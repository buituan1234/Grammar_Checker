# ==================================================
# Path: D:\buituan\project\Grammar_Checker
# Detected tech: javascript, python, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
Grammar_Checker/
├── .git/
├── .vscode/
├── backend/
│   ├── routes/
│   │   ├── grammar.js
│   │   ├── notificationRoutes.js
│   │   ├── statsRoutes.js
│   │   ├── usageRoutes.js
│   │   └── userRoutes.js
│   ├── services/
│   │   ├── cohereService.js
│   │   ├── languageToolService.js
│   │   └── notificationCleanup.js
│   ├── utils/
│   │   └── printConfidenceTable.js
│   └── server.js
├── frontend/
│   └── public/
│       ├── css/
│       │   ├── admin/
│       │   │   ├── badges.css
│       │   │   ├── base.css
│       │   │   ├── buttons.css
│       │   │   ├── cards.css
│       │   │   ├── checkboxes.css
│       │   │   ├── dashboard.css
│       │   │   ├── forms.css
│       │   │   ├── header.css
│       │   │   ├── main.css
│       │   │   ├── modals.css
│       │   │   ├── notifications.css
│       │   │   ├── responsive.css
│       │   │   └── tables.css
│       │   ├── grammar-checker/
│       │   │   ├── buttons.css
│       │   │   ├── contact-footer.css
│       │   │   ├── feature-grids.css
│       │   │   ├── forms-controls.css
│       │   │   ├── grammar-panels.css
│       │   │   ├── header-navigation.css
│       │   │   ├── main.css
│       │   │   ├── modals-messages.css
│       │   │   ├── panels-sections.css
│       │   │   ├── reset-base.css
│       │   │   ├── responsive.css
│       │   │   ├── utilities-animations.css
│       │   │   └── variables.css
│       │   ├── introduction/
│       │   │   ├── base.css
│       │   │   ├── buttons.css
│       │   │   ├── faq.css
│       │   │   ├── features.css
│       │   │   ├── footer.css
│       │   │   ├── header.css
│       │   │   ├── hero.css
│       │   │   ├── main.css
│       │   │   ├── modals.css
│       │   │   ├── responsive.css
│       │   │   └── testimonials.css
│       │   └── style/
│       │       ├── accessibility.css
│       │       ├── animations.css
│       │       ├── brand.css
│       │       ├── buttons.css
│       │       ├── decorations.css
│       │       ├── forms.css
│       │       ├── layout.css
│       │       ├── main.css
│       │       ├── navigation.css
│       │       ├── reset.css
│       │       ├── responsive.css
│       │       ├── utilities.css
│       │       └── variables.css
│       ├── images/
│       │   ├── Logo.jpg
│       │   ├── background.jpg
│       │   ├── facebook-icon.png
│       │   ├── future.jpg
│       │   ├── instagram-icon.png
│       │   ├── linkedin-icon.png
│       │   ├── starry-sky.jpg
│       │   ├── student.jpg
│       │   ├── tiktok-icon.png
│       │   ├── trang tri.jpg
│       │   ├── twitter-icon.png
│       │   └── web-icon.png
│       ├── js/
│       │   ├── admin/
│       │   │   ├── admin-api.js
│       │   │   ├── admin-auth.js
│       │   │   ├── admin-config.js
│       │   │   ├── admin-debug.js
│       │   │   ├── admin-events.js
│       │   │   ├── admin-forms.js
│       │   │   ├── admin-main.js
│       │   │   ├── admin-modals.js
│       │   │   ├── admin-state.js
│       │   │   ├── admin-storage.js
│       │   │   ├── admin-ui.js
│       │   │   ├── admin-utils.js
│       │   │   └── dashboard.js
│       │   ├── introduction/
│       │   │   ├── demoHandler.js
│       │   │   ├── grammarChecker.js
│       │   │   ├── intro-main.js
│       │   │   ├── languageUtils.js
│       │   │   ├── uiComponents.js
│       │   │   ├── usageManager.js
│       │   │   └── utils.js
│       │   ├── GrammarChecker1.js
│       │   ├── api.js
│       │   ├── bootstrap.bundle.min.js
│       │   ├── index.js
│       │   ├── login.js
│       │   ├── notifications.js
│       │   ├── sectionManager.js
│       │   └── utils.js
│       ├── GrammarChecker1.html
│       ├── admin-dashboard.html
│       ├── admin.html
│       ├── index.html
│       ├── introduction.html
│       └── login.html
├── node_modules/
├── .env
├── .gitignore
├── README.md
├── package-lock.json
├── package.json
└── source_dump.txt
```

## FILE CONTENTS

### backend\server.js
```js
// backend/server.js - FIXED VERSION
import express from 'express'; 
import cors from 'cors'; 
import rateLimit from 'express-rate-limit'; 
import helmet from 'helmet'; 
import compression from 'compression'; 
import sql from 'mssql'; 
import dotenv from 'dotenv'; 
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import notificationRoutes from './routes/notificationRoutes.js';
import { startNotificationCleanup } from './services/notificationCleanup.js';
import statsRoutes from './routes/statsRoutes.js';
import grammarRoutes from './routes/grammar.js'; 
import userRoutes from './routes/userRoutes.js'; 
import usageRoutes from './routes/usageRoutes.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

dotenv.config({ path: path.resolve(__dirname, '../.env') }); 

const app = express();
const PORT = process.env.PORT || 3000;

// SQL Server connection configuration
const dbConfig = {
    server: process.env.DB_SERVER,
    database: process.env.DB_DATABASE,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    options: {
        encrypt: false, 
        trustServerCertificate: true,
        instanceName: process.env.DB_INSTANCE 
    }
};

if (process.env.DB_USER && process.env.DB_USER.trim() !== '' && process.env.DB_PASSWORD && process.env.DB_PASSWORD.trim() !== '') {
    dbConfig.user = process.env.DB_USER.trim();
    dbConfig.password = process.env.DB_PASSWORD.trim();
    dbConfig.options.trustedConnection = false; 
} else {
    dbConfig.options.trustedConnection = true;
}

console.log('➡️ Connecting to SQL Server with config:');
console.log('Server:', dbConfig.server);
console.log('Database:', dbConfig.database);
if (dbConfig.user) {
    console.log('User:', dbConfig.user);
}
if (dbConfig.options.trustedConnection) {
    console.log('Authentication: Windows Authentication (Trusted Connection)');
} else if (dbConfig.user) {
    console.log('Authentication: SQL Server Authentication');
}

async function connectToDatabase() {
    try {
        const pool = new sql.ConnectionPool(dbConfig);
        await pool.connect();
        app.locals.db = pool; 
        console.log('✅ Connected to SQL Server database.');
        startNotificationCleanup(pool);
    } catch (err) {
        console.error('❌ Database connection failed:', err);
        process.exit(1); 
    }
}

connectToDatabase();

// Middleware order is CRITICAL
app.use(cors());
app.use(compression());

// ✅ FIX: Admin-specific CSP configuration BEFORE general helmet
app.use(['/admin.html', '/admin-dashboard.html', '/admin*'], (req, res, next) => {
    console.log('🔓 Setting permissive CSP for admin route:', req.path);
    
    // Set very permissive CSP for admin pages only
    res.setHeader('Content-Security-Policy', 
        "default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob: ws: wss:; " +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob: https://cdnjs.cloudflare.com; " +
        "script-src-elem 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob: https://cdnjs.cloudflare.com; " +
        "style-src 'self' 'unsafe-inline' https: data:; " +
        "font-src 'self' https: data:; " +
        "img-src 'self' https: data: blob:; " +
        "connect-src 'self' https: data: ws: wss:; " +
        "object-src 'none'; " +
        "base-uri 'self';"
    );
    next();
});

// ✅ FIX: General helmet configuration for other routes
app.use((req, res, next) => {
    if (req.path.includes('admin')) {
        // Skip helmet CSP for admin pages
        return next();
    }
    
    helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'", "'unsafe-inline'"],
                styleSrc: ["'self'", "'unsafe-inline'", "https:"],
                fontSrc: ["'self'", "https:", "data:"],
                imgSrc: ["'self'", "data:", "https:"],
                connectSrc: ["'self'"],
            },
        },
        crossOriginEmbedderPolicy: false,
    })(req, res, next);
});

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, 
    max: 100, 
    message: 'Too many requests from this IP, please try again after 15 minutes',
    standardHeaders: true,
    legacyHeaders: false,
});
app.use('/api/', limiter);

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// ✅ FIX: Static file serving with proper headers
app.use(express.static(path.join(__dirname, '../frontend/public'), {
    setHeaders: (res, path) => {
        // Set proper MIME types for JS modules
        if (path.endsWith('.js')) {
            res.setHeader('Content-Type', 'application/javascript');
        }
        // Allow CORS for admin files
        if (path.includes('admin')) {
            res.setHeader('Access-Control-Allow-Origin', '*');
        }
    }
}));

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '../frontend/public/introduction.html'));
});

// Routes
app.use('/api/grammar', grammarRoutes); 

app.use('/api/users', userRoutes);

app.use('/api/notifications', notificationRoutes);
app.use('/api/stats', statsRoutes);

app.use('/api/usage', usageRoutes);

app.get('/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});

app.get('/api/admin/users', async (req, res) => {
    console.log('🎯 Frontend calling /api/admin/users endpoint');
    
    try {
        if (!req.app.locals.db) {
            return res.status(500).json({ success: false, error: 'Database not connected' });
        }

        const result = await req.app.locals.db.request().query(`
            SELECT 
                UserID, Username, Email, Phone, UserRole, 
                FullName, AccountType, UserStatus, 
                FORMAT(CreatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as CreatedAt,
                FORMAT(UpdatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as UpdatedAt
            FROM Users
            ORDER BY CreatedAt DESC
        `);
        
        console.log('🔍 Backend response first user:', result.recordset[0]);
        console.log('📅 UpdatedAt from DB:', result.recordset[0]?.UpdatedAt);

        res.json({
            success: true,
            users: result.recordset
        });
    } catch (err) {
        console.error('❌ Error fetching users:', err);
        res.status(500).json({ success: false, error: err.message });
    }
});

app.get('/api/check', (req, res) => {
    res.json({ status: 'ok', message: 'API is running.' });
});

// ✅ ADD: Debug endpoint to check database connection
app.get('/api/debug/db', async (req, res) => {
    try {
        if (!req.app.locals.db) {
            return res.status(500).json({ 
                success: false, 
                error: 'Database pool not available' 
            });
        }
        
        const result = await req.app.locals.db.request().query('SELECT COUNT(*) as userCount FROM Users');
        res.json({ 
            success: true, 
            dbConnected: true,
            userCount: result.recordset[0].userCount
        });
    } catch (err) {
        res.status(500).json({ 
            success: false, 
            error: err.message,
            dbConnected: false 
        });
    }
});

app.use((err, req, res, next) => {
    console.error('Error:', err);
    res.status(500).json({
        success: false,
        error: 'Internal Server Error',
        message: err.message 
    });
});

app.listen(PORT, () => {
    console.log(`🚀 Server running on port ${PORT}`);
    console.log(`📊 Admin panel: http://localhost:${PORT}/admin.html`);
    console.log(`🔍 API check: http://localhost:${PORT}/api/check`);
    console.log(`🔍 DB debug: http://localhost:${PORT}/api/debug/db`);
    
    if (!process.env.COHERE_API_KEY) {
        console.warn('⚠️ COHERE_API_KEY is not set. Cohere API (grammar fallback) will not work.');
    }
}

);
```

### backend\routes\grammar.js
```js
import express from 'express';
import languageToolService from '../services/languageToolService.js';
import { fallbackCheckWithCohere, validateCorrectionsWithCohere } from '../services/cohereService.js';
import dotenv from 'dotenv';
dotenv.config();

const router = express.Router();

/**
 * Detect language from input text
 */
router.post('/detect', async (req, res) => {
  const { text } = req.body;

  try {
    const lang = await languageToolService.detectLanguage(text);
    res.json({ success: true, language: lang });
  } catch (error) {
    console.error('❌ Language detection failed:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Get supported languages
 */
router.get('/languages', async (req, res) => {
  try {
    const languages = await languageToolService.getLanguages();
    res.json({ success: true, data: { languages } });
  } catch (error) {
    console.error('❌ Failed to fetch languages:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Check grammar: Cohere → Validate by LT → fallback LT if necessary
 */
router.post('/check', async (req, res) => {
  const { text, language = 'auto' } = req.body;

  if (!text || typeof text !== 'string' || !text.trim()) {
    return res.status(400).json({ success: false, error: 'Missing or invalid text.' });
  }

  try {
    const normalizedLang = language === 'auto' ? 'en' : language;
    const cohereStart = Date.now();

    // Step 1: Use Cohere to detect suggestions
    const cohereMatches = await fallbackCheckWithCohere(text);
    console.log(`✅ Cohere returned ${cohereMatches.length} matches in ${Date.now() - cohereStart} ms.`);

    // Step 2: Validate Cohere's suggestions using LanguageTool
    const validatedCohereMatches = await languageToolService.validateCohereSuggestions(text, cohereMatches);
    const validationTime = Date.now() - cohereStart;
    console.log(`✅ LanguageTool validated ${validatedCohereMatches.length} matches in ${validationTime} ms.`);

    // Step 3: If Cohere didn't find anything, fallback to full LanguageTool check
    let ltResult = { matches: [] };

    if (!validatedCohereMatches.length) {
      const ltStart = Date.now();
      ltResult = await languageToolService.checkGrammar(text, normalizedLang);
      console.log(`✅ LanguageTool returned ${ltResult.matches.length} matches in ${Date.now() - ltStart} ms.`);
    } else {
      console.log('⚠️ Skipping full LanguageTool check because Cohere found issues.');
    }

    const finalMatches = [...validatedCohereMatches];

    // Merge additional LT suggestions (avoid duplicate offset-length)
    if (ltResult?.matches?.length) {
      const existingOffsets = new Set(finalMatches.map(m => `${m.offset}-${m.length}`));
      for (const m of ltResult.matches) {
        const key = `${m.offset}-${m.length}`;
        if (!existingOffsets.has(key)) {
          finalMatches.push({
            ...m,
            source: 'languagetool',
            replacements: m.replacements?.map(r => ({ value: r.value }))
          });
        }
      }
    }

    return res.json({ success: true, data: { matches: finalMatches } });

  } catch (error) {
    console.error('❌ Grammar check failed:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

export default router;

```

### backend\routes\notificationRoutes.js
```js
// backend/routes/notificationRoutes.js
import express from 'express';
import sql from 'mssql';

const router = express.Router();

// Utility function to get database pool (same pattern as userRoutes.js)
function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('❌ Database pool not available in req.app.locals.db');
        throw new Error('Database pool not available.');
    }
    console.log('✅ Database pool retrieved successfully');
    return req.app.locals.db;
}

// Middleware to check if user is admin (same as userRoutes.js)
const isAdmin = (req, res, next) => {
    console.log('🔐 Admin middleware - checking authorization...');
    const userRole = req.headers['x-user-role'] || req.body.userRole;
    console.log(`🔍 Extracted user role: "${userRole}"`);

    if (userRole === 'admin') {
        console.log('✅ Admin access granted');
        next();
    } else {
        console.log(`❌ Admin access denied. Role: "${userRole}"`);
        res.status(403).json({ 
            success: false, 
            error: 'Access denied. Admin privileges required.',
            receivedRole: userRole,
            expectedRole: 'admin'
        });
    }
};

// Middleware to check authentication (basic auth check)
const requireAuth = (req, res, next) => {
    const userId = req.headers['x-user-id'] || req.params.userId;
    const userRole = req.headers['x-user-role'];
    
    if (!userId || !userRole) {
        return res.status(401).json({
            success: false,
            error: 'Authentication required. Missing user credentials.'
        });
    }
    
    // Store in req for later use
    req.authenticatedUser = {
        id: parseInt(userId),
        role: userRole
    };
    
    next();
};

// 🔔 CREATE NOTIFICATION (Internal function - called when admin updates user)
export const createNotification = async (pool, notificationData) => {
    try {
        const request = pool.request();
        
        const query = `
            INSERT INTO Notifications (
                UserID, Title, Message, Type, IsRead, 
                AdminAction, AdminID, Metadata, CreatedAt
            )
            VALUES (
                @UserID, @Title, @Message, @Type, 0,
                @AdminAction, @AdminID, @Metadata, GETDATE()
            );
            SELECT SCOPE_IDENTITY() as NotificationID;
        `;

        request.input('UserID', sql.Int, notificationData.userID);
        request.input('Title', sql.NVarChar(255), notificationData.title);
        request.input('Message', sql.NVarChar(500), notificationData.message);
        request.input('Type', sql.VarChar(50), notificationData.type || 'profile_update');
        request.input('AdminAction', sql.NVarChar(100), notificationData.adminAction);
        request.input('AdminID', sql.Int, notificationData.adminID);
        request.input('Metadata', sql.NVarChar(sql.MAX), JSON.stringify(notificationData.metadata || {}));

        const result = await request.query(query);
        const notificationId = result.recordset[0].NotificationID;

        console.log('✅ Notification created successfully:', {
            id: notificationId,
            userID: notificationData.userID,
            type: notificationData.type
        });

        return { success: true, notificationId };

    } catch (err) {
        console.error('❌ Error creating notification:', err);
        throw err;
    }
};

// 📱 GET USER NOTIFICATIONS - Get all notifications for a specific user
router.get('/user/:userId', requireAuth, async (req, res) => {
    const userId = parseInt(req.params.userId);
    const { limit = 50, offset = 0, unreadOnly = false } = req.query;

    // Security check: users can only see their own notifications
    if (req.authenticatedUser.role !== 'admin' && req.authenticatedUser.id !== userId) {
        return res.status(403).json({
            success: false,
            error: 'Access denied. You can only view your own notifications.'
        });
    }

    console.log(`📱 Fetching notifications for user ${userId}`, { limit, offset, unreadOnly });

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        let whereClause = 'WHERE n.UserID = @userId';
        if (unreadOnly === 'true') {
            whereClause += ' AND n.IsRead = 0';
        }

        const query = `
            SELECT 
                n.NotificationID,
                n.UserID,
                n.Title,
                n.Message,
                n.Type,
                n.IsRead,
                n.AdminAction,
                n.AdminID,
                u.Username as AdminUsername,
                u.fullName as AdminName,
                n.Metadata,
                n.CreatedAt,
                n.ReadAt
            FROM Notifications n
            LEFT JOIN Users u ON n.AdminID = u.UserID
            ${whereClause}
            ORDER BY n.CreatedAt DESC
            OFFSET @offset ROWS
            FETCH NEXT @limit ROWS ONLY;
        `;

        request.input('userId', sql.Int, userId);
        request.input('limit', sql.Int, parseInt(limit));
        request.input('offset', sql.Int, parseInt(offset));

        const result = await request.query(query);

        // Get unread count
        const countQuery = `
            SELECT COUNT(*) as unreadCount 
            FROM Notifications 
            WHERE UserID = @userId AND IsRead = 0;
        `;
        
        const countResult = await pool.request()
            .input('userId', sql.Int, userId)
            .query(countQuery);

        const notifications = result.recordset.map(notification => ({
            ...notification,
            Metadata: notification.Metadata ? JSON.parse(notification.Metadata) : {}
        }));

        res.json({
            success: true,
            notifications,
            meta: {
                total: result.recordset.length,
                unreadCount: countResult.recordset[0].unreadCount,
                limit: parseInt(limit),
                offset: parseInt(offset)
            }
        });

    } catch (err) {
        console.error('❌ Error fetching notifications:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error fetching notifications.',
            details: err.message
        });
    }
});

// ✅ MARK NOTIFICATION AS READ
router.patch('/:notificationId/read', requireAuth, async (req, res) => {
    const notificationId = parseInt(req.params.notificationId);

    console.log(`✅ Marking notification ${notificationId} as read`);

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        // First, check if notification belongs to the authenticated user (security)
        const checkQuery = `
            SELECT UserID FROM Notifications WHERE NotificationID = @notificationId;
        `;

        request.input('notificationId', sql.Int, notificationId);
        const checkResult = await request.query(checkQuery);

        if (checkResult.recordset.length === 0) {
            return res.status(404).json({
                success: false,
                error: 'Notification not found.'
            });
        }

        const notificationUserId = checkResult.recordset[0].UserID;

        // Security check: users can only mark their own notifications as read
        if (req.authenticatedUser.role !== 'admin' && req.authenticatedUser.id !== notificationUserId) {
            return res.status(403).json({
                success: false,
                error: 'Access denied. You can only modify your own notifications.'
            });
        }

        // Update notification as read
        const updateQuery = `
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = GETDATE()
            WHERE NotificationID = @notificationId AND IsRead = 0;
        `;

        const updateResult = await pool.request()
            .input('notificationId', sql.Int, notificationId)
            .query(updateQuery);

        if (updateResult.rowsAffected[0] > 0) {
            res.json({
                success: true,
                message: 'Notification marked as read successfully.'
            });
        } else {
            res.json({
                success: true,
                message: 'Notification was already marked as read.'
            });
        }

    } catch (err) {
        console.error('❌ Error marking notification as read:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error updating notification.',
            details: err.message
        });
    }
});

// ✅ MARK ALL NOTIFICATIONS AS READ FOR A USER
router.patch('/user/:userId/mark-all-read', requireAuth, async (req, res) => {
    const userId = parseInt(req.params.userId);

    // Security check: users can only mark their own notifications
    if (req.authenticatedUser.role !== 'admin' && req.authenticatedUser.id !== userId) {
        return res.status(403).json({
            success: false,
            error: 'Access denied. You can only modify your own notifications.'
        });
    }

    console.log(`✅ Marking all notifications as read for user ${userId}`);

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        const query = `
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = GETDATE()
            WHERE UserID = @userId AND IsRead = 0;
        `;

        request.input('userId', sql.Int, userId);
        const result = await request.query(query);

        res.json({
            success: true,
            message: `${result.rowsAffected[0]} notifications marked as read.`,
            markedCount: result.rowsAffected[0]
        });

    } catch (err) {
        console.error('❌ Error marking all notifications as read:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error updating notifications.',
            details: err.message
        });
    }
});

// 👨‍💼 ADMIN: Get notifications sent by specific admin
router.get('/admin/sent/:adminId', isAdmin, async (req, res) => {
    const adminId = parseInt(req.params.adminId);
    const { limit = 100, offset = 0, dateFrom, dateTo } = req.query;

    console.log(`👨‍💼 Admin ${adminId} fetching sent notifications`);

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        let whereClause = 'WHERE n.AdminID = @adminId';
        
        if (dateFrom) {
            whereClause += ' AND n.CreatedAt >= @dateFrom';
            request.input('dateFrom', sql.DateTime, new Date(dateFrom));
        }
        
        if (dateTo) {
            whereClause += ' AND n.CreatedAt <= @dateTo';
            request.input('dateTo', sql.DateTime, new Date(dateTo));
        }

        const query = `
            SELECT 
                n.NotificationID,
                n.UserID,
                u.Username,
                u.fullName as UserName,
                u.Email as UserEmail,
                n.Title,
                n.Message,
                n.Type,
                n.IsRead,
                n.AdminAction,
                n.CreatedAt,
                n.ReadAt
            FROM Notifications n
            INNER JOIN Users u ON n.UserID = u.UserID
            ${whereClause}
            ORDER BY n.CreatedAt DESC
            OFFSET @offset ROWS
            FETCH NEXT @limit ROWS ONLY;
        `;

        request.input('adminId', sql.Int, adminId);
        request.input('limit', sql.Int, parseInt(limit));
        request.input('offset', sql.Int, parseInt(offset));

        const result = await request.query(query);

        // Get stats
        const statsQuery = `
            SELECT 
                COUNT(*) as totalSent,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readCount,
                SUM(CASE WHEN IsRead = 0 THEN 1 ELSE 0 END) as unreadCount
            FROM Notifications 
            WHERE AdminID = @adminId
            ${dateFrom ? 'AND CreatedAt >= @dateFrom' : ''}
            ${dateTo ? 'AND CreatedAt <= @dateTo' : ''};
        `;

        const statsRequest = pool.request().input('adminId', sql.Int, adminId);
        if (dateFrom) statsRequest.input('dateFrom', sql.DateTime, new Date(dateFrom));
        if (dateTo) statsRequest.input('dateTo', sql.DateTime, new Date(dateTo));
        
        const statsResult = await statsRequest.query(statsQuery);

        res.json({
            success: true,
            notifications: result.recordset,
            stats: statsResult.recordset[0],
            meta: {
                limit: parseInt(limit),
                offset: parseInt(offset)
            }
        });

    } catch (err) {
        console.error('❌ Error fetching admin sent notifications:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error fetching admin notifications.',
            details: err.message
        });
    }
});

// 🧹 CLEANUP OLD NOTIFICATIONS (older than 3 days)
router.delete('/cleanup', isAdmin, async (req, res) => {
    console.log('🧹 Starting notification cleanup (older than 3 days)');

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        const query = `
            DELETE FROM Notifications 
            WHERE CreatedAt < DATEADD(day, -3, GETDATE());
        `;

        const result = await request.query(query);

        console.log(`🧹 Cleanup completed. Deleted ${result.rowsAffected[0]} old notifications`);

        res.json({
            success: true,
            message: `Cleanup completed. ${result.rowsAffected[0]} old notifications deleted.`,
            deletedCount: result.rowsAffected[0]
        });

    } catch (err) {
        console.error('❌ Error during notification cleanup:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error during cleanup.',
            details: err.message
        });
    }
});

// 📊 GET NOTIFICATION STATISTICS (for admin dashboard)
router.get('/admin/stats', isAdmin, async (req, res) => {
    console.log('📊 Fetching notification statistics');

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        const query = `
            SELECT 
                COUNT(*) as totalNotifications,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readNotifications,
                SUM(CASE WHEN IsRead = 0 THEN 1 ELSE 0 END) as unreadNotifications,
                COUNT(DISTINCT UserID) as usersWithNotifications,
                COUNT(DISTINCT AdminID) as adminsWhoSent
            FROM Notifications;

            SELECT 
                Type,
                COUNT(*) as count,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readCount
            FROM Notifications
            GROUP BY Type
            ORDER BY count DESC;

            SELECT TOP 10
                u.Username,
                u.fullName,
                COUNT(*) as notificationCount
            FROM Notifications n
            INNER JOIN Users u ON n.UserID = u.UserID
            GROUP BY u.UserID, u.Username, u.fullName
            ORDER BY notificationCount DESC;
        `;

        const result = await request.query(query);

        res.json({
            success: true,
            stats: {
                overview: result.recordsets[0][0],
                byType: result.recordsets[1],
                topUsers: result.recordsets[2]
            }
        });

    } catch (err) {
        console.error('❌ Error fetching notification stats:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error fetching stats.',
            details: err.message
        });
    }
});

export default router;
```

### backend\routes\statsRoutes.js
```js
// backend/routes/statsRoutes.js
import express from 'express';

const router = express.Router();

// Utility function to get database pool
function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('Database pool not available in req.app.locals.db');
        throw new Error('Database pool not available.');
    }
    return req.app.locals.db;
}

// Middleware to check if user is admin
const isAdmin = (req, res, next) => {
    const userRole = req.headers['x-user-role'] || req.body.userRole;
    if (userRole === 'admin') {
        next();
    } else {
        res.status(403).json({ 
            success: false, 
            error: 'Access denied. Admin privileges required.'
        });
    }
};

// GET /api/stats/account-types - Account type statistics
router.get('/account-types', isAdmin, async (req, res) => {
    try {
        const pool = getDbPool(req);
        const result = await pool.request().query(`
            SELECT 
                AccountType,
                COUNT(*) as count,
                CAST(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS DECIMAL(5,2)) as percentage
            FROM Users 
            WHERE UserStatus = 'active'
            GROUP BY AccountType
            ORDER BY count DESC
        `);

        const stats = {
            total: result.recordset.reduce((sum, item) => sum + item.count, 0),
            breakdown: result.recordset.map(item => ({
                type: item.AccountType,
                count: item.count,
                percentage: parseFloat(item.percentage)
            }))
        };

        res.json({
            success: true,
            data: stats
        });

    } catch (err) {
        console.error('Error fetching account type stats:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error fetching account statistics.'
        });
    }
});

// GET /api/stats/languages - Language usage statistics
router.get('/languages', isAdmin, async (req, res) => {
  try {
    const pool = getDbPool(req);

    // Thống kê số lần sử dụng theo ngôn ngữ từ bảng UsageLogs
    const result = await pool.request().query(`
      SELECT 
        ISNULL(Language, 'unknown') AS language,
        COUNT(*) AS usage_count
      FROM UsageLogs
      WHERE Action = 'grammar_check'
      GROUP BY ISNULL(Language, 'unknown')
      ORDER BY usage_count DESC;
    `);

    if (!result.recordset || result.recordset.length === 0) {
      return res.json({
        success: true,
        data: {
          total_usage: 0,
          most_used: null,
          least_used: null,
          languages: []
        }
      });
    }

    // Bản đồ ngôn ngữ -> tên hiển thị
    const languageMap = {
      'en-US': 'English (US)',
      'vi': 'Vietnamese',
      'fr': 'French',
      'de': 'German',
      'es': 'Spanish',
      'ja-JP': 'Japanese',
      'unknown': 'Unknown'
    };

    const totalUsage = result.recordset.reduce((sum, item) => sum + item.usage_count, 0);

    const stats = {
      total_usage: totalUsage,
      most_used: {
        ...result.recordset[0],
        language_name: languageMap[result.recordset[0].language] || result.recordset[0].language
      },
      least_used: {
        ...result.recordset[result.recordset.length - 1],
        language_name: languageMap[result.recordset[result.recordset.length - 1].language] || result.recordset[result.recordset.length - 1].language
      },
      languages: result.recordset.map(item => ({
        language: item.language,
        language_name: languageMap[item.language] || item.language,
        usage_count: item.usage_count,
        percentage: ((item.usage_count / totalUsage) * 100).toFixed(2)
      }))
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (err) {
    console.error('Error fetching language stats:', err);
    res.status(500).json({
      success: false,
      error: 'Internal server error fetching language statistics: ' + err.message
    });
  }
});

// GET /api/stats/timeframe?range=hour|day|month|year&action=login
router.get('/timeframe', isAdmin, async (req, res) => {
  try {
    const { range = 'day', action } = req.query;
    const pool = getDbPool(req);

    if (!['hour', 'day', 'month', 'year'].includes(range)) {
      return res.status(400).json({
        success: false,
        error: "Invalid range. Use: hour, day, month, or year"
      });
    }

    // Nếu có action thì lọc, ví dụ action=login
    const actionFilter = action ? `AND u.Action = '${action}'` : '';

    let query = '';

    switch (range) {
      case 'hour': 
        query = `
          ;WITH Hours AS (
            SELECT 0 AS h UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3
            UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7
            UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11
            UNION ALL SELECT 12 UNION ALL SELECT 13 UNION ALL SELECT 14 UNION ALL SELECT 15
            UNION ALL SELECT 16 UNION ALL SELECT 17 UNION ALL SELECT 18 UNION ALL SELECT 19
            UNION ALL SELECT 20 UNION ALL SELECT 21 UNION ALL SELECT 22 UNION ALL SELECT 23
          )
          SELECT 
            h AS period,
            'Hour ' + CAST(h AS VARCHAR(2)) AS period_label,
            COUNT(u.LogID) AS activity_count
          FROM Hours h
          LEFT JOIN UsageLogs u
            ON DATEPART(HOUR, u.CreatedAt) = h.h
           AND u.CreatedAt >= DATEADD(day, -1, GETDATE())
           ${actionFilter}
          GROUP BY h
          ORDER BY h;
        `;
        break;

      case 'day': 
        query = `
          ;WITH Days AS (
            SELECT CAST(GETDATE() AS DATE) AS d
            UNION ALL
            SELECT DATEADD(DAY, -1, d) FROM Days WHERE d > DATEADD(DAY, -29, GETDATE())
          )
          SELECT 
            d AS period,
            FORMAT(d, 'MMM dd') AS period_label,
            COUNT(u.LogID) AS activity_count
          FROM Days
          LEFT JOIN UsageLogs u
            ON CAST(u.CreatedAt AS DATE) = d
           ${actionFilter}
          GROUP BY d
          ORDER BY d;
        `;
        break;

      case 'month': 
        query = `
          ;WITH Months AS (
            SELECT DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1) AS m
            UNION ALL
            SELECT DATEADD(MONTH, -1, m) FROM Months WHERE m > DATEADD(MONTH, -11, GETDATE())
          )
          SELECT 
            YEAR(m) * 100 + MONTH(m) AS period,
            FORMAT(m, 'MMM yyyy') AS period_label,
            COUNT(u.LogID) AS activity_count
          FROM Months
          LEFT JOIN UsageLogs u
            ON YEAR(u.CreatedAt) = YEAR(m) 
           AND MONTH(u.CreatedAt) = MONTH(m)
           ${actionFilter}
          GROUP BY m
          ORDER BY m;
        `;
        break;

      case 'year': 
        query = `
          ;WITH Years AS (
            SELECT YEAR(GETDATE()) AS y
            UNION ALL
            SELECT y - 1 FROM Years WHERE y > YEAR(GETDATE()) - 4
          )
          SELECT 
            y AS period,
            CAST(y AS VARCHAR(4)) AS period_label,
            COUNT(u.LogID) AS activity_count
          FROM Years
          LEFT JOIN UsageLogs u
            ON YEAR(u.CreatedAt) = y
           ${actionFilter}
          GROUP BY y
          ORDER BY y;
        `;
        break;
    }

    const result = await pool.request().query(query);

    const stats = {
      range,
      total_activity: result.recordset.reduce((sum, item) => sum + item.activity_count, 0),
      data: result.recordset.map(item => ({
        period: item.period_label,
        count: item.activity_count
      }))
    };

    res.json({ success: true, data: stats });
  } catch (err) {
    console.error('Error fetching timeframe stats:', err);
    res.status(500).json({
      success: false,
      error: 'Internal server error fetching timeframe statistics: ' + err.message
    });
  }
});


// GET /api/stats/overview - Dashboard overview stats
router.get('/overview', isAdmin, async (req, res) => {
    try {
        const pool = getDbPool(req);
        
        // Get multiple statistics in one go
        const result = await pool.request().query(`
            -- Total users by status
            SELECT 'total_users' as stat_type, COUNT(*) as value
            FROM Users
            
            UNION ALL
            
            -- Active users
            SELECT 'active_users' as stat_type, COUNT(*) as value
            FROM Users WHERE UserStatus = 'active'
            
            UNION ALL
            
            -- Total notifications
            SELECT 'total_notifications' as stat_type, COUNT(*) as value
            FROM Notifications
            
            UNION ALL
            
            -- Unread notifications
            SELECT 'unread_notifications' as stat_type, COUNT(*) as value
            FROM Notifications WHERE IsRead = 0
            
            UNION ALL
            
            -- Users created today
            SELECT 'new_users_today' as stat_type, COUNT(*) as value
            FROM Users WHERE CAST(CreatedAt AS DATE) = CAST(GETDATE() AS DATE)
            
            UNION ALL
            
            -- Users created this month
            SELECT 'new_users_this_month' as stat_type, COUNT(*) as value
            FROM Users 
            WHERE YEAR(CreatedAt) = YEAR(GETDATE()) 
            AND MONTH(CreatedAt) = MONTH(GETDATE())
        `);

        // Transform result into object
        const stats = {};
        result.recordset.forEach(row => {
            stats[row.stat_type] = row.value;
        });

        res.json({
            success: true,
            data: stats
        });

    } catch (err) {
        console.error('Error fetching overview stats:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error fetching overview statistics.'
        });
    }
});

// GET /api/stats/export - Export statistics to Excel
router.get('/export', isAdmin, async (req, res) => {
    try {
        const pool = getDbPool(req);
        
        // Get comprehensive data for export
        const result = await pool.request().query(`
            SELECT 
                u.UserID,
                u.Username,
                u.Email,
                u.UserRole,
                u.AccountType,
                u.UserStatus,
                u.CreatedAt,
                COUNT(n.NotificationID) as NotificationCount,
                SUM(CASE WHEN n.IsRead = 0 THEN 1 ELSE 0 END) as UnreadNotifications
            FROM Users u
            LEFT JOIN Notifications n ON u.UserID = n.UserID
            GROUP BY u.UserID, u.Username, u.Email, u.UserRole, u.AccountType, u.UserStatus, u.CreatedAt
            ORDER BY u.CreatedAt DESC
        `);

        // Format data for export
        const exportData = {
            export_date: new Date().toISOString(),
            total_records: result.recordset.length,
            data: result.recordset.map(row => ({
                user_id: row.UserID,
                username: row.Username,
                email: row.Email,
                role: row.UserRole,
                account_type: row.AccountType,
                status: row.UserStatus,
                created_at: row.CreatedAt,
                notification_count: row.NotificationCount,
                unread_notifications: row.UnreadNotifications
            }))
        };

        res.json({
            success: true,
            data: exportData
        });

    } catch (err) {
        console.error('Error exporting stats:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error exporting statistics.'
        });
    }
});

export default router;
```

### backend\routes\usageRoutes.js
```js
// backend/routes/usageRoutes.js
import express from 'express';
import sql from 'mssql';

const router = express.Router();

// POST /api/usage/log - Log user activity
router.post('/log', async (req, res) => {
  try {
    const pool = req.app.locals.db;
    if (!pool) {
      console.error('Usage log: DB pool not available', { headers: req.headers, body: req.body });
      return res.status(503).json({ success: false, error: 'Database not available' });
    }

    console.log('Usage log request body:', req.body);
    console.log('Usage log request headers:', {
      'x-user-id': req.headers['x-user-id'],
      'x-user-role': req.headers['x-user-role'],
      ua: req.headers['user-agent'],
    });

    const rawUserId = req.body?.user_id ?? req.body?.UserID ?? req.body?.user?.id ?? req.headers['x-user-id'] ?? null;
    const UserID = rawUserId ? parseInt(rawUserId, 10) : null;

    const action = (req.body?.action ?? '').toString().trim();
    if (!action) {
      return res.status(400).json({ success: false, error: 'Missing action in request body' });
    }

    const language = req.body?.language ?? req.body?.lang ?? null;
    const detailsObj = req.body?.metadata ?? req.body?.details ?? req.body?.message ?? {};
    const Details = (typeof detailsObj === 'string') ? detailsObj : JSON.stringify(detailsObj);

    // IP detection with x-forwarded-for fallback
    const ipHeader = req.headers['x-forwarded-for'] || '';
    const ipFromHeader = ipHeader.split(',').map(s => s.trim()).find(Boolean) || null;
    const IPAddress = (ipFromHeader || req.ip || req.socket?.remoteAddress || '').toString();

    const UserAgent = (req.headers['user-agent'] || req.body?.user_agent || '').toString();

    await pool.request()
      .input('UserID', sql.Int, UserID)
      .input('Action', sql.VarChar(255), action)
      .input('Language', sql.VarChar(50), language)
      .input('Details', sql.NVarChar(sql.MAX), Details)
      .input('IPAddress', sql.VarChar(100), IPAddress)
      .input('UserAgent', sql.NVarChar(sql.MAX), UserAgent)
      .query(`
        INSERT INTO UsageLogs 
          (UserID, Action, Language, Details, IPAddress, UserAgent, CreatedAt)
        VALUES 
          (@UserID, @Action, @Language, @Details, @IPAddress, @UserAgent, GETDATE())
      `);

    return res.json({ success: true });
  } catch (error) {
    console.error('Error logging usage:', error.stack || error);
    return res.status(500).json({ success: false, error: 'Failed to log usage', detail: error?.message });
  }
});

export default router;

```

### backend\routes\userRoutes.js
```js
// backend/routes/userRoutes.js - FIXED VERSION WITH isAdmin MIDDLEWARE
import express from 'express';
import sql from 'mssql';
import bcrypt from 'bcrypt';
import { createNotification } from './notificationRoutes.js';

const router = express.Router();

function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('❌ Database pool not available in req.app.locals.db');
        throw new Error('Database pool not available.');
    }
    console.log('✅ Database pool retrieved successfully');
    return req.app.locals.db;
}

const isAdmin = (req, res, next) => {
    console.log('🔐 Admin middleware - checking authorization...');
    const userRole = req.headers['x-user-role'] || req.body.userRole;
    console.log(`🔍 Extracted user role: "${userRole}"`);

    if (userRole === 'admin') {
        console.log('✅ Admin access granted');
        next();
    } else {
        console.log(`❌ Admin access denied. Role: "${userRole}"`);
        res.status(403).json({ 
            success: false, 
            error: 'Access denied. Admin privileges required.',
            receivedRole: userRole,
            expectedRole: 'admin'
        });
    }
};

// --- Update user by ID (for admin.js fallback compatibility)
router.put('/:id', async (req, res) => {
    const userId = req.params.id;
    const { username, email, phone, fullName, role, accountType, status } = req.body;

    if (!username || !email || !fullName) {
        return res.status(400).json({
            success: false,
            error: 'Username, email, and full name are required.'
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        const query = `
            UPDATE Users
            SET 
                Username = @username,
                Email = @email,
                Phone = @phone,
                fullName = @fullName,
                UserRole = @role,
                AccountType = @accountType,
                UserStatus = @status
            WHERE UserID = @updateUserId;
        `;

        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('fullName', sql.NVarChar(100), fullName);
        request.input('role', sql.NVarChar(50), role || 'user');
        request.input('accountType', sql.NVarChar(50), accountType || 'free');
        request.input('status', sql.NVarChar(50), status || 'active');
        request.input('updateUserId', sql.Int, userId);

        const result = await request.query(query);

        if (result.rowsAffected[0] > 0) {
            res.json({ success: true, message: 'User updated successfully.' });
        } else {
            res.status(404).json({ success: false, error: 'User not found or no changes made.' });
        }
    } catch (err) {
        res.status(500).json({
            success: false,
            error: 'Internal server error updating user.',
            details: err.message
        });
    }
});

// --- Register (for regular users, no admin required)
router.post('/register', async (req, res) => {
    const { username, password, email, phone, fullName } = req.body;
    
    console.log('📝 User registration attempt - FULL REQUEST BODY:', req.body);
    console.log('📝 Extracted fields:', {
        username,
        password: password ? '***' : 'MISSING',
        email,
        phone: phone || 'Not provided',
        fullName: fullName || 'MISSING'
    });

    if (!username || !password || !email || !fullName) {
        console.log('❌ Registration failed: Missing required fields');
        console.log('❌ Missing fields check:', {
            username: !username ? 'MISSING' : 'OK',
            password: !password ? 'MISSING' : 'OK', 
            email: !email ? 'MISSING' : 'OK',
            fullName: !fullName ? 'MISSING' : 'OK'
        });
        return res.status(400).json({ 
            success: false, 
            error: 'Username, password, email, and full name are required.',
            received: Object.keys(req.body)
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);

        console.log('🔍 Checking for existing username/email...');
        const checkResult = await request.query`
            SELECT COUNT(*) AS count FROM Users WHERE Username = @username OR Email = @email;
        `;

        if (checkResult.recordset[0].count > 0) {
            console.log('❌ Registration failed: Username or email already exists');
            return res.status(409).json({ 
                success: false, 
                error: 'Username or email already exists.' 
            });
        }

        console.log('🔐 Hashing password...');
        const hashedPassword = await bcrypt.hash(password, 10);

        const query = `
            INSERT INTO Users (Username, PasswordHash, Email, Phone, UserRole, fullName, CreatedAt, UserStatus, AccountType)
            VALUES (@username, @hashedPassword, @email, @phone, 'user', @fullName, GETDATE(), 'active', 'free');
        `;

        request.input('hashedPassword', sql.NVarChar(255), hashedPassword);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('fullName', sql.NVarChar(100), fullName);

        console.log('💾 Inserting new user into database...');
        await request.query(query);

        console.log('✅ User registered successfully:', username);
        res.status(201).json({ 
            success: true, 
            message: 'User registered successfully.' 
        });

    } catch (err) {
        console.error('❌ Error registering user:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error during registration.',
            details: err.message
        });
    }
});

// --- Login ---
router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    console.log('🔑 Login attempt for username:', username);

    if (!username || !password) {
        return res.status(400).json({ 
            success: false, 
            error: 'Username and password are required.' 
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();
        request.input('username', sql.NVarChar(50), username);

        const result = await request.query`
            SELECT UserID, Username, PasswordHash, Email, Phone, UserRole, fullName
            FROM Users WHERE Username = @username;
        `;

        if (result.recordset.length === 0) {
            return res.status(401).json({ 
                success: false, 
                error: 'Invalid username or password.' 
            });
        }

        const user = result.recordset[0];
        const isPasswordValid = await bcrypt.compare(password, user.PasswordHash);

        if (isPasswordValid) {
            res.json({
                success: true,
                message: 'Login successful.',
                userId: user.UserID,      
                username: user.Username, 
                email: user.Email,        
                phone: user.Phone,        
                userRole: user.UserRole,
                fullName: user.fullName
            });
        } else {
            res.status(401).json({ 
                success: false, 
                error: 'Invalid username or password.' 
            });
        }

    } catch (err) {
        console.error('❌ Error during login:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error during login.',
            details: err.message
        });
    }
});

// --- Admin: Update user ---
router.put('/admin/update/:id', isAdmin, async (req, res) => {
    const userId = req.params.id;
    const { username, email, phone, fullName, role, accountType, status } = req.body;

    console.log('🔄 Admin updating user:', { userId, username, accountType, status, role });

    if (!username || !email || !fullName) {
        return res.status(400).json({ 
            success: false, 
            error: 'Username, email, and full name are required.' 
        });
    }

    try {
        const pool = getDbPool(req);
        
        // FIRST: Get current user data for comparison
        const getCurrentUserRequest = pool.request();
        getCurrentUserRequest.input('userId', sql.Int, userId);
        
        const currentUserQuery = `
            SELECT Username, Email, Phone, fullName, UserRole, AccountType, UserStatus 
            FROM Users WHERE UserID = @userId;
        `;
        
        const currentUserResult = await getCurrentUserRequest.query(currentUserQuery);
        
        if (currentUserResult.recordset.length === 0) {
            return res.status(404).json({ success: false, error: 'User not found.' });
        }
        
        const currentUser = currentUserResult.recordset[0];
        console.log('📋 Current user data:', currentUser);

        // UPDATE user data
        const updateRequest = pool.request();
        const query = `
            UPDATE Users
            SET Username = @username, 
                Email = @email, 
                Phone = @phone, 
                fullName = @fullName,
                UserRole = @role,
                AccountType = @accountType,
                UserStatus = @status,
                UpdatedAt = GETDATE()
            WHERE UserID = @updateUserId;
        `;

        updateRequest.input('username', sql.NVarChar(50), username);
        updateRequest.input('email', sql.NVarChar(100), email);
        updateRequest.input('phone', sql.NVarChar(20), phone || null);
        updateRequest.input('fullName', sql.NVarChar(100), fullName);
        updateRequest.input('role', sql.NVarChar(50), role || 'user');
        updateRequest.input('accountType', sql.NVarChar(50), accountType || 'free');
        updateRequest.input('status', sql.NVarChar(50), status || 'active');
        updateRequest.input('updateUserId', sql.Int, userId);

        console.log('💾 Executing SQL update with params:', { 
            username, email, fullName, role, accountType, status 
        });

        const result = await updateRequest.query(query);

        if (result.rowsAffected[0] > 0) {
            // THÊM: Query lại user vừa update để trả về data mới với format đúng
            const updatedUserQuery = pool.request();
            updatedUserQuery.input('userId', sql.Int, userId);
                         
            const updatedUserResult = await updatedUserQuery.query(`
                SELECT
                    UserID, Username, Email, Phone, UserRole,
                    FullName, AccountType, UserStatus,
                    FORMAT(CreatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as CreatedAt,
                    FORMAT(UpdatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as UpdatedAt
                FROM Users WHERE UserID = @userId
            `);

            console.log('✅ User updated successfully in database:', userId);
            console.log('📅 Updated user data:', updatedUserResult.recordset[0]);

            // 🔔 CREATE NOTIFICATION for the updated user
            try {
                // Get admin ID from headers (you'll need to pass this from frontend)
                const adminId = req.headers['x-admin-id'] || req.headers['x-user-id'];
                
                // Determine what changed
                const changes = [];
                if (currentUser.Username !== username) changes.push(`Username: ${currentUser.Username} → ${username}`);
                if (currentUser.Email !== email) changes.push(`Email: ${currentUser.Email} → ${email}`);
                if (currentUser.fullName !== fullName) changes.push(`Name: ${currentUser.fullName} → ${fullName}`);
                if (currentUser.UserRole !== (role || 'user')) changes.push(`Role: ${currentUser.UserRole} → ${role || 'user'}`);
                if (currentUser.AccountType !== (accountType || 'free')) changes.push(`Account: ${currentUser.AccountType} → ${accountType || 'free'}`);
                if (currentUser.UserStatus !== (status || 'active')) changes.push(`Status: ${currentUser.UserStatus} → ${status || 'active'}`);

                if (changes.length > 0) {
                    const notificationData = {
                        userID: parseInt(userId),
                        title: 'Account Updated by Administrator',
                        message: `Your account information has been updated. Changes: ${changes.join(', ')}`,
                        type: 'profile_update',
                        adminAction: 'update_user_profile',
                        adminID: adminId ? parseInt(adminId) : null,
                        metadata: {
                            changes: changes,
                            updatedFields: Object.keys(req.body),
                            timestamp: new Date().toISOString(),
                            previousValues: {
                                username: currentUser.Username,
                                email: currentUser.Email,
                                fullName: currentUser.fullName,
                                role: currentUser.UserRole,
                                accountType: currentUser.AccountType,
                                status: currentUser.UserStatus
                            }
                        }
                    };

                    console.log('Creating notification for user:', userId);
                    await createNotification(pool, notificationData);
                    console.log('Notification created successfully');
                } else {
                    console.log('No changes detected, skipping notification');
                }
            } catch (notificationError) {
                console.error('Error creating notification:', notificationError);
            }

            res.json({
                success: true,
                message: 'User updated successfully.',
                user: updatedUserResult.recordset[0] 
            });
        } else {
            res.status(404).json({ success: false, error: 'User not found or no changes made.' });
        }
    } catch (err) {
        console.error('❌ Error updating user:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error updating user.',
            details: err.message
        });
    }
});

// --- ✅ FIXED: Admin: Create user (for admin panel) - NOW WITH isAdmin MIDDLEWARE
router.post('/', isAdmin, async (req, res) => {
    const { username, password, email, phone, fullName, role, accountType, status } = req.body;

    console.log('👤 Admin creating new user:', {
        username,
        email,
        phone: phone || 'Not provided',
        role: role || 'user (default)',
        accountType: accountType || 'free (default)',
        status: status || 'active (default)',
        fullName
    });

    if (!username || !password || !email || !fullName) {
        console.log('❌ Admin create user failed: Missing required fields');
        return res.status(400).json({
            success: false,
            error: 'Username, password, email, and full name are required.'
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        // Check for existing username/email
        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);

        console.log('🔍 Checking for existing username/email...');
        const checkResult = await request.query`
            SELECT COUNT(*) AS count FROM Users WHERE Username = @username OR Email = @email;
        `;

        if (checkResult.recordset[0].count > 0) {
            console.log('❌ Admin create user failed: Username or email already exists');
            return res.status(409).json({
                success: false,
                error: 'Username or email already exists.'
            });
        }

        console.log('🔐 Hashing password...');
        const hashedPassword = await bcrypt.hash(password, 10);

        // Insert new user and get the new ID
        const insertQuery = `
            INSERT INTO Users (Username, PasswordHash, Email, Phone, UserRole, fullName, CreatedAt, UserStatus, AccountType)
            VALUES (@username, @hashedPassword, @email, @phone, @role, @fullName, GETDATE(), @status, @accountType);
            SELECT SCOPE_IDENTITY() as NewUserID;
        `;

        request.input('hashedPassword', sql.NVarChar(255), hashedPassword);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('role', sql.NVarChar(50), role || 'user');
        request.input('fullName', sql.NVarChar(100), fullName);
        request.input('status', sql.NVarChar(50), status || 'active');
        request.input('accountType', sql.NVarChar(50), accountType || 'free');

        console.log('💾 Inserting new user into database...');
        const insertResult = await request.query(insertQuery);
        const newUserId = insertResult.recordset[0].NewUserID;

        // 🔔 CREATE WELCOME NOTIFICATION
        try {
            const adminId = req.headers['x-admin-id'] || req.headers['x-user-id'];
            
            const notificationData = {
                userID: newUserId,
                title: 'Welcome to Grammar Checker!',
                message: `Welcome ${fullName}! Your account has been created by an administrator with ${accountType} access. You can now start using our grammar checking service.`,
                type: 'welcome',
                adminAction: 'create_user_account',
                adminID: adminId ? parseInt(adminId) : null,
                metadata: {
                    accountType: accountType || 'free',
                    userRole: role || 'user',
                    createdBy: 'admin',
                    timestamp: new Date().toISOString()
                }
            };

            console.log('🔔 Creating welcome notification for new user:', newUserId);
            await createNotification(pool, notificationData);
            console.log('✅ Welcome notification created successfully');
        } catch (notificationError) {
            console.error('❌ Error creating welcome notification:', notificationError);
            // Don't fail user creation if notification creation fails
        }

        console.log('✅ Admin created user successfully:', username);
        res.status(201).json({
            success: true,
            message: 'User created successfully.',
            userId: newUserId
        });
    } catch (err) {
        console.error('❌ Error creating user:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error creating user.',
            details: err.message
        });
    }
});

// --- Admin: Delete user ---
router.delete('/admin/delete/:id', isAdmin, async (req, res) => {
    const userId = req.params.id;

    try {
        const pool = getDbPool(req);
        const request = pool.request();
        request.input('userId', sql.Int, userId);

        const result = await request.query`
            DELETE FROM Users WHERE UserID = @userId;
        `;

        if (result.rowsAffected[0] > 0) {
            res.json({ success: true, message: 'User deleted successfully.' });
        } else {
            res.status(404).json({ success: false, error: 'User not found.' });
        }

    } catch (err) {
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error deleting user.',
            details: err.message
        });
    }
});

export default router;
```

### backend\services\cohereService.js
```js
import { CohereClient } from 'cohere-ai';

const apiKey = process.env.COHERE_API_KEY;
let cohere = null;

if (apiKey?.trim()) {
  cohere = new CohereClient({ token: apiKey });
  console.log('✅ Cohere client initialized.');
} else {
  console.warn('⚠️ COHERE_API_KEY not found. Cohere will not be used.');
}

export async function fallbackCheckWithCohere(text) {
  if (!cohere) return [];

  try {
    console.log("📝 Checking with Cohere:", JSON.stringify(text));

    const prompt = `
You are an English grammar correction expert. Analyze the following text.

Instructions:
- Only identify grammar, spelling, punctuation, or capitalization mistakes.
- For each issue, output EXACTLY 1 line using this strict format:
  original | correction | explanation
- The "original" must be a word or phrase from the input.
- The "correction" must differ from the original.
- The "explanation" must be brief.
- Do NOT repeat same word (e.g., "had ➝ had").
- Do NOT rewrite entire sentence.
- Do NOT return full sentence corrections.

Example:
Input: she have went to the store yesterday
Output:
have | had | Use "had" for past perfect tense.
went | gone | "Gone" is the correct past participle.
(no period) | . | Add a period at the end.

Now correct this:
"""${text}"""`;
console.log("📤 Prompt sent to Cohere:\n", prompt);

    const response = await cohere.generate({
      model: 'command',
      prompt,
      maxTokens: 500,
      temperature: 0.1,
    });

    const raw = response.generations?.[0]?.text || '';
    console.log('📤 Cohere raw response:\n', raw);

    const matches = [];
    const usedOffsets = new Set();
    const regex = /^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/gm;
    let match;

    while ((match = regex.exec(raw)) !== null) {
      const original = match[1].trim();
      const replacement = match[2].trim();
      const explanation = match[3].trim();

      if (!original || original === replacement) continue;

      let offset = -1;
      let searchStart = 0;
      while (true) {
        offset = text.indexOf(original, searchStart);
        if (offset === -1 || !usedOffsets.has(offset)) break;
        searchStart = offset + 1;
      }

      if (offset === -1) continue;
      usedOffsets.add(offset);

      matches.push({
        offset,
        length: original.length,
        message: explanation,
        replacements: [{ value: replacement }],
      });
    }

    console.log('✅ Parsed matches:', matches);
    return matches;
  } catch (error) {
    console.error('❌ Cohere fallbackCheck error:', error);
    return [];
  }
}

const validationCache = new Map();

export async function validateCorrectionsWithCohere(text, matches) {
  if (!cohere || !Array.isArray(matches) || matches.length === 0) return [];

  const cacheKey = `${text}_${JSON.stringify(matches)}`;
  if (validationCache.has(cacheKey)) return validationCache.get(cacheKey);

  try {
    const suggestionsList = matches.map((m, index) => {
      const original = text.slice(m.offset, m.offset + m.length);
      const replacement = m.replacements?.[0]?.value || '[No suggestion]';
      return `${index + 1}. ${original} ➝ ${replacement}`;
    }).join('\n');

    const prompt = `You are a grammar expert. Validate if the following suggestions are correct.

Text:
${text}

Suggestions:
${suggestionsList}

Reply only with valid suggestions in format:
original ➝ replacement`;

    const response = await cohere.generate({
      model: 'command',
      prompt,
      maxTokens: 500,
      temperature: 0.2,
    });

    const raw = response.generations?.[0]?.text || '';
    console.log('📤 Cohere validation raw response:\n', raw);

    const validated = raw.match(/(.+?)\s*➝\s*(.+)/g) || [];
    const confirmed = validated.map(v => {
      const parts = v.match(/(.+?)\s*➝\s*(.+)/);
      return {
        from: parts[1].trim(),
        to: parts[2].trim()
      };
    });

    const filteredMatches = matches.map(m => {
      const original = text.slice(m.offset, m.offset + m.length);
      const confirmedCorrection = confirmed.find(c => c.from === original && c.from !== c.to);
      if (confirmedCorrection) {
        return {
          ...m,
          replacements: [{ value: confirmedCorrection.to }]
        };
      } else {
        console.log(`🗑️ Removed invalid or duplicate suggestion: "${original}" ➝ "${m.replacements?.[0]?.value}"`);
        return null;
      }
    }).filter(Boolean);

    validationCache.set(cacheKey, filteredMatches);
    return filteredMatches;
  } catch (error) {
    console.error('❌ Cohere validation error:', error);
    return [];
  }
}

```

### backend\services\languageToolService.js
```js
import fetch from 'node-fetch';

// Custom error class for LanguageTool API issues
class LanguageToolError extends Error {
  constructor(message, statusCode, details = null) {
    super(message);
    this.name = 'LanguageToolError';
    this.statusCode = statusCode;
    this.details = details;
  }
}

class LanguageToolService {
  constructor() {
    this.baseURL = process.env.LANGUAGETOOL_API_URL || 'https://api.languagetool.org/v2';
    this.timeout = parseInt(process.env.API_TIMEOUT) || 10000;

    // In-memory cache for grammar results
    this.grammarCache = new Map();
    this.grammarCacheTimeout = 5 * 60 * 1000; // 5 minutes

    this.languagesCache = null;
    this.languagesCacheTimestamp = 0;
    this.languagesCacheTimeout = 60 * 60 * 1000; // 1 hour

    // Clear expired cache periodically
    setInterval(() => this.clearExpiredGrammarCache(), this.grammarCacheTimeout);
  }

  async detectLanguage(text) {
    const params = new URLSearchParams({ text, language: 'auto' });

    try {
      const response = await fetch(`${this.baseURL}/check`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body: params.toString(),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LanguageToolError(`Language detection failed: ${response.statusText}`, response.status, errorText);
      }

      const data = await response.json();
      const detectedCode = data.language?.detectedLanguage?.code;

      if (!detectedCode || typeof detectedCode !== 'string') {
        throw new LanguageToolError('No valid detected language returned by LanguageTool.', 500);
      }

      return detectedCode;
    } catch (error) {
      if (error instanceof LanguageToolError) throw error;
      throw new LanguageToolError(`Language detection failed: ${error.message}`, error.statusCode || 500, error.details || error.stack);
    }
  }

  _hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString();
  }

  setGrammarCache(key, value) {
    this.grammarCache.set(key, { data: value, timestamp: Date.now() });
  }

  getFromGrammarCache(key) {
    const cached = this.grammarCache.get(key);
    if (!cached) return null;
    if (Date.now() - cached.timestamp > this.grammarCacheTimeout) {
      this.grammarCache.delete(key);
      return null;
    }
    return cached.data;
  }

  clearExpiredGrammarCache() {
    const now = Date.now();
    for (const [key, value] of this.grammarCache.entries()) {
      if (now - value.timestamp > this.grammarCacheTimeout) {
        this.grammarCache.delete(key);
      }
    }
  }

  async getLanguages() {
    const now = Date.now();
    if (this.languagesCache && (now - this.languagesCacheTimestamp < this.languagesCacheTimeout)) {
      return this.languagesCache;
    }

    try {
      const response = await fetch(`${this.baseURL}/languages`);
      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        throw new LanguageToolError(`Failed to fetch languages: ${response.statusText}`, response.status, errorBody);
      }
      const data = await response.json();
      this.languagesCache = data;
      this.languagesCacheTimestamp = now;
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new LanguageToolError('LanguageTool API request timed out.', 408);
      }
      if (error instanceof LanguageToolError) throw error;
      throw new LanguageToolError(`Network error or LanguageTool API is unreachable: ${error.message}`, 503);
    }
  }

  async checkGrammar(text, language = 'auto') {
    const cacheKey = this._hashString(`${text}-${language}`);
    const cachedResult = this.getFromGrammarCache(cacheKey);
    if (cachedResult) {
      console.log('⚡ [CACHE HIT] Grammar check result returned from cache.');
      return cachedResult;
    }

    const params = new URLSearchParams({ language, text });

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);

      const response = await fetch(`${this.baseURL}/check`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body: params.toString(),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        throw new LanguageToolError(`LanguageTool API error: ${response.statusText}`, response.status, errorBody);
      }

      const data = await response.json();
      if (!data.matches) {
        throw new LanguageToolError('Response did not contain "matches".', 500, data);
      }

      this.setGrammarCache(cacheKey, data);
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new LanguageToolError('LanguageTool API request timed out.', 408);
      }
      if (error instanceof LanguageToolError) throw error;
      throw new LanguageToolError(`Network error or LanguageTool API is unreachable: ${error.message}`, 503);
    }
  }
}

// ✅ Improved: Validate Cohere suggestions by checking that the same error is not repeated in the same position
async function validateCohereSuggestions(text, cohereMatches) {
  const validateTasks = cohereMatches.map(async (match) => {
    const replacement = match.replacements?.[0]?.value;
    if (!replacement) return null;

    const updatedText = text.slice(0, match.offset) + replacement + text.slice(match.offset + match.length);

    try {
      const result = await languageToolService.checkGrammar(updatedText, 'en');

      const sameError = result.matches.some(m => m.offset === match.offset && m.length === match.length);
      return !sameError ? match : null;
    } catch (err) {
      console.warn('⚠️ LanguageTool validation failed:', err.message);
      return null;
    }
  });

  const validated = await Promise.all(validateTasks);
  console.log(`✅ LT validation accepted ${validated.filter(Boolean).length}/${cohereMatches.length} suggestions.`);
  return validated.filter(Boolean);
}

const languageToolService = new LanguageToolService();
languageToolService.validateCohereSuggestions = validateCohereSuggestions;

export default languageToolService;

```

### backend\services\notificationCleanup.js
```js
// backend/services/notificationCleanup.js
import cron from 'node-cron';

export function startNotificationCleanup(dbPool) {
    if (!dbPool) {
        console.error('Database pool not provided for notification cleanup');
        return;
    }

    // Schedule cleanup to run daily at 2:00 AM
    const cleanupJob = cron.schedule('0 2 * * *', async () => {
        try {
            console.log('Starting automatic notification cleanup...');
            const startTime = new Date();

            const request = dbPool.request();
            const query = `
                DELETE FROM Notifications 
                WHERE CreatedAt < DATEADD(day, -3, GETDATE())
            `;

            const result = await request.query(query);
            const deletedCount = result.rowsAffected[0];
            const endTime = new Date();
            const duration = endTime - startTime;

            console.log(`Notification cleanup completed:`);
            console.log(`- Deleted: ${deletedCount} notifications older than 3 days`);
            console.log(`- Duration: ${duration}ms`);

        } catch (error) {
            console.error('Error during automatic notification cleanup:', error);
        }
    }, {
        scheduled: false, 
        timezone: "Asia/Ho_Chi_Minh" 
    });

    // Start the scheduled job
    cleanupJob.start();
    
    console.log('Notification cleanup scheduler started');
    console.log('- Schedule: Daily at 2:00 AM (Vietnam time)');

    // Optional: Run cleanup once on startup to clean existing old notifications
    setTimeout(async () => {
        try {
            console.log('Running initial notification cleanup...');
            const request = dbPool.request();
            const result = await request.query(`
                DELETE FROM Notifications 
                WHERE CreatedAt < DATEADD(day, -3, GETDATE())
            `);
            console.log(`Initial cleanup: deleted ${result.rowsAffected[0]} old notifications`);
        } catch (error) {
            console.error('Error during initial cleanup:', error);
        }
    }, 5000); 

    return cleanupJob;
}
```

### backend\utils\printConfidenceTable.js
```js
// backend/utils/printConfidenceTable.js

function getConfidenceLevel(score) {
  if (typeof score !== 'number') return 'Unknown';
  if (score >= 0.9) return '✅ Very High';
  if (score >= 0.7) return '🟡 Medium';
  if (score >= 0.5) return '🔴 Low';
  return '⚪️ Very Low';
}

export function printConfidenceTable(matches) {
  if (!Array.isArray(matches) || matches.length === 0) {
    console.log('✅ No grammar issues found.');
    return;
  }

  const tableData = matches.map((match, index) => {
    const confidence = match.rule?.confidence ?? 'N/A';
    const level = getConfidenceLevel(confidence);
    const suggestions = match.replacements.map(r => r.value).join(', ');
    return {
      '#': index + 1,
      Message: match.message,
      Confidence: typeof confidence === 'number' ? confidence.toFixed(2) : 'N/A',
      Level: level,
      Suggestions: suggestions
    };
  });

  console.log('\n📊 Grammar Check Confidence Table:\n');
  console.table(tableData);
}

```

### frontend\public\js\api.js
```js
const API_BASE_URL = 'http://localhost:3000/api';

class FrontendCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
    this.ttl = 10 * 60 * 1000; // 10 minutes
    setInterval(() => this.cleanExpired(), 5 * 60 * 1000);
  }
  generateKey(text, type, language = '') {
    const textKey = (text || '').slice(0, 100) + `_len${(text || '').length}`;
    return `${type}_${language}_${this.hashString(textKey)}`;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return String(hash);
  }
  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, { data: value, expires: Date.now() + this.ttl });
  }
  get(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;
    if (Date.now() > cached.expires) { this.cache.delete(key); return null; }
    return cached.data;
  }
  cleanExpired() {
    const now = Date.now(); let cleaned = 0;
    for (const [k, v] of this.cache.entries()) {
      if (now > v.expires) { this.cache.delete(k); cleaned++; }
    }
    if (cleaned) console.log(`Cache cleaned: ${cleaned} items`);
  }
  clear() { this.cache.clear(); console.log('Cache cleared'); }
  getStats() { return { size: this.cache.size, maxSize: this.maxSize, ttlMinutes: this.ttl / 60000 }; }
}
const frontendCache = new FrontendCache();
if (typeof window !== 'undefined') window.grammarCache = frontendCache;

/* =========================
   Helpers
   ========================= */
function getUserData() {
  try {
    let loggedData = localStorage.getItem("loggedInAs_user");
    
    if (!loggedData) {
      loggedData = localStorage.getItem("loggedInAs_admin");
    }
    
    if (!loggedData) {
      loggedData = localStorage.getItem("loggedInAs");
    }
    
    if (!loggedData) return null;
    return JSON.parse(loggedData);
  } catch (e) {
    console.error('getUserData parse error', e);
    return null;
  }
}

export async function logUsageActivity(data) {
    try {
        const userData = getUserData(); 
        const payload = {
          user_id: userData?.userId ?? userData?.id ?? null,
          username: userData?.username ?? userData?.name ?? null,
          action: data.action || null,
          language: data.language || null,   // thêm dòng này
          metadata: data.details ?? data.metadata ?? {},
          user_agent: navigator.userAgent || '',
          session_id: sessionStorage.getItem('sessionId') || ''
        };

        await fetch('/api/usage/log', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-user-id': userData?.userId?.toString() || '',
                'x-user-role': userData?.userRole || 'guest'
            },
            body: JSON.stringify(payload)
        });
    } catch (error) {
        console.error('Error logging usage:', error);
    }
}


async function safeJson(response) {
  try {
    return await response.json();
  } catch (e) {
    console.warn('Response not JSON', e);
    return null;
  }
}

/* =========================
   Public API functions
   ========================= */

/** fetchLanguages - tolerant to multiple response shapes */
export const fetchLanguages = async () => {
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/languages`);
    const data = await safeJson(res) || {};
    // Accept several shapes
    if (data?.success && data?.data?.languages) return data.data.languages;
    if (data?.languages) return data.languages;
    if (data?.data?.languagesList) return data.data.languagesList;
    throw new Error('Unexpected languages response');
  } catch (err) {
    console.error('fetchLanguages error', err);
    throw err;
  }
};

/** detectLanguage with caching + simple heuristics + fallback */
export const detectLanguage = async (text) => {
  if (typeof text !== 'string' || text.trim() === '') throw new Error('Text must be a non-empty string.');
  const trimmed = text.trim();
  const cacheKey = frontendCache.generateKey(trimmed, 'detect');
  const cached = frontendCache.get(cacheKey);
  if (cached) return cached;
  if (trimmed.length < 15) { frontendCache.set(cacheKey, 'en-US'); return 'en-US'; }
  if (trimmed.length < 50 && /^[a-zA-Z\s.,!?'"()-]+$/.test(trimmed)) {
    frontendCache.set(cacheKey, 'en-US'); return 'en-US';
  }
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/detect`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: trimmed })
    });
    const data = await safeJson(res) || {};
    const detected = data?.language || data?.data?.language || data?.detected || 'en-US';
    frontendCache.set(cacheKey, detected);
    return detected;
  } catch (err) {
    console.error('detectLanguage error', err);
    frontendCache.set(cacheKey, 'en-US');
    return 'en-US';
  }
};

/** checkGrammar with caching + tolerant response parsing */
export const checkGrammar = async (text, language = 'en-US') => {
  if (typeof text !== 'string' || text.trim() === '') throw new Error('Text must be a non-empty string.');
  const trimmed = text.trim();
  const cacheKey = frontendCache.generateKey(trimmed, 'grammar', language);
  const cached = frontendCache.get(cacheKey);
  if (cached) return cached;
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/check`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: trimmed, language })
    });
    const data = await safeJson(res) || {};
    // Accept shapes: { success: true, data: {...} } or { success: true, matches: [...] } or { matches: [...] }
    let result = null;
    if (data.success && data.data) result = data.data;
    else if (data.matches) result = { matches: data.matches };
    else if (data.data?.matches) result = data.data;
    else result = data; // fallback to raw
    frontendCache.set(cacheKey, result);
    return result;
  } catch (err) {
    console.error('checkGrammar error', err);
    throw new Error('Could not connect to the server to check grammar.');
  }
};

/** registerUser */
export async function registerUser(userData) {
  try {
    const res = await fetch(`${API_BASE_URL}/users/register`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(userData)
    });
    const data = await safeJson(res);
    return { success: res.ok && data?.success, message: data?.message, error: data?.error, status: res.status, data: data?.data || data };
  } catch (err) {
    console.error('registerUser error', err);
    return { success: false, error: 'Network error', status: 500 };
  }
}

/** loginUser (tolerant) */
export async function loginUser(username, password) {
  try {
    const res = await fetch(`${API_BASE_URL}/users/login`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username, password })
    });
    const data = await safeJson(res) || {};
    return {
      success: res.ok && data.success,
      message: data.message || '',
      error: data.error || null,
      token: data.token || `session-${data.userId || '0'}-${Date.now()}`,
      userId: data.userId || data.id || data.user?.id,
      username: data.username || data.user?.username,
      email: data.email || data.user?.email,
      phone: data.phone || data.user?.phone,
      userRole: data.userRole || data.user?.userRole || data.role,
      status: res.status
    };
  } catch (err) {
    console.error('loginUser error', err);
    return { success: false, error: 'Network error', status: 500 };
  }
}

/** fetchUsers (admin) */
export const fetchUsers = async () => {
  try {
    const userData = getUserData();
    if (!userData) throw new Error('Authentication required');
    const res = await fetch(`${API_BASE_URL}/users/admin/users`, {
      method: 'GET', headers: { 'Content-Type': 'application/json', 'x-user-role': userData.userRole }
    });
    const data = await safeJson(res) || {};
    if (!res.ok) {
      throw new Error(data?.error || `HTTP ${res.status}`);
    }
    return data.users || data.data?.users || data.data || [];
  } catch (err) {
    console.error('fetchUsers error', err);
    throw err;
  }
};

/** updateUser */
export const updateUser = async (userId, userData) => {
  try {
    const currentUser = getUserData();
    if (!currentUser || currentUser.userRole !== 'admin') return { success: false, error: 'Admin auth required' };
    const res = await fetch(`${API_BASE_URL}/users/admin/update/${userId}`, {
      method: 'PUT', headers: { 'Content-Type': 'application/json', 'x-user-role': currentUser.userRole }, body: JSON.stringify(userData)
    });
    const data = await safeJson(res) || {};
    return { success: res.ok && data.success, error: data.error, message: data.message };
  } catch (err) {
    console.error('updateUser error', err);
    return { success: false, error: 'Network error' };
  }
};

/** deleteUser */
export const deleteUser = async (userId) => {
  try {
    const currentUser = getUserData();
    if (!currentUser || currentUser.userRole !== 'admin') return { success: false, error: 'Admin auth required' };
    const res = await fetch(`${API_BASE_URL}/users/admin/delete/${userId}`, {
      method: 'DELETE', headers: { 'Content-Type': 'application/json', 'x-user-role': currentUser.userRole }
    });
    const data = await safeJson(res) || {};
    return { success: res.ok && data.success, error: data.error, message: data.message };
  } catch (err) {
    console.error('deleteUser error', err);
    return { success: false, error: 'Network error' };
  }
};

/* =========================
   Cache controls
   ========================= */
export const clearGrammarCache = () => { frontendCache.clear(); };
export const getCacheStats = () => frontendCache.getStats();
export const cacheManager = frontendCache;

```

### frontend\public\js\bootstrap.bundle.min.js
```js
/*!
  * Bootstrap v5.3.0 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).bootstrap=e()}(this,(function(){"use strict";const t=new Map,e={set(e,i,n){t.has(e)||t.set(e,new Map);const s=t.get(e);s.has(i)||0===s.size?s.set(i,n):console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)},get:(e,i)=>t.has(e)&&t.get(e).get(i)||null,remove(e,i){if(!t.has(e))return;const n=t.get(e);n.delete(i),0===n.size&&t.delete(e)}},i="transitionend",n=t=>(t&&window.CSS&&window.CSS.escape&&(t=t.replace(/#([^\s"#']+)/g,((t,e)=>`#${CSS.escape(e)}`))),t),s=t=>{t.dispatchEvent(new Event(i))},o=t=>!(!t||"object"!=typeof t)&&(void 0!==t.jquery&&(t=t[0]),void 0!==t.nodeType),r=t=>o(t)?t.jquery?t[0]:t:"string"==typeof t&&t.length>0?document.querySelector(n(t)):null,a=t=>{if(!o(t)||0===t.getClientRects().length)return!1;const e="visible"===getComputedStyle(t).getPropertyValue("visibility"),i=t.closest("details:not([open])");if(!i)return e;if(i!==t){const e=t.closest("summary");if(e&&e.parentNode!==i)return!1;if(null===e)return!1}return e},l=t=>!t||t.nodeType!==Node.ELEMENT_NODE||!!t.classList.contains("disabled")||(void 0!==t.disabled?t.disabled:t.hasAttribute("disabled")&&"false"!==t.getAttribute("disabled")),c=t=>{if(!document.documentElement.attachShadow)return null;if("function"==typeof t.getRootNode){const e=t.getRootNode();return e instanceof ShadowRoot?e:null}return t instanceof ShadowRoot?t:t.parentNode?c(t.parentNode):null},h=()=>{},d=t=>{t.offsetHeight},u=()=>window.jQuery&&!document.body.hasAttribute("data-bs-no-jquery")?window.jQuery:null,f=[],p=()=>"rtl"===document.documentElement.dir,m=t=>{var e;e=()=>{const e=u();if(e){const i=t.NAME,n=e.fn[i];e.fn[i]=t.jQueryInterface,e.fn[i].Constructor=t,e.fn[i].noConflict=()=>(e.fn[i]=n,t.jQueryInterface)}},"loading"===document.readyState?(f.length||document.addEventListener("DOMContentLoaded",(()=>{for(const t of f)t()})),f.push(e)):e()},g=(t,e=[],i=t)=>"function"==typeof t?t(...e):i,_=(t,e,n=!0)=>{if(!n)return void g(t);const o=(t=>{if(!t)return 0;let{transitionDuration:e,transitionDelay:i}=window.getComputedStyle(t);const n=Number.parseFloat(e),s=Number.parseFloat(i);return n||s?(e=e.split(",")[0],i=i.split(",")[0],1e3*(Number.parseFloat(e)+Number.parseFloat(i))):0})(e)+5;let r=!1;const a=({target:n})=>{n===e&&(r=!0,e.removeEventListener(i,a),g(t))};e.addEventListener(i,a),setTimeout((()=>{r||s(e)}),o)},b=(t,e,i,n)=>{const s=t.length;let o=t.indexOf(e);return-1===o?!i&&n?t[s-1]:t[0]:(o+=i?1:-1,n&&(o=(o+s)%s),t[Math.max(0,Math.min(o,s-1))])},v=/[^.]*(?=\..*)\.|.*/,y=/\..*/,w=/::\d+$/,A={};let E=1;const T={mouseenter:"mouseover",mouseleave:"mouseout"},C=new Set(["click","dblclick","mouseup","mousedown","contextmenu","mousewheel","DOMMouseScroll","mouseover","mouseout","mousemove","selectstart","selectend","keydown","keypress","keyup","orientationchange","touchstart","touchmove","touchend","touchcancel","pointerdown","pointermove","pointerup","pointerleave","pointercancel","gesturestart","gesturechange","gestureend","focus","blur","change","reset","select","submit","focusin","focusout","load","unload","beforeunload","resize","move","DOMContentLoaded","readystatechange","error","abort","scroll"]);function O(t,e){return e&&`${e}::${E++}`||t.uidEvent||E++}function x(t){const e=O(t);return t.uidEvent=e,A[e]=A[e]||{},A[e]}function k(t,e,i=null){return Object.values(t).find((t=>t.callable===e&&t.delegationSelector===i))}function L(t,e,i){const n="string"==typeof e,s=n?i:e||i;let o=N(t);return C.has(o)||(o=t),[n,s,o]}function S(t,e,i,n,s){if("string"!=typeof e||!t)return;let[o,r,a]=L(e,i,n);if(e in T){const t=t=>function(e){if(!e.relatedTarget||e.relatedTarget!==e.delegateTarget&&!e.delegateTarget.contains(e.relatedTarget))return t.call(this,e)};r=t(r)}const l=x(t),c=l[a]||(l[a]={}),h=k(c,r,o?i:null);if(h)return void(h.oneOff=h.oneOff&&s);const d=O(r,e.replace(v,"")),u=o?function(t,e,i){return function n(s){const o=t.querySelectorAll(e);for(let{target:r}=s;r&&r!==this;r=r.parentNode)for(const a of o)if(a===r)return M(s,{delegateTarget:r}),n.oneOff&&P.off(t,s.type,e,i),i.apply(r,[s])}}(t,i,r):function(t,e){return function i(n){return M(n,{delegateTarget:t}),i.oneOff&&P.off(t,n.type,e),e.apply(t,[n])}}(t,r);u.delegationSelector=o?i:null,u.callable=r,u.oneOff=s,u.uidEvent=d,c[d]=u,t.addEventListener(a,u,o)}function D(t,e,i,n,s){const o=k(e[i],n,s);o&&(t.removeEventListener(i,o,Boolean(s)),delete e[i][o.uidEvent])}function I(t,e,i,n){const s=e[i]||{};for(const[o,r]of Object.entries(s))o.includes(n)&&D(t,e,i,r.callable,r.delegationSelector)}function N(t){return t=t.replace(y,""),T[t]||t}const P={on(t,e,i,n){S(t,e,i,n,!1)},one(t,e,i,n){S(t,e,i,n,!0)},off(t,e,i,n){if("string"!=typeof e||!t)return;const[s,o,r]=L(e,i,n),a=r!==e,l=x(t),c=l[r]||{},h=e.startsWith(".");if(void 0===o){if(h)for(const i of Object.keys(l))I(t,l,i,e.slice(1));for(const[i,n]of Object.entries(c)){const s=i.replace(w,"");a&&!e.includes(s)||D(t,l,r,n.callable,n.delegationSelector)}}else{if(!Object.keys(c).length)return;D(t,l,r,o,s?i:null)}},trigger(t,e,i){if("string"!=typeof e||!t)return null;const n=u();let s=null,o=!0,r=!0,a=!1;e!==N(e)&&n&&(s=n.Event(e,i),n(t).trigger(s),o=!s.isPropagationStopped(),r=!s.isImmediatePropagationStopped(),a=s.isDefaultPrevented());const l=M(new Event(e,{bubbles:o,cancelable:!0}),i);return a&&l.preventDefault(),r&&t.dispatchEvent(l),l.defaultPrevented&&s&&s.preventDefault(),l}};function M(t,e={}){for(const[i,n]of Object.entries(e))try{t[i]=n}catch(e){Object.defineProperty(t,i,{configurable:!0,get:()=>n})}return t}function j(t){if("true"===t)return!0;if("false"===t)return!1;if(t===Number(t).toString())return Number(t);if(""===t||"null"===t)return null;if("string"!=typeof t)return t;try{return JSON.parse(decodeURIComponent(t))}catch(e){return t}}function F(t){return t.replace(/[A-Z]/g,(t=>`-${t.toLowerCase()}`))}const H={setDataAttribute(t,e,i){t.setAttribute(`data-bs-${F(e)}`,i)},removeDataAttribute(t,e){t.removeAttribute(`data-bs-${F(e)}`)},getDataAttributes(t){if(!t)return{};const e={},i=Object.keys(t.dataset).filter((t=>t.startsWith("bs")&&!t.startsWith("bsConfig")));for(const n of i){let i=n.replace(/^bs/,"");i=i.charAt(0).toLowerCase()+i.slice(1,i.length),e[i]=j(t.dataset[n])}return e},getDataAttribute:(t,e)=>j(t.getAttribute(`data-bs-${F(e)}`))};class ${static get Default(){return{}}static get DefaultType(){return{}}static get NAME(){throw new Error('You have to implement the static method "NAME", for each component!')}_getConfig(t){return t=this._mergeConfigObj(t),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}_configAfterMerge(t){return t}_mergeConfigObj(t,e){const i=o(e)?H.getDataAttribute(e,"config"):{};return{...this.constructor.Default,..."object"==typeof i?i:{},...o(e)?H.getDataAttributes(e):{},..."object"==typeof t?t:{}}}_typeCheckConfig(t,e=this.constructor.DefaultType){for(const[n,s]of Object.entries(e)){const e=t[n],r=o(e)?"element":null==(i=e)?`${i}`:Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();if(!new RegExp(s).test(r))throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`)}var i}}class W extends ${constructor(t,i){super(),(t=r(t))&&(this._element=t,this._config=this._getConfig(i),e.set(this._element,this.constructor.DATA_KEY,this))}dispose(){e.remove(this._element,this.constructor.DATA_KEY),P.off(this._element,this.constructor.EVENT_KEY);for(const t of Object.getOwnPropertyNames(this))this[t]=null}_queueCallback(t,e,i=!0){_(t,e,i)}_getConfig(t){return t=this._mergeConfigObj(t,this._element),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}static getInstance(t){return e.get(r(t),this.DATA_KEY)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,"object"==typeof e?e:null)}static get VERSION(){return"5.3.0"}static get DATA_KEY(){return`bs.${this.NAME}`}static get EVENT_KEY(){return`.${this.DATA_KEY}`}static eventName(t){return`${t}${this.EVENT_KEY}`}}const B=t=>{let e=t.getAttribute("data-bs-target");if(!e||"#"===e){let i=t.getAttribute("href");if(!i||!i.includes("#")&&!i.startsWith("."))return null;i.includes("#")&&!i.startsWith("#")&&(i=`#${i.split("#")[1]}`),e=i&&"#"!==i?i.trim():null}return n(e)},z={find:(t,e=document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(e,t)),findOne:(t,e=document.documentElement)=>Element.prototype.querySelector.call(e,t),children:(t,e)=>[].concat(...t.children).filter((t=>t.matches(e))),parents(t,e){const i=[];let n=t.parentNode.closest(e);for(;n;)i.push(n),n=n.parentNode.closest(e);return i},prev(t,e){let i=t.previousElementSibling;for(;i;){if(i.matches(e))return[i];i=i.previousElementSibling}return[]},next(t,e){let i=t.nextElementSibling;for(;i;){if(i.matches(e))return[i];i=i.nextElementSibling}return[]},focusableChildren(t){const e=["a","button","input","textarea","select","details","[tabindex]",'[contenteditable="true"]'].map((t=>`${t}:not([tabindex^="-"])`)).join(",");return this.find(e,t).filter((t=>!l(t)&&a(t)))},getSelectorFromElement(t){const e=B(t);return e&&z.findOne(e)?e:null},getElementFromSelector(t){const e=B(t);return e?z.findOne(e):null},getMultipleElementsFromSelector(t){const e=B(t);return e?z.find(e):[]}},R=(t,e="hide")=>{const i=`click.dismiss${t.EVENT_KEY}`,n=t.NAME;P.on(document,i,`[data-bs-dismiss="${n}"]`,(function(i){if(["A","AREA"].includes(this.tagName)&&i.preventDefault(),l(this))return;const s=z.getElementFromSelector(this)||this.closest(`.${n}`);t.getOrCreateInstance(s)[e]()}))};class q extends W{static get NAME(){return"alert"}close(){if(P.trigger(this._element,"close.bs.alert").defaultPrevented)return;this._element.classList.remove("show");const t=this._element.classList.contains("fade");this._queueCallback((()=>this._destroyElement()),this._element,t)}_destroyElement(){this._element.remove(),P.trigger(this._element,"closed.bs.alert"),this.dispose()}static jQueryInterface(t){return this.each((function(){const e=q.getOrCreateInstance(this);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}R(q,"close"),m(q);const V='[data-bs-toggle="button"]';class K extends W{static get NAME(){return"button"}toggle(){this._element.setAttribute("aria-pressed",this._element.classList.toggle("active"))}static jQueryInterface(t){return this.each((function(){const e=K.getOrCreateInstance(this);"toggle"===t&&e[t]()}))}}P.on(document,"click.bs.button.data-api",V,(t=>{t.preventDefault();const e=t.target.closest(V);K.getOrCreateInstance(e).toggle()})),m(K);const Q={endCallback:null,leftCallback:null,rightCallback:null},X={endCallback:"(function|null)",leftCallback:"(function|null)",rightCallback:"(function|null)"};class Y extends ${constructor(t,e){super(),this._element=t,t&&Y.isSupported()&&(this._config=this._getConfig(e),this._deltaX=0,this._supportPointerEvents=Boolean(window.PointerEvent),this._initEvents())}static get Default(){return Q}static get DefaultType(){return X}static get NAME(){return"swipe"}dispose(){P.off(this._element,".bs.swipe")}_start(t){this._supportPointerEvents?this._eventIsPointerPenTouch(t)&&(this._deltaX=t.clientX):this._deltaX=t.touches[0].clientX}_end(t){this._eventIsPointerPenTouch(t)&&(this._deltaX=t.clientX-this._deltaX),this._handleSwipe(),g(this._config.endCallback)}_move(t){this._deltaX=t.touches&&t.touches.length>1?0:t.touches[0].clientX-this._deltaX}_handleSwipe(){const t=Math.abs(this._deltaX);if(t<=40)return;const e=t/this._deltaX;this._deltaX=0,e&&g(e>0?this._config.rightCallback:this._config.leftCallback)}_initEvents(){this._supportPointerEvents?(P.on(this._element,"pointerdown.bs.swipe",(t=>this._start(t))),P.on(this._element,"pointerup.bs.swipe",(t=>this._end(t))),this._element.classList.add("pointer-event")):(P.on(this._element,"touchstart.bs.swipe",(t=>this._start(t))),P.on(this._element,"touchmove.bs.swipe",(t=>this._move(t))),P.on(this._element,"touchend.bs.swipe",(t=>this._end(t))))}_eventIsPointerPenTouch(t){return this._supportPointerEvents&&("pen"===t.pointerType||"touch"===t.pointerType)}static isSupported(){return"ontouchstart"in document.documentElement||navigator.maxTouchPoints>0}}const U="next",G="prev",J="left",Z="right",tt="slid.bs.carousel",et="carousel",it="active",nt={ArrowLeft:Z,ArrowRight:J},st={interval:5e3,keyboard:!0,pause:"hover",ride:!1,touch:!0,wrap:!0},ot={interval:"(number|boolean)",keyboard:"boolean",pause:"(string|boolean)",ride:"(boolean|string)",touch:"boolean",wrap:"boolean"};class rt extends W{constructor(t,e){super(t,e),this._interval=null,this._activeElement=null,this._isSliding=!1,this.touchTimeout=null,this._swipeHelper=null,this._indicatorsElement=z.findOne(".carousel-indicators",this._element),this._addEventListeners(),this._config.ride===et&&this.cycle()}static get Default(){return st}static get DefaultType(){return ot}static get NAME(){return"carousel"}next(){this._slide(U)}nextWhenVisible(){!document.hidden&&a(this._element)&&this.next()}prev(){this._slide(G)}pause(){this._isSliding&&s(this._element),this._clearInterval()}cycle(){this._clearInterval(),this._updateInterval(),this._interval=setInterval((()=>this.nextWhenVisible()),this._config.interval)}_maybeEnableCycle(){this._config.ride&&(this._isSliding?P.one(this._element,tt,(()=>this.cycle())):this.cycle())}to(t){const e=this._getItems();if(t>e.length-1||t<0)return;if(this._isSliding)return void P.one(this._element,tt,(()=>this.to(t)));const i=this._getItemIndex(this._getActive());if(i===t)return;const n=t>i?U:G;this._slide(n,e[t])}dispose(){this._swipeHelper&&this._swipeHelper.dispose(),super.dispose()}_configAfterMerge(t){return t.defaultInterval=t.interval,t}_addEventListeners(){this._config.keyboard&&P.on(this._element,"keydown.bs.carousel",(t=>this._keydown(t))),"hover"===this._config.pause&&(P.on(this._element,"mouseenter.bs.carousel",(()=>this.pause())),P.on(this._element,"mouseleave.bs.carousel",(()=>this._maybeEnableCycle()))),this._config.touch&&Y.isSupported()&&this._addTouchEventListeners()}_addTouchEventListeners(){for(const t of z.find(".carousel-item img",this._element))P.on(t,"dragstart.bs.carousel",(t=>t.preventDefault()));const t={leftCallback:()=>this._slide(this._directionToOrder(J)),rightCallback:()=>this._slide(this._directionToOrder(Z)),endCallback:()=>{"hover"===this._config.pause&&(this.pause(),this.touchTimeout&&clearTimeout(this.touchTimeout),this.touchTimeout=setTimeout((()=>this._maybeEnableCycle()),500+this._config.interval))}};this._swipeHelper=new Y(this._element,t)}_keydown(t){if(/input|textarea/i.test(t.target.tagName))return;const e=nt[t.key];e&&(t.preventDefault(),this._slide(this._directionToOrder(e)))}_getItemIndex(t){return this._getItems().indexOf(t)}_setActiveIndicatorElement(t){if(!this._indicatorsElement)return;const e=z.findOne(".active",this._indicatorsElement);e.classList.remove(it),e.removeAttribute("aria-current");const i=z.findOne(`[data-bs-slide-to="${t}"]`,this._indicatorsElement);i&&(i.classList.add(it),i.setAttribute("aria-current","true"))}_updateInterval(){const t=this._activeElement||this._getActive();if(!t)return;const e=Number.parseInt(t.getAttribute("data-bs-interval"),10);this._config.interval=e||this._config.defaultInterval}_slide(t,e=null){if(this._isSliding)return;const i=this._getActive(),n=t===U,s=e||b(this._getItems(),i,n,this._config.wrap);if(s===i)return;const o=this._getItemIndex(s),r=e=>P.trigger(this._element,e,{relatedTarget:s,direction:this._orderToDirection(t),from:this._getItemIndex(i),to:o});if(r("slide.bs.carousel").defaultPrevented)return;if(!i||!s)return;const a=Boolean(this._interval);this.pause(),this._isSliding=!0,this._setActiveIndicatorElement(o),this._activeElement=s;const l=n?"carousel-item-start":"carousel-item-end",c=n?"carousel-item-next":"carousel-item-prev";s.classList.add(c),d(s),i.classList.add(l),s.classList.add(l),this._queueCallback((()=>{s.classList.remove(l,c),s.classList.add(it),i.classList.remove(it,c,l),this._isSliding=!1,r(tt)}),i,this._isAnimated()),a&&this.cycle()}_isAnimated(){return this._element.classList.contains("slide")}_getActive(){return z.findOne(".active.carousel-item",this._element)}_getItems(){return z.find(".carousel-item",this._element)}_clearInterval(){this._interval&&(clearInterval(this._interval),this._interval=null)}_directionToOrder(t){return p()?t===J?G:U:t===J?U:G}_orderToDirection(t){return p()?t===G?J:Z:t===G?Z:J}static jQueryInterface(t){return this.each((function(){const e=rt.getOrCreateInstance(this,t);if("number"!=typeof t){if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}else e.to(t)}))}}P.on(document,"click.bs.carousel.data-api","[data-bs-slide], [data-bs-slide-to]",(function(t){const e=z.getElementFromSelector(this);if(!e||!e.classList.contains(et))return;t.preventDefault();const i=rt.getOrCreateInstance(e),n=this.getAttribute("data-bs-slide-to");return n?(i.to(n),void i._maybeEnableCycle()):"next"===H.getDataAttribute(this,"slide")?(i.next(),void i._maybeEnableCycle()):(i.prev(),void i._maybeEnableCycle())})),P.on(window,"load.bs.carousel.data-api",(()=>{const t=z.find('[data-bs-ride="carousel"]');for(const e of t)rt.getOrCreateInstance(e)})),m(rt);const at="show",lt="collapse",ct="collapsing",ht='[data-bs-toggle="collapse"]',dt={parent:null,toggle:!0},ut={parent:"(null|element)",toggle:"boolean"};class ft extends W{constructor(t,e){super(t,e),this._isTransitioning=!1,this._triggerArray=[];const i=z.find(ht);for(const t of i){const e=z.getSelectorFromElement(t),i=z.find(e).filter((t=>t===this._element));null!==e&&i.length&&this._triggerArray.push(t)}this._initializeChildren(),this._config.parent||this._addAriaAndCollapsedClass(this._triggerArray,this._isShown()),this._config.toggle&&this.toggle()}static get Default(){return dt}static get DefaultType(){return ut}static get NAME(){return"collapse"}toggle(){this._isShown()?this.hide():this.show()}show(){if(this._isTransitioning||this._isShown())return;let t=[];if(this._config.parent&&(t=this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t=>t!==this._element)).map((t=>ft.getOrCreateInstance(t,{toggle:!1})))),t.length&&t[0]._isTransitioning)return;if(P.trigger(this._element,"show.bs.collapse").defaultPrevented)return;for(const e of t)e.hide();const e=this._getDimension();this._element.classList.remove(lt),this._element.classList.add(ct),this._element.style[e]=0,this._addAriaAndCollapsedClass(this._triggerArray,!0),this._isTransitioning=!0;const i=`scroll${e[0].toUpperCase()+e.slice(1)}`;this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ct),this._element.classList.add(lt,at),this._element.style[e]="",P.trigger(this._element,"shown.bs.collapse")}),this._element,!0),this._element.style[e]=`${this._element[i]}px`}hide(){if(this._isTransitioning||!this._isShown())return;if(P.trigger(this._element,"hide.bs.collapse").defaultPrevented)return;const t=this._getDimension();this._element.style[t]=`${this._element.getBoundingClientRect()[t]}px`,d(this._element),this._element.classList.add(ct),this._element.classList.remove(lt,at);for(const t of this._triggerArray){const e=z.getElementFromSelector(t);e&&!this._isShown(e)&&this._addAriaAndCollapsedClass([t],!1)}this._isTransitioning=!0,this._element.style[t]="",this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ct),this._element.classList.add(lt),P.trigger(this._element,"hidden.bs.collapse")}),this._element,!0)}_isShown(t=this._element){return t.classList.contains(at)}_configAfterMerge(t){return t.toggle=Boolean(t.toggle),t.parent=r(t.parent),t}_getDimension(){return this._element.classList.contains("collapse-horizontal")?"width":"height"}_initializeChildren(){if(!this._config.parent)return;const t=this._getFirstLevelChildren(ht);for(const e of t){const t=z.getElementFromSelector(e);t&&this._addAriaAndCollapsedClass([e],this._isShown(t))}}_getFirstLevelChildren(t){const e=z.find(":scope .collapse .collapse",this._config.parent);return z.find(t,this._config.parent).filter((t=>!e.includes(t)))}_addAriaAndCollapsedClass(t,e){if(t.length)for(const i of t)i.classList.toggle("collapsed",!e),i.setAttribute("aria-expanded",e)}static jQueryInterface(t){const e={};return"string"==typeof t&&/show|hide/.test(t)&&(e.toggle=!1),this.each((function(){const i=ft.getOrCreateInstance(this,e);if("string"==typeof t){if(void 0===i[t])throw new TypeError(`No method named "${t}"`);i[t]()}}))}}P.on(document,"click.bs.collapse.data-api",ht,(function(t){("A"===t.target.tagName||t.delegateTarget&&"A"===t.delegateTarget.tagName)&&t.preventDefault();for(const t of z.getMultipleElementsFromSelector(this))ft.getOrCreateInstance(t,{toggle:!1}).toggle()})),m(ft);var pt="top",mt="bottom",gt="right",_t="left",bt="auto",vt=[pt,mt,gt,_t],yt="start",wt="end",At="clippingParents",Et="viewport",Tt="popper",Ct="reference",Ot=vt.reduce((function(t,e){return t.concat([e+"-"+yt,e+"-"+wt])}),[]),xt=[].concat(vt,[bt]).reduce((function(t,e){return t.concat([e,e+"-"+yt,e+"-"+wt])}),[]),kt="beforeRead",Lt="read",St="afterRead",Dt="beforeMain",It="main",Nt="afterMain",Pt="beforeWrite",Mt="write",jt="afterWrite",Ft=[kt,Lt,St,Dt,It,Nt,Pt,Mt,jt];function Ht(t){return t?(t.nodeName||"").toLowerCase():null}function $t(t){if(null==t)return window;if("[object Window]"!==t.toString()){var e=t.ownerDocument;return e&&e.defaultView||window}return t}function Wt(t){return t instanceof $t(t).Element||t instanceof Element}function Bt(t){return t instanceof $t(t).HTMLElement||t instanceof HTMLElement}function zt(t){return"undefined"!=typeof ShadowRoot&&(t instanceof $t(t).ShadowRoot||t instanceof ShadowRoot)}const Rt={name:"applyStyles",enabled:!0,phase:"write",fn:function(t){var e=t.state;Object.keys(e.elements).forEach((function(t){var i=e.styles[t]||{},n=e.attributes[t]||{},s=e.elements[t];Bt(s)&&Ht(s)&&(Object.assign(s.style,i),Object.keys(n).forEach((function(t){var e=n[t];!1===e?s.removeAttribute(t):s.setAttribute(t,!0===e?"":e)})))}))},effect:function(t){var e=t.state,i={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(e.elements.popper.style,i.popper),e.styles=i,e.elements.arrow&&Object.assign(e.elements.arrow.style,i.arrow),function(){Object.keys(e.elements).forEach((function(t){var n=e.elements[t],s=e.attributes[t]||{},o=Object.keys(e.styles.hasOwnProperty(t)?e.styles[t]:i[t]).reduce((function(t,e){return t[e]="",t}),{});Bt(n)&&Ht(n)&&(Object.assign(n.style,o),Object.keys(s).forEach((function(t){n.removeAttribute(t)})))}))}},requires:["computeStyles"]};function qt(t){return t.split("-")[0]}var Vt=Math.max,Kt=Math.min,Qt=Math.round;function Xt(){var t=navigator.userAgentData;return null!=t&&t.brands&&Array.isArray(t.brands)?t.brands.map((function(t){return t.brand+"/"+t.version})).join(" "):navigator.userAgent}function Yt(){return!/^((?!chrome|android).)*safari/i.test(Xt())}function Ut(t,e,i){void 0===e&&(e=!1),void 0===i&&(i=!1);var n=t.getBoundingClientRect(),s=1,o=1;e&&Bt(t)&&(s=t.offsetWidth>0&&Qt(n.width)/t.offsetWidth||1,o=t.offsetHeight>0&&Qt(n.height)/t.offsetHeight||1);var r=(Wt(t)?$t(t):window).visualViewport,a=!Yt()&&i,l=(n.left+(a&&r?r.offsetLeft:0))/s,c=(n.top+(a&&r?r.offsetTop:0))/o,h=n.width/s,d=n.height/o;return{width:h,height:d,top:c,right:l+h,bottom:c+d,left:l,x:l,y:c}}function Gt(t){var e=Ut(t),i=t.offsetWidth,n=t.offsetHeight;return Math.abs(e.width-i)<=1&&(i=e.width),Math.abs(e.height-n)<=1&&(n=e.height),{x:t.offsetLeft,y:t.offsetTop,width:i,height:n}}function Jt(t,e){var i=e.getRootNode&&e.getRootNode();if(t.contains(e))return!0;if(i&&zt(i)){var n=e;do{if(n&&t.isSameNode(n))return!0;n=n.parentNode||n.host}while(n)}return!1}function Zt(t){return $t(t).getComputedStyle(t)}function te(t){return["table","td","th"].indexOf(Ht(t))>=0}function ee(t){return((Wt(t)?t.ownerDocument:t.document)||window.document).documentElement}function ie(t){return"html"===Ht(t)?t:t.assignedSlot||t.parentNode||(zt(t)?t.host:null)||ee(t)}function ne(t){return Bt(t)&&"fixed"!==Zt(t).position?t.offsetParent:null}function se(t){for(var e=$t(t),i=ne(t);i&&te(i)&&"static"===Zt(i).position;)i=ne(i);return i&&("html"===Ht(i)||"body"===Ht(i)&&"static"===Zt(i).position)?e:i||function(t){var e=/firefox/i.test(Xt());if(/Trident/i.test(Xt())&&Bt(t)&&"fixed"===Zt(t).position)return null;var i=ie(t);for(zt(i)&&(i=i.host);Bt(i)&&["html","body"].indexOf(Ht(i))<0;){var n=Zt(i);if("none"!==n.transform||"none"!==n.perspective||"paint"===n.contain||-1!==["transform","perspective"].indexOf(n.willChange)||e&&"filter"===n.willChange||e&&n.filter&&"none"!==n.filter)return i;i=i.parentNode}return null}(t)||e}function oe(t){return["top","bottom"].indexOf(t)>=0?"x":"y"}function re(t,e,i){return Vt(t,Kt(e,i))}function ae(t){return Object.assign({},{top:0,right:0,bottom:0,left:0},t)}function le(t,e){return e.reduce((function(e,i){return e[i]=t,e}),{})}const ce={name:"arrow",enabled:!0,phase:"main",fn:function(t){var e,i=t.state,n=t.name,s=t.options,o=i.elements.arrow,r=i.modifiersData.popperOffsets,a=qt(i.placement),l=oe(a),c=[_t,gt].indexOf(a)>=0?"height":"width";if(o&&r){var h=function(t,e){return ae("number"!=typeof(t="function"==typeof t?t(Object.assign({},e.rects,{placement:e.placement})):t)?t:le(t,vt))}(s.padding,i),d=Gt(o),u="y"===l?pt:_t,f="y"===l?mt:gt,p=i.rects.reference[c]+i.rects.reference[l]-r[l]-i.rects.popper[c],m=r[l]-i.rects.reference[l],g=se(o),_=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=p/2-m/2,v=h[u],y=_-d[c]-h[f],w=_/2-d[c]/2+b,A=re(v,w,y),E=l;i.modifiersData[n]=((e={})[E]=A,e.centerOffset=A-w,e)}},effect:function(t){var e=t.state,i=t.options.element,n=void 0===i?"[data-popper-arrow]":i;null!=n&&("string"!=typeof n||(n=e.elements.popper.querySelector(n)))&&Jt(e.elements.popper,n)&&(e.elements.arrow=n)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function he(t){return t.split("-")[1]}var de={top:"auto",right:"auto",bottom:"auto",left:"auto"};function ue(t){var e,i=t.popper,n=t.popperRect,s=t.placement,o=t.variation,r=t.offsets,a=t.position,l=t.gpuAcceleration,c=t.adaptive,h=t.roundOffsets,d=t.isFixed,u=r.x,f=void 0===u?0:u,p=r.y,m=void 0===p?0:p,g="function"==typeof h?h({x:f,y:m}):{x:f,y:m};f=g.x,m=g.y;var _=r.hasOwnProperty("x"),b=r.hasOwnProperty("y"),v=_t,y=pt,w=window;if(c){var A=se(i),E="clientHeight",T="clientWidth";A===$t(i)&&"static"!==Zt(A=ee(i)).position&&"absolute"===a&&(E="scrollHeight",T="scrollWidth"),(s===pt||(s===_t||s===gt)&&o===wt)&&(y=mt,m-=(d&&A===w&&w.visualViewport?w.visualViewport.height:A[E])-n.height,m*=l?1:-1),s!==_t&&(s!==pt&&s!==mt||o!==wt)||(v=gt,f-=(d&&A===w&&w.visualViewport?w.visualViewport.width:A[T])-n.width,f*=l?1:-1)}var C,O=Object.assign({position:a},c&&de),x=!0===h?function(t,e){var i=t.x,n=t.y,s=e.devicePixelRatio||1;return{x:Qt(i*s)/s||0,y:Qt(n*s)/s||0}}({x:f,y:m},$t(i)):{x:f,y:m};return f=x.x,m=x.y,l?Object.assign({},O,((C={})[y]=b?"0":"",C[v]=_?"0":"",C.transform=(w.devicePixelRatio||1)<=1?"translate("+f+"px, "+m+"px)":"translate3d("+f+"px, "+m+"px, 0)",C)):Object.assign({},O,((e={})[y]=b?m+"px":"",e[v]=_?f+"px":"",e.transform="",e))}const fe={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(t){var e=t.state,i=t.options,n=i.gpuAcceleration,s=void 0===n||n,o=i.adaptive,r=void 0===o||o,a=i.roundOffsets,l=void 0===a||a,c={placement:qt(e.placement),variation:he(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:s,isFixed:"fixed"===e.options.strategy};null!=e.modifiersData.popperOffsets&&(e.styles.popper=Object.assign({},e.styles.popper,ue(Object.assign({},c,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:r,roundOffsets:l})))),null!=e.modifiersData.arrow&&(e.styles.arrow=Object.assign({},e.styles.arrow,ue(Object.assign({},c,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})},data:{}};var pe={passive:!0};const me={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(t){var e=t.state,i=t.instance,n=t.options,s=n.scroll,o=void 0===s||s,r=n.resize,a=void 0===r||r,l=$t(e.elements.popper),c=[].concat(e.scrollParents.reference,e.scrollParents.popper);return o&&c.forEach((function(t){t.addEventListener("scroll",i.update,pe)})),a&&l.addEventListener("resize",i.update,pe),function(){o&&c.forEach((function(t){t.removeEventListener("scroll",i.update,pe)})),a&&l.removeEventListener("resize",i.update,pe)}},data:{}};var ge={left:"right",right:"left",bottom:"top",top:"bottom"};function _e(t){return t.replace(/left|right|bottom|top/g,(function(t){return ge[t]}))}var be={start:"end",end:"start"};function ve(t){return t.replace(/start|end/g,(function(t){return be[t]}))}function ye(t){var e=$t(t);return{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function we(t){return Ut(ee(t)).left+ye(t).scrollLeft}function Ae(t){var e=Zt(t),i=e.overflow,n=e.overflowX,s=e.overflowY;return/auto|scroll|overlay|hidden/.test(i+s+n)}function Ee(t){return["html","body","#document"].indexOf(Ht(t))>=0?t.ownerDocument.body:Bt(t)&&Ae(t)?t:Ee(ie(t))}function Te(t,e){var i;void 0===e&&(e=[]);var n=Ee(t),s=n===(null==(i=t.ownerDocument)?void 0:i.body),o=$t(n),r=s?[o].concat(o.visualViewport||[],Ae(n)?n:[]):n,a=e.concat(r);return s?a:a.concat(Te(ie(r)))}function Ce(t){return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}function Oe(t,e,i){return e===Et?Ce(function(t,e){var i=$t(t),n=ee(t),s=i.visualViewport,o=n.clientWidth,r=n.clientHeight,a=0,l=0;if(s){o=s.width,r=s.height;var c=Yt();(c||!c&&"fixed"===e)&&(a=s.offsetLeft,l=s.offsetTop)}return{width:o,height:r,x:a+we(t),y:l}}(t,i)):Wt(e)?function(t,e){var i=Ut(t,!1,"fixed"===e);return i.top=i.top+t.clientTop,i.left=i.left+t.clientLeft,i.bottom=i.top+t.clientHeight,i.right=i.left+t.clientWidth,i.width=t.clientWidth,i.height=t.clientHeight,i.x=i.left,i.y=i.top,i}(e,i):Ce(function(t){var e,i=ee(t),n=ye(t),s=null==(e=t.ownerDocument)?void 0:e.body,o=Vt(i.scrollWidth,i.clientWidth,s?s.scrollWidth:0,s?s.clientWidth:0),r=Vt(i.scrollHeight,i.clientHeight,s?s.scrollHeight:0,s?s.clientHeight:0),a=-n.scrollLeft+we(t),l=-n.scrollTop;return"rtl"===Zt(s||i).direction&&(a+=Vt(i.clientWidth,s?s.clientWidth:0)-o),{width:o,height:r,x:a,y:l}}(ee(t)))}function xe(t){var e,i=t.reference,n=t.element,s=t.placement,o=s?qt(s):null,r=s?he(s):null,a=i.x+i.width/2-n.width/2,l=i.y+i.height/2-n.height/2;switch(o){case pt:e={x:a,y:i.y-n.height};break;case mt:e={x:a,y:i.y+i.height};break;case gt:e={x:i.x+i.width,y:l};break;case _t:e={x:i.x-n.width,y:l};break;default:e={x:i.x,y:i.y}}var c=o?oe(o):null;if(null!=c){var h="y"===c?"height":"width";switch(r){case yt:e[c]=e[c]-(i[h]/2-n[h]/2);break;case wt:e[c]=e[c]+(i[h]/2-n[h]/2)}}return e}function ke(t,e){void 0===e&&(e={});var i=e,n=i.placement,s=void 0===n?t.placement:n,o=i.strategy,r=void 0===o?t.strategy:o,a=i.boundary,l=void 0===a?At:a,c=i.rootBoundary,h=void 0===c?Et:c,d=i.elementContext,u=void 0===d?Tt:d,f=i.altBoundary,p=void 0!==f&&f,m=i.padding,g=void 0===m?0:m,_=ae("number"!=typeof g?g:le(g,vt)),b=u===Tt?Ct:Tt,v=t.rects.popper,y=t.elements[p?b:u],w=function(t,e,i,n){var s="clippingParents"===e?function(t){var e=Te(ie(t)),i=["absolute","fixed"].indexOf(Zt(t).position)>=0&&Bt(t)?se(t):t;return Wt(i)?e.filter((function(t){return Wt(t)&&Jt(t,i)&&"body"!==Ht(t)})):[]}(t):[].concat(e),o=[].concat(s,[i]),r=o[0],a=o.reduce((function(e,i){var s=Oe(t,i,n);return e.top=Vt(s.top,e.top),e.right=Kt(s.right,e.right),e.bottom=Kt(s.bottom,e.bottom),e.left=Vt(s.left,e.left),e}),Oe(t,r,n));return a.width=a.right-a.left,a.height=a.bottom-a.top,a.x=a.left,a.y=a.top,a}(Wt(y)?y:y.contextElement||ee(t.elements.popper),l,h,r),A=Ut(t.elements.reference),E=xe({reference:A,element:v,strategy:"absolute",placement:s}),T=Ce(Object.assign({},v,E)),C=u===Tt?T:A,O={top:w.top-C.top+_.top,bottom:C.bottom-w.bottom+_.bottom,left:w.left-C.left+_.left,right:C.right-w.right+_.right},x=t.modifiersData.offset;if(u===Tt&&x){var k=x[s];Object.keys(O).forEach((function(t){var e=[gt,mt].indexOf(t)>=0?1:-1,i=[pt,mt].indexOf(t)>=0?"y":"x";O[t]+=k[i]*e}))}return O}function Le(t,e){void 0===e&&(e={});var i=e,n=i.placement,s=i.boundary,o=i.rootBoundary,r=i.padding,a=i.flipVariations,l=i.allowedAutoPlacements,c=void 0===l?xt:l,h=he(n),d=h?a?Ot:Ot.filter((function(t){return he(t)===h})):vt,u=d.filter((function(t){return c.indexOf(t)>=0}));0===u.length&&(u=d);var f=u.reduce((function(e,i){return e[i]=ke(t,{placement:i,boundary:s,rootBoundary:o,padding:r})[qt(i)],e}),{});return Object.keys(f).sort((function(t,e){return f[t]-f[e]}))}const Se={name:"flip",enabled:!0,phase:"main",fn:function(t){var e=t.state,i=t.options,n=t.name;if(!e.modifiersData[n]._skip){for(var s=i.mainAxis,o=void 0===s||s,r=i.altAxis,a=void 0===r||r,l=i.fallbackPlacements,c=i.padding,h=i.boundary,d=i.rootBoundary,u=i.altBoundary,f=i.flipVariations,p=void 0===f||f,m=i.allowedAutoPlacements,g=e.options.placement,_=qt(g),b=l||(_!==g&&p?function(t){if(qt(t)===bt)return[];var e=_e(t);return[ve(t),e,ve(e)]}(g):[_e(g)]),v=[g].concat(b).reduce((function(t,i){return t.concat(qt(i)===bt?Le(e,{placement:i,boundary:h,rootBoundary:d,padding:c,flipVariations:p,allowedAutoPlacements:m}):i)}),[]),y=e.rects.reference,w=e.rects.popper,A=new Map,E=!0,T=v[0],C=0;C<v.length;C++){var O=v[C],x=qt(O),k=he(O)===yt,L=[pt,mt].indexOf(x)>=0,S=L?"width":"height",D=ke(e,{placement:O,boundary:h,rootBoundary:d,altBoundary:u,padding:c}),I=L?k?gt:_t:k?mt:pt;y[S]>w[S]&&(I=_e(I));var N=_e(I),P=[];if(o&&P.push(D[x]<=0),a&&P.push(D[I]<=0,D[N]<=0),P.every((function(t){return t}))){T=O,E=!1;break}A.set(O,P)}if(E)for(var M=function(t){var e=v.find((function(e){var i=A.get(e);if(i)return i.slice(0,t).every((function(t){return t}))}));if(e)return T=e,"break"},j=p?3:1;j>0&&"break"!==M(j);j--);e.placement!==T&&(e.modifiersData[n]._skip=!0,e.placement=T,e.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function De(t,e,i){return void 0===i&&(i={x:0,y:0}),{top:t.top-e.height-i.y,right:t.right-e.width+i.x,bottom:t.bottom-e.height+i.y,left:t.left-e.width-i.x}}function Ie(t){return[pt,gt,mt,_t].some((function(e){return t[e]>=0}))}const Ne={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(t){var e=t.state,i=t.name,n=e.rects.reference,s=e.rects.popper,o=e.modifiersData.preventOverflow,r=ke(e,{elementContext:"reference"}),a=ke(e,{altBoundary:!0}),l=De(r,n),c=De(a,s,o),h=Ie(l),d=Ie(c);e.modifiersData[i]={referenceClippingOffsets:l,popperEscapeOffsets:c,isReferenceHidden:h,hasPopperEscaped:d},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":h,"data-popper-escaped":d})}},Pe={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(t){var e=t.state,i=t.options,n=t.name,s=i.offset,o=void 0===s?[0,0]:s,r=xt.reduce((function(t,i){return t[i]=function(t,e,i){var n=qt(t),s=[_t,pt].indexOf(n)>=0?-1:1,o="function"==typeof i?i(Object.assign({},e,{placement:t})):i,r=o[0],a=o[1];return r=r||0,a=(a||0)*s,[_t,gt].indexOf(n)>=0?{x:a,y:r}:{x:r,y:a}}(i,e.rects,o),t}),{}),a=r[e.placement],l=a.x,c=a.y;null!=e.modifiersData.popperOffsets&&(e.modifiersData.popperOffsets.x+=l,e.modifiersData.popperOffsets.y+=c),e.modifiersData[n]=r}},Me={name:"popperOffsets",enabled:!0,phase:"read",fn:function(t){var e=t.state,i=t.name;e.modifiersData[i]=xe({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})},data:{}},je={name:"preventOverflow",enabled:!0,phase:"main",fn:function(t){var e=t.state,i=t.options,n=t.name,s=i.mainAxis,o=void 0===s||s,r=i.altAxis,a=void 0!==r&&r,l=i.boundary,c=i.rootBoundary,h=i.altBoundary,d=i.padding,u=i.tether,f=void 0===u||u,p=i.tetherOffset,m=void 0===p?0:p,g=ke(e,{boundary:l,rootBoundary:c,padding:d,altBoundary:h}),_=qt(e.placement),b=he(e.placement),v=!b,y=oe(_),w="x"===y?"y":"x",A=e.modifiersData.popperOffsets,E=e.rects.reference,T=e.rects.popper,C="function"==typeof m?m(Object.assign({},e.rects,{placement:e.placement})):m,O="number"==typeof C?{mainAxis:C,altAxis:C}:Object.assign({mainAxis:0,altAxis:0},C),x=e.modifiersData.offset?e.modifiersData.offset[e.placement]:null,k={x:0,y:0};if(A){if(o){var L,S="y"===y?pt:_t,D="y"===y?mt:gt,I="y"===y?"height":"width",N=A[y],P=N+g[S],M=N-g[D],j=f?-T[I]/2:0,F=b===yt?E[I]:T[I],H=b===yt?-T[I]:-E[I],$=e.elements.arrow,W=f&&$?Gt($):{width:0,height:0},B=e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},z=B[S],R=B[D],q=re(0,E[I],W[I]),V=v?E[I]/2-j-q-z-O.mainAxis:F-q-z-O.mainAxis,K=v?-E[I]/2+j+q+R+O.mainAxis:H+q+R+O.mainAxis,Q=e.elements.arrow&&se(e.elements.arrow),X=Q?"y"===y?Q.clientTop||0:Q.clientLeft||0:0,Y=null!=(L=null==x?void 0:x[y])?L:0,U=N+K-Y,G=re(f?Kt(P,N+V-Y-X):P,N,f?Vt(M,U):M);A[y]=G,k[y]=G-N}if(a){var J,Z="x"===y?pt:_t,tt="x"===y?mt:gt,et=A[w],it="y"===w?"height":"width",nt=et+g[Z],st=et-g[tt],ot=-1!==[pt,_t].indexOf(_),rt=null!=(J=null==x?void 0:x[w])?J:0,at=ot?nt:et-E[it]-T[it]-rt+O.altAxis,lt=ot?et+E[it]+T[it]-rt-O.altAxis:st,ct=f&&ot?function(t,e,i){var n=re(t,e,i);return n>i?i:n}(at,et,lt):re(f?at:nt,et,f?lt:st);A[w]=ct,k[w]=ct-et}e.modifiersData[n]=k}},requiresIfExists:["offset"]};function Fe(t,e,i){void 0===i&&(i=!1);var n,s,o=Bt(e),r=Bt(e)&&function(t){var e=t.getBoundingClientRect(),i=Qt(e.width)/t.offsetWidth||1,n=Qt(e.height)/t.offsetHeight||1;return 1!==i||1!==n}(e),a=ee(e),l=Ut(t,r,i),c={scrollLeft:0,scrollTop:0},h={x:0,y:0};return(o||!o&&!i)&&(("body"!==Ht(e)||Ae(a))&&(c=(n=e)!==$t(n)&&Bt(n)?{scrollLeft:(s=n).scrollLeft,scrollTop:s.scrollTop}:ye(n)),Bt(e)?((h=Ut(e,!0)).x+=e.clientLeft,h.y+=e.clientTop):a&&(h.x=we(a))),{x:l.left+c.scrollLeft-h.x,y:l.top+c.scrollTop-h.y,width:l.width,height:l.height}}function He(t){var e=new Map,i=new Set,n=[];function s(t){i.add(t.name),[].concat(t.requires||[],t.requiresIfExists||[]).forEach((function(t){if(!i.has(t)){var n=e.get(t);n&&s(n)}})),n.push(t)}return t.forEach((function(t){e.set(t.name,t)})),t.forEach((function(t){i.has(t.name)||s(t)})),n}var $e={placement:"bottom",modifiers:[],strategy:"absolute"};function We(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return!e.some((function(t){return!(t&&"function"==typeof t.getBoundingClientRect)}))}function Be(t){void 0===t&&(t={});var e=t,i=e.defaultModifiers,n=void 0===i?[]:i,s=e.defaultOptions,o=void 0===s?$e:s;return function(t,e,i){void 0===i&&(i=o);var s,r,a={placement:"bottom",orderedModifiers:[],options:Object.assign({},$e,o),modifiersData:{},elements:{reference:t,popper:e},attributes:{},styles:{}},l=[],c=!1,h={state:a,setOptions:function(i){var s="function"==typeof i?i(a.options):i;d(),a.options=Object.assign({},o,a.options,s),a.scrollParents={reference:Wt(t)?Te(t):t.contextElement?Te(t.contextElement):[],popper:Te(e)};var r,c,u=function(t){var e=He(t);return Ft.reduce((function(t,i){return t.concat(e.filter((function(t){return t.phase===i})))}),[])}((r=[].concat(n,a.options.modifiers),c=r.reduce((function(t,e){var i=t[e.name];return t[e.name]=i?Object.assign({},i,e,{options:Object.assign({},i.options,e.options),data:Object.assign({},i.data,e.data)}):e,t}),{}),Object.keys(c).map((function(t){return c[t]}))));return a.orderedModifiers=u.filter((function(t){return t.enabled})),a.orderedModifiers.forEach((function(t){var e=t.name,i=t.options,n=void 0===i?{}:i,s=t.effect;if("function"==typeof s){var o=s({state:a,name:e,instance:h,options:n});l.push(o||function(){})}})),h.update()},forceUpdate:function(){if(!c){var t=a.elements,e=t.reference,i=t.popper;if(We(e,i)){a.rects={reference:Fe(e,se(i),"fixed"===a.options.strategy),popper:Gt(i)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(t){return a.modifiersData[t.name]=Object.assign({},t.data)}));for(var n=0;n<a.orderedModifiers.length;n++)if(!0!==a.reset){var s=a.orderedModifiers[n],o=s.fn,r=s.options,l=void 0===r?{}:r,d=s.name;"function"==typeof o&&(a=o({state:a,options:l,name:d,instance:h})||a)}else a.reset=!1,n=-1}}},update:(s=function(){return new Promise((function(t){h.forceUpdate(),t(a)}))},function(){return r||(r=new Promise((function(t){Promise.resolve().then((function(){r=void 0,t(s())}))}))),r}),destroy:function(){d(),c=!0}};if(!We(t,e))return h;function d(){l.forEach((function(t){return t()})),l=[]}return h.setOptions(i).then((function(t){!c&&i.onFirstUpdate&&i.onFirstUpdate(t)})),h}}var ze=Be(),Re=Be({defaultModifiers:[me,Me,fe,Rt]}),qe=Be({defaultModifiers:[me,Me,fe,Rt,Pe,Se,je,ce,Ne]});const Ve=Object.freeze(Object.defineProperty({__proto__:null,afterMain:Nt,afterRead:St,afterWrite:jt,applyStyles:Rt,arrow:ce,auto:bt,basePlacements:vt,beforeMain:Dt,beforeRead:kt,beforeWrite:Pt,bottom:mt,clippingParents:At,computeStyles:fe,createPopper:qe,createPopperBase:ze,createPopperLite:Re,detectOverflow:ke,end:wt,eventListeners:me,flip:Se,hide:Ne,left:_t,main:It,modifierPhases:Ft,offset:Pe,placements:xt,popper:Tt,popperGenerator:Be,popperOffsets:Me,preventOverflow:je,read:Lt,reference:Ct,right:gt,start:yt,top:pt,variationPlacements:Ot,viewport:Et,write:Mt},Symbol.toStringTag,{value:"Module"})),Ke="dropdown",Qe="ArrowUp",Xe="ArrowDown",Ye="click.bs.dropdown.data-api",Ue="keydown.bs.dropdown.data-api",Ge="show",Je='[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',Ze=`${Je}.show`,ti=".dropdown-menu",ei=p()?"top-end":"top-start",ii=p()?"top-start":"top-end",ni=p()?"bottom-end":"bottom-start",si=p()?"bottom-start":"bottom-end",oi=p()?"left-start":"right-start",ri=p()?"right-start":"left-start",ai={autoClose:!0,boundary:"clippingParents",display:"dynamic",offset:[0,2],popperConfig:null,reference:"toggle"},li={autoClose:"(boolean|string)",boundary:"(string|element)",display:"string",offset:"(array|string|function)",popperConfig:"(null|object|function)",reference:"(string|element|object)"};class ci extends W{constructor(t,e){super(t,e),this._popper=null,this._parent=this._element.parentNode,this._menu=z.next(this._element,ti)[0]||z.prev(this._element,ti)[0]||z.findOne(ti,this._parent),this._inNavbar=this._detectNavbar()}static get Default(){return ai}static get DefaultType(){return li}static get NAME(){return Ke}toggle(){return this._isShown()?this.hide():this.show()}show(){if(l(this._element)||this._isShown())return;const t={relatedTarget:this._element};if(!P.trigger(this._element,"show.bs.dropdown",t).defaultPrevented){if(this._createPopper(),"ontouchstart"in document.documentElement&&!this._parent.closest(".navbar-nav"))for(const t of[].concat(...document.body.children))P.on(t,"mouseover",h);this._element.focus(),this._element.setAttribute("aria-expanded",!0),this._menu.classList.add(Ge),this._element.classList.add(Ge),P.trigger(this._element,"shown.bs.dropdown",t)}}hide(){if(l(this._element)||!this._isShown())return;const t={relatedTarget:this._element};this._completeHide(t)}dispose(){this._popper&&this._popper.destroy(),super.dispose()}update(){this._inNavbar=this._detectNavbar(),this._popper&&this._popper.update()}_completeHide(t){if(!P.trigger(this._element,"hide.bs.dropdown",t).defaultPrevented){if("ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.off(t,"mouseover",h);this._popper&&this._popper.destroy(),this._menu.classList.remove(Ge),this._element.classList.remove(Ge),this._element.setAttribute("aria-expanded","false"),H.removeDataAttribute(this._menu,"popper"),P.trigger(this._element,"hidden.bs.dropdown",t)}}_getConfig(t){if("object"==typeof(t=super._getConfig(t)).reference&&!o(t.reference)&&"function"!=typeof t.reference.getBoundingClientRect)throw new TypeError(`${Ke.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);return t}_createPopper(){if(void 0===Ve)throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");let t=this._element;"parent"===this._config.reference?t=this._parent:o(this._config.reference)?t=r(this._config.reference):"object"==typeof this._config.reference&&(t=this._config.reference);const e=this._getPopperConfig();this._popper=qe(t,this._menu,e)}_isShown(){return this._menu.classList.contains(Ge)}_getPlacement(){const t=this._parent;if(t.classList.contains("dropend"))return oi;if(t.classList.contains("dropstart"))return ri;if(t.classList.contains("dropup-center"))return"top";if(t.classList.contains("dropdown-center"))return"bottom";const e="end"===getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();return t.classList.contains("dropup")?e?ii:ei:e?si:ni}_detectNavbar(){return null!==this._element.closest(".navbar")}_getOffset(){const{offset:t}=this._config;return"string"==typeof t?t.split(",").map((t=>Number.parseInt(t,10))):"function"==typeof t?e=>t(e,this._element):t}_getPopperConfig(){const t={placement:this._getPlacement(),modifiers:[{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"offset",options:{offset:this._getOffset()}}]};return(this._inNavbar||"static"===this._config.display)&&(H.setDataAttribute(this._menu,"popper","static"),t.modifiers=[{name:"applyStyles",enabled:!1}]),{...t,...g(this._config.popperConfig,[t])}}_selectMenuItem({key:t,target:e}){const i=z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",this._menu).filter((t=>a(t)));i.length&&b(i,e,t===Xe,!i.includes(e)).focus()}static jQueryInterface(t){return this.each((function(){const e=ci.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}static clearMenus(t){if(2===t.button||"keyup"===t.type&&"Tab"!==t.key)return;const e=z.find(Ze);for(const i of e){const e=ci.getInstance(i);if(!e||!1===e._config.autoClose)continue;const n=t.composedPath(),s=n.includes(e._menu);if(n.includes(e._element)||"inside"===e._config.autoClose&&!s||"outside"===e._config.autoClose&&s)continue;if(e._menu.contains(t.target)&&("keyup"===t.type&&"Tab"===t.key||/input|select|option|textarea|form/i.test(t.target.tagName)))continue;const o={relatedTarget:e._element};"click"===t.type&&(o.clickEvent=t),e._completeHide(o)}}static dataApiKeydownHandler(t){const e=/input|textarea/i.test(t.target.tagName),i="Escape"===t.key,n=[Qe,Xe].includes(t.key);if(!n&&!i)return;if(e&&!i)return;t.preventDefault();const s=this.matches(Je)?this:z.prev(this,Je)[0]||z.next(this,Je)[0]||z.findOne(Je,t.delegateTarget.parentNode),o=ci.getOrCreateInstance(s);if(n)return t.stopPropagation(),o.show(),void o._selectMenuItem(t);o._isShown()&&(t.stopPropagation(),o.hide(),s.focus())}}P.on(document,Ue,Je,ci.dataApiKeydownHandler),P.on(document,Ue,ti,ci.dataApiKeydownHandler),P.on(document,Ye,ci.clearMenus),P.on(document,"keyup.bs.dropdown.data-api",ci.clearMenus),P.on(document,Ye,Je,(function(t){t.preventDefault(),ci.getOrCreateInstance(this).toggle()})),m(ci);const hi="show",di="mousedown.bs.backdrop",ui={className:"modal-backdrop",clickCallback:null,isAnimated:!1,isVisible:!0,rootElement:"body"},fi={className:"string",clickCallback:"(function|null)",isAnimated:"boolean",isVisible:"boolean",rootElement:"(element|string)"};class pi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isAppended=!1,this._element=null}static get Default(){return ui}static get DefaultType(){return fi}static get NAME(){return"backdrop"}show(t){if(!this._config.isVisible)return void g(t);this._append();const e=this._getElement();this._config.isAnimated&&d(e),e.classList.add(hi),this._emulateAnimation((()=>{g(t)}))}hide(t){this._config.isVisible?(this._getElement().classList.remove(hi),this._emulateAnimation((()=>{this.dispose(),g(t)}))):g(t)}dispose(){this._isAppended&&(P.off(this._element,di),this._element.remove(),this._isAppended=!1)}_getElement(){if(!this._element){const t=document.createElement("div");t.className=this._config.className,this._config.isAnimated&&t.classList.add("fade"),this._element=t}return this._element}_configAfterMerge(t){return t.rootElement=r(t.rootElement),t}_append(){if(this._isAppended)return;const t=this._getElement();this._config.rootElement.append(t),P.on(t,di,(()=>{g(this._config.clickCallback)})),this._isAppended=!0}_emulateAnimation(t){_(t,this._getElement(),this._config.isAnimated)}}const mi=".bs.focustrap",gi="backward",_i={autofocus:!0,trapElement:null},bi={autofocus:"boolean",trapElement:"element"};class vi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isActive=!1,this._lastTabNavDirection=null}static get Default(){return _i}static get DefaultType(){return bi}static get NAME(){return"focustrap"}activate(){this._isActive||(this._config.autofocus&&this._config.trapElement.focus(),P.off(document,mi),P.on(document,"focusin.bs.focustrap",(t=>this._handleFocusin(t))),P.on(document,"keydown.tab.bs.focustrap",(t=>this._handleKeydown(t))),this._isActive=!0)}deactivate(){this._isActive&&(this._isActive=!1,P.off(document,mi))}_handleFocusin(t){const{trapElement:e}=this._config;if(t.target===document||t.target===e||e.contains(t.target))return;const i=z.focusableChildren(e);0===i.length?e.focus():this._lastTabNavDirection===gi?i[i.length-1].focus():i[0].focus()}_handleKeydown(t){"Tab"===t.key&&(this._lastTabNavDirection=t.shiftKey?gi:"forward")}}const yi=".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",wi=".sticky-top",Ai="padding-right",Ei="margin-right";class Ti{constructor(){this._element=document.body}getWidth(){const t=document.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}hide(){const t=this.getWidth();this._disableOverFlow(),this._setElementAttributes(this._element,Ai,(e=>e+t)),this._setElementAttributes(yi,Ai,(e=>e+t)),this._setElementAttributes(wi,Ei,(e=>e-t))}reset(){this._resetElementAttributes(this._element,"overflow"),this._resetElementAttributes(this._element,Ai),this._resetElementAttributes(yi,Ai),this._resetElementAttributes(wi,Ei)}isOverflowing(){return this.getWidth()>0}_disableOverFlow(){this._saveInitialAttribute(this._element,"overflow"),this._element.style.overflow="hidden"}_setElementAttributes(t,e,i){const n=this.getWidth();this._applyManipulationCallback(t,(t=>{if(t!==this._element&&window.innerWidth>t.clientWidth+n)return;this._saveInitialAttribute(t,e);const s=window.getComputedStyle(t).getPropertyValue(e);t.style.setProperty(e,`${i(Number.parseFloat(s))}px`)}))}_saveInitialAttribute(t,e){const i=t.style.getPropertyValue(e);i&&H.setDataAttribute(t,e,i)}_resetElementAttributes(t,e){this._applyManipulationCallback(t,(t=>{const i=H.getDataAttribute(t,e);null!==i?(H.removeDataAttribute(t,e),t.style.setProperty(e,i)):t.style.removeProperty(e)}))}_applyManipulationCallback(t,e){if(o(t))e(t);else for(const i of z.find(t,this._element))e(i)}}const Ci=".bs.modal",Oi="hidden.bs.modal",xi="show.bs.modal",ki="modal-open",Li="show",Si="modal-static",Di={backdrop:!0,focus:!0,keyboard:!0},Ii={backdrop:"(boolean|string)",focus:"boolean",keyboard:"boolean"};class Ni extends W{constructor(t,e){super(t,e),this._dialog=z.findOne(".modal-dialog",this._element),this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._isShown=!1,this._isTransitioning=!1,this._scrollBar=new Ti,this._addEventListeners()}static get Default(){return Di}static get DefaultType(){return Ii}static get NAME(){return"modal"}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){this._isShown||this._isTransitioning||P.trigger(this._element,xi,{relatedTarget:t}).defaultPrevented||(this._isShown=!0,this._isTransitioning=!0,this._scrollBar.hide(),document.body.classList.add(ki),this._adjustDialog(),this._backdrop.show((()=>this._showElement(t))))}hide(){this._isShown&&!this._isTransitioning&&(P.trigger(this._element,"hide.bs.modal").defaultPrevented||(this._isShown=!1,this._isTransitioning=!0,this._focustrap.deactivate(),this._element.classList.remove(Li),this._queueCallback((()=>this._hideModal()),this._element,this._isAnimated())))}dispose(){P.off(window,Ci),P.off(this._dialog,Ci),this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}handleUpdate(){this._adjustDialog()}_initializeBackDrop(){return new pi({isVisible:Boolean(this._config.backdrop),isAnimated:this._isAnimated()})}_initializeFocusTrap(){return new vi({trapElement:this._element})}_showElement(t){document.body.contains(this._element)||document.body.append(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.scrollTop=0;const e=z.findOne(".modal-body",this._dialog);e&&(e.scrollTop=0),d(this._element),this._element.classList.add(Li),this._queueCallback((()=>{this._config.focus&&this._focustrap.activate(),this._isTransitioning=!1,P.trigger(this._element,"shown.bs.modal",{relatedTarget:t})}),this._dialog,this._isAnimated())}_addEventListeners(){P.on(this._element,"keydown.dismiss.bs.modal",(t=>{"Escape"===t.key&&(this._config.keyboard?this.hide():this._triggerBackdropTransition())})),P.on(window,"resize.bs.modal",(()=>{this._isShown&&!this._isTransitioning&&this._adjustDialog()})),P.on(this._element,"mousedown.dismiss.bs.modal",(t=>{P.one(this._element,"click.dismiss.bs.modal",(e=>{this._element===t.target&&this._element===e.target&&("static"!==this._config.backdrop?this._config.backdrop&&this.hide():this._triggerBackdropTransition())}))}))}_hideModal(){this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._isTransitioning=!1,this._backdrop.hide((()=>{document.body.classList.remove(ki),this._resetAdjustments(),this._scrollBar.reset(),P.trigger(this._element,Oi)}))}_isAnimated(){return this._element.classList.contains("fade")}_triggerBackdropTransition(){if(P.trigger(this._element,"hidePrevented.bs.modal").defaultPrevented)return;const t=this._element.scrollHeight>document.documentElement.clientHeight,e=this._element.style.overflowY;"hidden"===e||this._element.classList.contains(Si)||(t||(this._element.style.overflowY="hidden"),this._element.classList.add(Si),this._queueCallback((()=>{this._element.classList.remove(Si),this._queueCallback((()=>{this._element.style.overflowY=e}),this._dialog)}),this._dialog),this._element.focus())}_adjustDialog(){const t=this._element.scrollHeight>document.documentElement.clientHeight,e=this._scrollBar.getWidth(),i=e>0;if(i&&!t){const t=p()?"paddingLeft":"paddingRight";this._element.style[t]=`${e}px`}if(!i&&t){const t=p()?"paddingRight":"paddingLeft";this._element.style[t]=`${e}px`}}_resetAdjustments(){this._element.style.paddingLeft="",this._element.style.paddingRight=""}static jQueryInterface(t,e){return this.each((function(){const i=Ni.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===i[t])throw new TypeError(`No method named "${t}"`);i[t](e)}}))}}P.on(document,"click.bs.modal.data-api",'[data-bs-toggle="modal"]',(function(t){const e=z.getElementFromSelector(this);["A","AREA"].includes(this.tagName)&&t.preventDefault(),P.one(e,xi,(t=>{t.defaultPrevented||P.one(e,Oi,(()=>{a(this)&&this.focus()}))}));const i=z.findOne(".modal.show");i&&Ni.getInstance(i).hide(),Ni.getOrCreateInstance(e).toggle(this)})),R(Ni),m(Ni);const Pi="show",Mi="showing",ji="hiding",Fi=".offcanvas.show",Hi="hidePrevented.bs.offcanvas",$i="hidden.bs.offcanvas",Wi={backdrop:!0,keyboard:!0,scroll:!1},Bi={backdrop:"(boolean|string)",keyboard:"boolean",scroll:"boolean"};class zi extends W{constructor(t,e){super(t,e),this._isShown=!1,this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._addEventListeners()}static get Default(){return Wi}static get DefaultType(){return Bi}static get NAME(){return"offcanvas"}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){this._isShown||P.trigger(this._element,"show.bs.offcanvas",{relatedTarget:t}).defaultPrevented||(this._isShown=!0,this._backdrop.show(),this._config.scroll||(new Ti).hide(),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.classList.add(Mi),this._queueCallback((()=>{this._config.scroll&&!this._config.backdrop||this._focustrap.activate(),this._element.classList.add(Pi),this._element.classList.remove(Mi),P.trigger(this._element,"shown.bs.offcanvas",{relatedTarget:t})}),this._element,!0))}hide(){this._isShown&&(P.trigger(this._element,"hide.bs.offcanvas").defaultPrevented||(this._focustrap.deactivate(),this._element.blur(),this._isShown=!1,this._element.classList.add(ji),this._backdrop.hide(),this._queueCallback((()=>{this._element.classList.remove(Pi,ji),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._config.scroll||(new Ti).reset(),P.trigger(this._element,$i)}),this._element,!0)))}dispose(){this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}_initializeBackDrop(){const t=Boolean(this._config.backdrop);return new pi({className:"offcanvas-backdrop",isVisible:t,isAnimated:!0,rootElement:this._element.parentNode,clickCallback:t?()=>{"static"!==this._config.backdrop?this.hide():P.trigger(this._element,Hi)}:null})}_initializeFocusTrap(){return new vi({trapElement:this._element})}_addEventListeners(){P.on(this._element,"keydown.dismiss.bs.offcanvas",(t=>{"Escape"===t.key&&(this._config.keyboard?this.hide():P.trigger(this._element,Hi))}))}static jQueryInterface(t){return this.each((function(){const e=zi.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}P.on(document,"click.bs.offcanvas.data-api",'[data-bs-toggle="offcanvas"]',(function(t){const e=z.getElementFromSelector(this);if(["A","AREA"].includes(this.tagName)&&t.preventDefault(),l(this))return;P.one(e,$i,(()=>{a(this)&&this.focus()}));const i=z.findOne(Fi);i&&i!==e&&zi.getInstance(i).hide(),zi.getOrCreateInstance(e).toggle(this)})),P.on(window,"load.bs.offcanvas.data-api",(()=>{for(const t of z.find(Fi))zi.getOrCreateInstance(t).show()})),P.on(window,"resize.bs.offcanvas",(()=>{for(const t of z.find("[aria-modal][class*=show][class*=offcanvas-]"))"fixed"!==getComputedStyle(t).position&&zi.getOrCreateInstance(t).hide()})),R(zi),m(zi);const Ri={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","srcset","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},qi=new Set(["background","cite","href","itemtype","longdesc","poster","src","xlink:href"]),Vi=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,Ki=(t,e)=>{const i=t.nodeName.toLowerCase();return e.includes(i)?!qi.has(i)||Boolean(Vi.test(t.nodeValue)):e.filter((t=>t instanceof RegExp)).some((t=>t.test(i)))},Qi={allowList:Ri,content:{},extraClass:"",html:!1,sanitize:!0,sanitizeFn:null,template:"<div></div>"},Xi={allowList:"object",content:"object",extraClass:"(string|function)",html:"boolean",sanitize:"boolean",sanitizeFn:"(null|function)",template:"string"},Yi={entry:"(string|element|function|null)",selector:"(string|element)"};class Ui extends ${constructor(t){super(),this._config=this._getConfig(t)}static get Default(){return Qi}static get DefaultType(){return Xi}static get NAME(){return"TemplateFactory"}getContent(){return Object.values(this._config.content).map((t=>this._resolvePossibleFunction(t))).filter(Boolean)}hasContent(){return this.getContent().length>0}changeContent(t){return this._checkContent(t),this._config.content={...this._config.content,...t},this}toHtml(){const t=document.createElement("div");t.innerHTML=this._maybeSanitize(this._config.template);for(const[e,i]of Object.entries(this._config.content))this._setContent(t,i,e);const e=t.children[0],i=this._resolvePossibleFunction(this._config.extraClass);return i&&e.classList.add(...i.split(" ")),e}_typeCheckConfig(t){super._typeCheckConfig(t),this._checkContent(t.content)}_checkContent(t){for(const[e,i]of Object.entries(t))super._typeCheckConfig({selector:e,entry:i},Yi)}_setContent(t,e,i){const n=z.findOne(i,t);n&&((e=this._resolvePossibleFunction(e))?o(e)?this._putElementInTemplate(r(e),n):this._config.html?n.innerHTML=this._maybeSanitize(e):n.textContent=e:n.remove())}_maybeSanitize(t){return this._config.sanitize?function(t,e,i){if(!t.length)return t;if(i&&"function"==typeof i)return i(t);const n=(new window.DOMParser).parseFromString(t,"text/html"),s=[].concat(...n.body.querySelectorAll("*"));for(const t of s){const i=t.nodeName.toLowerCase();if(!Object.keys(e).includes(i)){t.remove();continue}const n=[].concat(...t.attributes),s=[].concat(e["*"]||[],e[i]||[]);for(const e of n)Ki(e,s)||t.removeAttribute(e.nodeName)}return n.body.innerHTML}(t,this._config.allowList,this._config.sanitizeFn):t}_resolvePossibleFunction(t){return g(t,[this])}_putElementInTemplate(t,e){if(this._config.html)return e.innerHTML="",void e.append(t);e.textContent=t.textContent}}const Gi=new Set(["sanitize","allowList","sanitizeFn"]),Ji="fade",Zi="show",tn=".modal",en="hide.bs.modal",nn="hover",sn="focus",on={AUTO:"auto",TOP:"top",RIGHT:p()?"left":"right",BOTTOM:"bottom",LEFT:p()?"right":"left"},rn={allowList:Ri,animation:!0,boundary:"clippingParents",container:!1,customClass:"",delay:0,fallbackPlacements:["top","right","bottom","left"],html:!1,offset:[0,6],placement:"top",popperConfig:null,sanitize:!0,sanitizeFn:null,selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',title:"",trigger:"hover focus"},an={allowList:"object",animation:"boolean",boundary:"(string|element)",container:"(string|element|boolean)",customClass:"(string|function)",delay:"(number|object)",fallbackPlacements:"array",html:"boolean",offset:"(array|string|function)",placement:"(string|function)",popperConfig:"(null|object|function)",sanitize:"boolean",sanitizeFn:"(null|function)",selector:"(string|boolean)",template:"string",title:"(string|element|function)",trigger:"string"};class ln extends W{constructor(t,e){if(void 0===Ve)throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");super(t,e),this._isEnabled=!0,this._timeout=0,this._isHovered=null,this._activeTrigger={},this._popper=null,this._templateFactory=null,this._newContent=null,this.tip=null,this._setListeners(),this._config.selector||this._fixTitle()}static get Default(){return rn}static get DefaultType(){return an}static get NAME(){return"tooltip"}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}toggleEnabled(){this._isEnabled=!this._isEnabled}toggle(){this._isEnabled&&(this._activeTrigger.click=!this._activeTrigger.click,this._isShown()?this._leave():this._enter())}dispose(){clearTimeout(this._timeout),P.off(this._element.closest(tn),en,this._hideModalHandler),this._element.getAttribute("data-bs-original-title")&&this._element.setAttribute("title",this._element.getAttribute("data-bs-original-title")),this._disposePopper(),super.dispose()}show(){if("none"===this._element.style.display)throw new Error("Please use show on visible elements");if(!this._isWithContent()||!this._isEnabled)return;const t=P.trigger(this._element,this.constructor.eventName("show")),e=(c(this._element)||this._element.ownerDocument.documentElement).contains(this._element);if(t.defaultPrevented||!e)return;this._disposePopper();const i=this._getTipElement();this._element.setAttribute("aria-describedby",i.getAttribute("id"));const{container:n}=this._config;if(this._element.ownerDocument.documentElement.contains(this.tip)||(n.append(i),P.trigger(this._element,this.constructor.eventName("inserted"))),this._popper=this._createPopper(i),i.classList.add(Zi),"ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.on(t,"mouseover",h);this._queueCallback((()=>{P.trigger(this._element,this.constructor.eventName("shown")),!1===this._isHovered&&this._leave(),this._isHovered=!1}),this.tip,this._isAnimated())}hide(){if(this._isShown()&&!P.trigger(this._element,this.constructor.eventName("hide")).defaultPrevented){if(this._getTipElement().classList.remove(Zi),"ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.off(t,"mouseover",h);this._activeTrigger.click=!1,this._activeTrigger.focus=!1,this._activeTrigger.hover=!1,this._isHovered=null,this._queueCallback((()=>{this._isWithActiveTrigger()||(this._isHovered||this._disposePopper(),this._element.removeAttribute("aria-describedby"),P.trigger(this._element,this.constructor.eventName("hidden")))}),this.tip,this._isAnimated())}}update(){this._popper&&this._popper.update()}_isWithContent(){return Boolean(this._getTitle())}_getTipElement(){return this.tip||(this.tip=this._createTipElement(this._newContent||this._getContentForTemplate())),this.tip}_createTipElement(t){const e=this._getTemplateFactory(t).toHtml();if(!e)return null;e.classList.remove(Ji,Zi),e.classList.add(`bs-${this.constructor.NAME}-auto`);const i=(t=>{do{t+=Math.floor(1e6*Math.random())}while(document.getElementById(t));return t})(this.constructor.NAME).toString();return e.setAttribute("id",i),this._isAnimated()&&e.classList.add(Ji),e}setContent(t){this._newContent=t,this._isShown()&&(this._disposePopper(),this.show())}_getTemplateFactory(t){return this._templateFactory?this._templateFactory.changeContent(t):this._templateFactory=new Ui({...this._config,content:t,extraClass:this._resolvePossibleFunction(this._config.customClass)}),this._templateFactory}_getContentForTemplate(){return{".tooltip-inner":this._getTitle()}}_getTitle(){return this._resolvePossibleFunction(this._config.title)||this._element.getAttribute("data-bs-original-title")}_initializeOnDelegatedTarget(t){return this.constructor.getOrCreateInstance(t.delegateTarget,this._getDelegateConfig())}_isAnimated(){return this._config.animation||this.tip&&this.tip.classList.contains(Ji)}_isShown(){return this.tip&&this.tip.classList.contains(Zi)}_createPopper(t){const e=g(this._config.placement,[this,t,this._element]),i=on[e.toUpperCase()];return qe(this._element,t,this._getPopperConfig(i))}_getOffset(){const{offset:t}=this._config;return"string"==typeof t?t.split(",").map((t=>Number.parseInt(t,10))):"function"==typeof t?e=>t(e,this._element):t}_resolvePossibleFunction(t){return g(t,[this._element])}_getPopperConfig(t){const e={placement:t,modifiers:[{name:"flip",options:{fallbackPlacements:this._config.fallbackPlacements}},{name:"offset",options:{offset:this._getOffset()}},{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"arrow",options:{element:`.${this.constructor.NAME}-arrow`}},{name:"preSetPlacement",enabled:!0,phase:"beforeMain",fn:t=>{this._getTipElement().setAttribute("data-popper-placement",t.state.placement)}}]};return{...e,...g(this._config.popperConfig,[e])}}_setListeners(){const t=this._config.trigger.split(" ");for(const e of t)if("click"===e)P.on(this._element,this.constructor.eventName("click"),this._config.selector,(t=>{this._initializeOnDelegatedTarget(t).toggle()}));else if("manual"!==e){const t=e===nn?this.constructor.eventName("mouseenter"):this.constructor.eventName("focusin"),i=e===nn?this.constructor.eventName("mouseleave"):this.constructor.eventName("focusout");P.on(this._element,t,this._config.selector,(t=>{const e=this._initializeOnDelegatedTarget(t);e._activeTrigger["focusin"===t.type?sn:nn]=!0,e._enter()})),P.on(this._element,i,this._config.selector,(t=>{const e=this._initializeOnDelegatedTarget(t);e._activeTrigger["focusout"===t.type?sn:nn]=e._element.contains(t.relatedTarget),e._leave()}))}this._hideModalHandler=()=>{this._element&&this.hide()},P.on(this._element.closest(tn),en,this._hideModalHandler)}_fixTitle(){const t=this._element.getAttribute("title");t&&(this._element.getAttribute("aria-label")||this._element.textContent.trim()||this._element.setAttribute("aria-label",t),this._element.setAttribute("data-bs-original-title",t),this._element.removeAttribute("title"))}_enter(){this._isShown()||this._isHovered?this._isHovered=!0:(this._isHovered=!0,this._setTimeout((()=>{this._isHovered&&this.show()}),this._config.delay.show))}_leave(){this._isWithActiveTrigger()||(this._isHovered=!1,this._setTimeout((()=>{this._isHovered||this.hide()}),this._config.delay.hide))}_setTimeout(t,e){clearTimeout(this._timeout),this._timeout=setTimeout(t,e)}_isWithActiveTrigger(){return Object.values(this._activeTrigger).includes(!0)}_getConfig(t){const e=H.getDataAttributes(this._element);for(const t of Object.keys(e))Gi.has(t)&&delete e[t];return t={...e,..."object"==typeof t&&t?t:{}},t=this._mergeConfigObj(t),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}_configAfterMerge(t){return t.container=!1===t.container?document.body:r(t.container),"number"==typeof t.delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),t}_getDelegateConfig(){const t={};for(const[e,i]of Object.entries(this._config))this.constructor.Default[e]!==i&&(t[e]=i);return t.selector=!1,t.trigger="manual",t}_disposePopper(){this._popper&&(this._popper.destroy(),this._popper=null),this.tip&&(this.tip.remove(),this.tip=null)}static jQueryInterface(t){return this.each((function(){const e=ln.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}}m(ln);const cn={...ln.Default,content:"",offset:[0,8],placement:"right",template:'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',trigger:"click"},hn={...ln.DefaultType,content:"(null|string|element|function)"};class dn extends ln{static get Default(){return cn}static get DefaultType(){return hn}static get NAME(){return"popover"}_isWithContent(){return this._getTitle()||this._getContent()}_getContentForTemplate(){return{".popover-header":this._getTitle(),".popover-body":this._getContent()}}_getContent(){return this._resolvePossibleFunction(this._config.content)}static jQueryInterface(t){return this.each((function(){const e=dn.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}}m(dn);const un="click.bs.scrollspy",fn="active",pn="[href]",mn={offset:null,rootMargin:"0px 0px -25%",smoothScroll:!1,target:null,threshold:[.1,.5,1]},gn={offset:"(number|null)",rootMargin:"string",smoothScroll:"boolean",target:"element",threshold:"array"};class _n extends W{constructor(t,e){super(t,e),this._targetLinks=new Map,this._observableSections=new Map,this._rootElement="visible"===getComputedStyle(this._element).overflowY?null:this._element,this._activeTarget=null,this._observer=null,this._previousScrollData={visibleEntryTop:0,parentScrollTop:0},this.refresh()}static get Default(){return mn}static get DefaultType(){return gn}static get NAME(){return"scrollspy"}refresh(){this._initializeTargetsAndObservables(),this._maybeEnableSmoothScroll(),this._observer?this._observer.disconnect():this._observer=this._getNewObserver();for(const t of this._observableSections.values())this._observer.observe(t)}dispose(){this._observer.disconnect(),super.dispose()}_configAfterMerge(t){return t.target=r(t.target)||document.body,t.rootMargin=t.offset?`${t.offset}px 0px -30%`:t.rootMargin,"string"==typeof t.threshold&&(t.threshold=t.threshold.split(",").map((t=>Number.parseFloat(t)))),t}_maybeEnableSmoothScroll(){this._config.smoothScroll&&(P.off(this._config.target,un),P.on(this._config.target,un,pn,(t=>{const e=this._observableSections.get(t.target.hash);if(e){t.preventDefault();const i=this._rootElement||window,n=e.offsetTop-this._element.offsetTop;if(i.scrollTo)return void i.scrollTo({top:n,behavior:"smooth"});i.scrollTop=n}})))}_getNewObserver(){const t={root:this._rootElement,threshold:this._config.threshold,rootMargin:this._config.rootMargin};return new IntersectionObserver((t=>this._observerCallback(t)),t)}_observerCallback(t){const e=t=>this._targetLinks.get(`#${t.target.id}`),i=t=>{this._previousScrollData.visibleEntryTop=t.target.offsetTop,this._process(e(t))},n=(this._rootElement||document.documentElement).scrollTop,s=n>=this._previousScrollData.parentScrollTop;this._previousScrollData.parentScrollTop=n;for(const o of t){if(!o.isIntersecting){this._activeTarget=null,this._clearActiveClass(e(o));continue}const t=o.target.offsetTop>=this._previousScrollData.visibleEntryTop;if(s&&t){if(i(o),!n)return}else s||t||i(o)}}_initializeTargetsAndObservables(){this._targetLinks=new Map,this._observableSections=new Map;const t=z.find(pn,this._config.target);for(const e of t){if(!e.hash||l(e))continue;const t=z.findOne(decodeURI(e.hash),this._element);a(t)&&(this._targetLinks.set(decodeURI(e.hash),e),this._observableSections.set(e.hash,t))}}_process(t){this._activeTarget!==t&&(this._clearActiveClass(this._config.target),this._activeTarget=t,t.classList.add(fn),this._activateParents(t),P.trigger(this._element,"activate.bs.scrollspy",{relatedTarget:t}))}_activateParents(t){if(t.classList.contains("dropdown-item"))z.findOne(".dropdown-toggle",t.closest(".dropdown")).classList.add(fn);else for(const e of z.parents(t,".nav, .list-group"))for(const t of z.prev(e,".nav-link, .nav-item > .nav-link, .list-group-item"))t.classList.add(fn)}_clearActiveClass(t){t.classList.remove(fn);const e=z.find("[href].active",t);for(const t of e)t.classList.remove(fn)}static jQueryInterface(t){return this.each((function(){const e=_n.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}))}}P.on(window,"load.bs.scrollspy.data-api",(()=>{for(const t of z.find('[data-bs-spy="scroll"]'))_n.getOrCreateInstance(t)})),m(_n);const bn="ArrowLeft",vn="ArrowRight",yn="ArrowUp",wn="ArrowDown",An="active",En="fade",Tn="show",Cn='[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',On=`.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Cn}`;class xn extends W{constructor(t){super(t),this._parent=this._element.closest('.list-group, .nav, [role="tablist"]'),this._parent&&(this._setInitialAttributes(this._parent,this._getChildren()),P.on(this._element,"keydown.bs.tab",(t=>this._keydown(t))))}static get NAME(){return"tab"}show(){const t=this._element;if(this._elemIsActive(t))return;const e=this._getActiveElem(),i=e?P.trigger(e,"hide.bs.tab",{relatedTarget:t}):null;P.trigger(t,"show.bs.tab",{relatedTarget:e}).defaultPrevented||i&&i.defaultPrevented||(this._deactivate(e,t),this._activate(t,e))}_activate(t,e){t&&(t.classList.add(An),this._activate(z.getElementFromSelector(t)),this._queueCallback((()=>{"tab"===t.getAttribute("role")?(t.removeAttribute("tabindex"),t.setAttribute("aria-selected",!0),this._toggleDropDown(t,!0),P.trigger(t,"shown.bs.tab",{relatedTarget:e})):t.classList.add(Tn)}),t,t.classList.contains(En)))}_deactivate(t,e){t&&(t.classList.remove(An),t.blur(),this._deactivate(z.getElementFromSelector(t)),this._queueCallback((()=>{"tab"===t.getAttribute("role")?(t.setAttribute("aria-selected",!1),t.setAttribute("tabindex","-1"),this._toggleDropDown(t,!1),P.trigger(t,"hidden.bs.tab",{relatedTarget:e})):t.classList.remove(Tn)}),t,t.classList.contains(En)))}_keydown(t){if(![bn,vn,yn,wn].includes(t.key))return;t.stopPropagation(),t.preventDefault();const e=[vn,wn].includes(t.key),i=b(this._getChildren().filter((t=>!l(t))),t.target,e,!0);i&&(i.focus({preventScroll:!0}),xn.getOrCreateInstance(i).show())}_getChildren(){return z.find(On,this._parent)}_getActiveElem(){return this._getChildren().find((t=>this._elemIsActive(t)))||null}_setInitialAttributes(t,e){this._setAttributeIfNotExists(t,"role","tablist");for(const t of e)this._setInitialAttributesOnChild(t)}_setInitialAttributesOnChild(t){t=this._getInnerElement(t);const e=this._elemIsActive(t),i=this._getOuterElement(t);t.setAttribute("aria-selected",e),i!==t&&this._setAttributeIfNotExists(i,"role","presentation"),e||t.setAttribute("tabindex","-1"),this._setAttributeIfNotExists(t,"role","tab"),this._setInitialAttributesOnTargetPanel(t)}_setInitialAttributesOnTargetPanel(t){const e=z.getElementFromSelector(t);e&&(this._setAttributeIfNotExists(e,"role","tabpanel"),t.id&&this._setAttributeIfNotExists(e,"aria-labelledby",`${t.id}`))}_toggleDropDown(t,e){const i=this._getOuterElement(t);if(!i.classList.contains("dropdown"))return;const n=(t,n)=>{const s=z.findOne(t,i);s&&s.classList.toggle(n,e)};n(".dropdown-toggle",An),n(".dropdown-menu",Tn),i.setAttribute("aria-expanded",e)}_setAttributeIfNotExists(t,e,i){t.hasAttribute(e)||t.setAttribute(e,i)}_elemIsActive(t){return t.classList.contains(An)}_getInnerElement(t){return t.matches(On)?t:z.findOne(On,t)}_getOuterElement(t){return t.closest(".nav-item, .list-group-item")||t}static jQueryInterface(t){return this.each((function(){const e=xn.getOrCreateInstance(this);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}))}}P.on(document,"click.bs.tab",Cn,(function(t){["A","AREA"].includes(this.tagName)&&t.preventDefault(),l(this)||xn.getOrCreateInstance(this).show()})),P.on(window,"load.bs.tab",(()=>{for(const t of z.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'))xn.getOrCreateInstance(t)})),m(xn);const kn="hide",Ln="show",Sn="showing",Dn={animation:"boolean",autohide:"boolean",delay:"number"},In={animation:!0,autohide:!0,delay:5e3};class Nn extends W{constructor(t,e){super(t,e),this._timeout=null,this._hasMouseInteraction=!1,this._hasKeyboardInteraction=!1,this._setListeners()}static get Default(){return In}static get DefaultType(){return Dn}static get NAME(){return"toast"}show(){P.trigger(this._element,"show.bs.toast").defaultPrevented||(this._clearTimeout(),this._config.animation&&this._element.classList.add("fade"),this._element.classList.remove(kn),d(this._element),this._element.classList.add(Ln,Sn),this._queueCallback((()=>{this._element.classList.remove(Sn),P.trigger(this._element,"shown.bs.toast"),this._maybeScheduleHide()}),this._element,this._config.animation))}hide(){this.isShown()&&(P.trigger(this._element,"hide.bs.toast").defaultPrevented||(this._element.classList.add(Sn),this._queueCallback((()=>{this._element.classList.add(kn),this._element.classList.remove(Sn,Ln),P.trigger(this._element,"hidden.bs.toast")}),this._element,this._config.animation)))}dispose(){this._clearTimeout(),this.isShown()&&this._element.classList.remove(Ln),super.dispose()}isShown(){return this._element.classList.contains(Ln)}_maybeScheduleHide(){this._config.autohide&&(this._hasMouseInteraction||this._hasKeyboardInteraction||(this._timeout=setTimeout((()=>{this.hide()}),this._config.delay)))}_onInteraction(t,e){switch(t.type){case"mouseover":case"mouseout":this._hasMouseInteraction=e;break;case"focusin":case"focusout":this._hasKeyboardInteraction=e}if(e)return void this._clearTimeout();const i=t.relatedTarget;this._element===i||this._element.contains(i)||this._maybeScheduleHide()}_setListeners(){P.on(this._element,"mouseover.bs.toast",(t=>this._onInteraction(t,!0))),P.on(this._element,"mouseout.bs.toast",(t=>this._onInteraction(t,!1))),P.on(this._element,"focusin.bs.toast",(t=>this._onInteraction(t,!0))),P.on(this._element,"focusout.bs.toast",(t=>this._onInteraction(t,!1)))}_clearTimeout(){clearTimeout(this._timeout),this._timeout=null}static jQueryInterface(t){return this.each((function(){const e=Nn.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}return R(Nn),m(Nn),{Alert:q,Button:K,Carousel:rt,Collapse:ft,Dropdown:ci,Modal:Ni,Offcanvas:zi,Popover:dn,ScrollSpy:_n,Tab:xn,Toast:Nn,Tooltip:ln}}));

```

### frontend\public\js\GrammarChecker1.js
```js
// GrammarChecker1.js
import { SectionManager } from './sectionManager.js';
import { checkGrammar, detectLanguage, logUsageActivity } from './api.js'; 
import { showCustomAlert } from './utils.js';
import { NotificationManager } from './notifications.js';

const LANGUAGE_NAMES = {
  'en-US': 'English', 'fr': 'French', 'de': 'German', 'ru': 'Russian',
  'ja': 'Japanese', 'ja-JP': 'Japanese', 'es': 'Spanish', 'pt': 'Portuguese',
  'gl-ES': 'Galician', 'de-DE': 'German (Germany)'
};

function getLanguageName(code) {
  return LANGUAGE_NAMES[code] || code;
}
let currentUser = null;

async function initializeNotifications(user) {
  if (!user || !user.userId) {
    console.warn('Cannot initialize notifications: No user data');
    return;
  }
  
  try {
    await logUsageActivity({
      action: 'page_access',
      language: null,
      details: { page: 'grammar_checker' }
    });

    console.log('Initializing notifications for user:', user.username);
    
    // Đảm bảo chỉ có 1 instance duy nhất
    if (!window.notificationManager) {
      window.notificationManager = new NotificationManager();
      console.log('Created new NotificationManager instance');
    } else {
      console.log('Using existing NotificationManager instance');
    }
    
    // Initialize với user data
    await window.notificationManager.init(user.userId, user.userRole || 'user');
    
    console.log('Notifications initialized successfully');
    
  } catch (error) {
    console.error('Error initializing notifications:', error);
  }
}

document.addEventListener("DOMContentLoaded", async () => {
function getLoggedInUser() {
  // Try new keys first
  let userData = localStorage.getItem("loggedInAs_user") || localStorage.getItem("loggedInAs_admin");
  
  // Fallback to legacy key
  if (!userData) {
    userData = localStorage.getItem("loggedInAs");
  }
  
  return userData ? JSON.parse(userData) : null;
}

  const loggedInUser = getLoggedInUser();
  const textInput = document.getElementById('textInput');
  const languageSelect = document.getElementById('languageSelect');
  const checkGrammarBtn = document.getElementById('checkGrammarBtn');
  const highlightedTextDiv = document.getElementById('highlightedText');
  const suggestionsPanel = document.getElementById('suggestionsPanel');
  const suggestionsList = document.getElementById('suggestionsList');
  const wordCountSpan = document.getElementById('wordCount');
  const charCountSpan = document.getElementById('charCount');
  const errorCountSpan = document.getElementById('errorCount');
  const successMessageDiv = document.getElementById('successMessage');
  const errorMessageDiv = document.getElementById('errorMessage');
  const acceptAllBtn = document.getElementById('acceptAllBtn');
  const statsContainer = document.getElementById('statsContainer');
  const noSuggestionsDiv = document.querySelector('.no-suggestions');

  const dropdownUsername = document.getElementById('dropdownUsername');
  const dropdownEmail = document.getElementById('dropdownEmail');

  const sectionManager = new SectionManager();
  console.log('Section Manager initialized');

  if (loggedInUser) {
    dropdownUsername.textContent = loggedInUser.username || 'Unknown';
    dropdownEmail.textContent = loggedInUser.email || 'guest@example.com';
    currentUser = loggedInUser;
    await initializeNotifications(loggedInUser);
  }

  const settingsBtn = document.getElementById('settingsToggleBtn');
  const userDropdown = document.getElementById('userDropdown');
  
  settingsBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // Calculate position for fixed dropdown
    const rect = settingsBtn.getBoundingClientRect();
    const dropdown = userDropdown;
    
    if (dropdown.classList.contains('show')) {
      dropdown.classList.remove('show');
    } else {
      // Position dropdown relative to button
      dropdown.style.top = `${rect.bottom + 8}px`;
      dropdown.style.right = `${window.innerWidth - rect.right}px`;
      dropdown.classList.add('show');
    }
  });
  
  document.addEventListener('click', (e) => {
    if (!userDropdown.contains(e.target) && !settingsBtn.contains(e.target)) {
      userDropdown.classList.remove('show');
    }
  });
  
  // Handle window resize to reposition dropdown
  window.addEventListener('resize', () => {
    if (userDropdown.classList.contains('show')) {
      const rect = settingsBtn.getBoundingClientRect();
      userDropdown.style.top = `${rect.bottom + 8}px`;
      userDropdown.style.right = `${window.innerWidth - rect.right}px`;
    }
  });

  document.querySelector('.logout-btn')?.addEventListener('click', () => {
    localStorage.removeItem("loggedInAs");
    localStorage.removeItem("lastGrammarMatches");
    
    // ADD THIS: Cleanup notification manager on logout
    currentUser = null;
    if (notificationManager) {
      notificationManager = null;
      window.notificationManager = null;
    }
    
    window.location.href = 'login.html?message=logout_success';
  });

  function getFreeUsageCount() {
    return parseInt(localStorage.getItem("freeUsageCount") || "0");
  }

  function incrementFreeUsageCount() {
    localStorage.setItem("freeUsageCount", getFreeUsageCount() + 1);
  }

  function showLoginModal() {
    document.getElementById('loginModal')?.classList.remove('hidden');
  }

  function escapeHtml(text) {
    return text.replace(/[&<>"']/g, (match) => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[match]));
  }
  
  function showMessage(el, msg, type) {
    el.textContent = msg;
    el.className = `message ${type}`;
    el.classList.remove('hidden');
    setTimeout(() => {
      el.classList.add('hidden');
    }, 5000);
  }

  function setLoading(btn, isLoading) {
    const loader = btn.querySelector('.btn-loader');
    const btnText = btn.querySelector('.btn-text');
    
    if (isLoading) {
      btn.disabled = true;
      loader?.classList.remove('hidden');
      loader?.classList.add('show');
      btnText?.classList.add('hidden');
    } else {
      btn.disabled = false;
      loader?.classList.add('hidden');
      loader?.classList.remove('show');
      btnText?.classList.remove('hidden');
    }
  }

  function setAcceptAllLoading(isLoading) {
    setLoading(acceptAllBtn, isLoading);
  }

  function showNoSuggestions() {
    suggestionsList.classList.add('hidden');
    noSuggestionsDiv.classList.remove('hidden');
  }

  function hidePlaceholder() {
    const placeholder = highlightedTextDiv.querySelector('.placeholder-text');
    if (placeholder) {
      placeholder.style.display = 'none';
    }
  }

  function showPlaceholder() {
    const placeholder = highlightedTextDiv.querySelector('.placeholder-text');
    if (placeholder) {
      placeholder.style.display = 'flex';
    }
  }

  function getErrorTypeClass(match) {
    const category = match.rule?.category?.id || '';
    if (category.includes('TYPOS') || match.rule?.issueType === 'misspelling') {
      return 'Spelling Error';
    } else if (category.includes('GRAMMAR')) {
      return 'Grammar Error';
    } else if (category.includes('STYLE')) {
      return 'Style Suggestion';
    }
    return 'Grammar Error'; // default
  }

  function createSuggestionItem(match, index) {
    const errorText = match.context?.text?.slice(match.context.offset, match.context.offset + match.context.length) || 'Unknown';
    const firstReplacement = match.replacements?.[0]?.value || '';
    const errorType = getErrorTypeClass(match);
    
    const li = document.createElement('li');
    li.className = 'suggestion-item';
    li.innerHTML = `
      <div class="suggestion-error">${errorType}</div>
      <div class="suggestion-message">${escapeHtml(match.message)}</div>
      <div class="suggestion-actions">
        ${firstReplacement ? `<span class="suggestion-fix">${escapeHtml(errorText)} → ${escapeHtml(firstReplacement)}</span>` : '<em>No suggestions available</em>'}
        ${firstReplacement ? `<button class="suggestion-apply-btn" data-error-index="${index}" data-replacement="${escapeHtml(firstReplacement)}">Apply</button>` : ''}
      </div>
    `;
    
    return li;
  }

  function displayResults(text, matches) {
    hidePlaceholder();
    
    let html = '', lastIndex = 0;
    suggestionsList.innerHTML = '';
    suggestionsList.classList.remove('hidden');
    noSuggestionsDiv.classList.add('hidden');
    
    matches.sort((a, b) => a.offset - b.offset);

    matches.forEach((match, index) => {
      html += escapeHtml(text.slice(lastIndex, match.offset));
      const errorText = text.slice(match.offset, match.offset + match.length);
      html += `<span class="grammar-error" data-error-index="${index}" title="${escapeHtml(match.message)}">${escapeHtml(errorText)}</span>`;
      lastIndex = match.offset + match.length;

      // Console logging for debugging
      const firstReplacement = match.replacements?.[0]?.value;
      const source = match.source || 'Unknown';
      console.log(`🔎 Suggestion #${index + 1}`);
      console.log(`📌 Mistake: "${errorText}"`);
      console.log(`💡 Suggest: "${firstReplacement || '[No suggestion]'}"`);
      console.log(`📖 Message: ${match.message}`);
      console.log(`🏷️ Source: ${source}`);
      console.log('-----------------------');

      // Create suggestion item with new design
      const suggestionItem = createSuggestionItem(match, index);
      suggestionsList.appendChild(suggestionItem);
    });

    html += escapeHtml(text.slice(lastIndex));
    highlightedTextDiv.innerHTML = html;

    // Add event listeners to apply buttons
    document.querySelectorAll('.suggestion-apply-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.dataset.errorIndex);
        const replacement = e.target.dataset.replacement;
        applySuggestion(index, replacement);
      });
    });

    // Add event listeners to grammar errors in text
    document.querySelectorAll('.grammar-error').forEach(el => {
      el.addEventListener('click', () => {
        const index = parseInt(el.dataset.errorIndex);
        const suggestionItem = document.querySelector(`[data-error-index="${index}"]`).closest('.suggestion-item');
        if (suggestionItem) {
          suggestionItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          suggestionItem.style.backgroundColor = 'var(--primary-50)';
          setTimeout(() => {
            suggestionItem.style.backgroundColor = '';
          }, 2000);
        }
      });
    });

    acceptAllBtn?.classList.remove('hidden');
  }

  // Accept All functionality
  acceptAllBtn?.addEventListener('click', () => {
    const matches = JSON.parse(localStorage.getItem('lastGrammarMatches') || '[]');
    if (!matches.length) return;

    let updatedText = textInput.value;
    let offsetShift = 0;
    setAcceptAllLoading(true);

    matches.forEach(match => {
      const replacement = match.replacements?.[0]?.value;
      if (replacement) {
        const start = match.offset + offsetShift;
        const end = start + match.length;
        updatedText = updatedText.slice(0, start) + replacement + updatedText.slice(end);
        offsetShift += replacement.length - match.length;
      }
    });

    setTimeout(() => {
      textInput.value = updatedText;
      highlightedTextDiv.textContent = updatedText;
      showNoSuggestions();
      errorCountSpan.textContent = '0';
      acceptAllBtn.classList.add('hidden');
      setAcceptAllLoading(false);
      showCustomAlert('All suggestions applied!', 'success');
      hidePlaceholder();
    }, 300);
  });

  function applySuggestion(index, replacement) {
    const text = textInput.value;
    const matches = JSON.parse(localStorage.getItem('lastGrammarMatches') || '[]');
    const match = matches[index];
    
    if (!match) return;
    
    const newText = text.slice(0, match.offset) + replacement + text.slice(match.offset + match.length);
    textInput.value = newText;
    highlightedTextDiv.textContent = newText;
    
    // Remove the applied suggestion from the list
    const suggestionItem = document.querySelector(`[data-error-index="${index}"]`).closest('.suggestion-item');
    if (suggestionItem) {
      suggestionItem.style.transform = 'translateX(100%)';
      suggestionItem.style.opacity = '0';
      setTimeout(() => {
        suggestionItem.remove();
        
        // Check if there are any suggestions left
        const remainingSuggestions = suggestionsList.querySelectorAll('.suggestion-item');
        if (remainingSuggestions.length === 0) {
          showNoSuggestions();
          acceptAllBtn?.classList.add('hidden');
        }
        
        // Update error count
        errorCountSpan.textContent = remainingSuggestions.length;
      }, 300);
    }
    
    hidePlaceholder();
    showCustomAlert("Suggestion applied!", 'success');
  }

  function showLoading(isLoading) {
    setLoading(checkGrammarBtn, isLoading);
  }

  function hideMessages() {
    successMessageDiv.classList.add('hidden');
    errorMessageDiv.classList.add('hidden');
  }

  function updateStats() {
    const text = textInput.value;
    charCountSpan.textContent = text.length;
    wordCountSpan.textContent = (text.match(/\b\w+\b/g) || []).length;
  }

  function populateLanguages() {
    languageSelect.innerHTML = ''; // Clear existing options
    [
      { code: 'en-US', name: 'English (US)' },
      { code: 'ja-JP', name: 'Japanese' },
      { code: 'fr', name: 'French' },
      { code: 'de', name: 'German' },
      { code: 'ru', name: 'Russian' },
      { code: 'es', name: 'Spanish' },
    ].forEach(({ code, name }) => {
      const opt = document.createElement('option');
      opt.value = code;
      opt.textContent = name;
      languageSelect.appendChild(opt);
    });
    languageSelect.value = 'en-US';
  }

  checkGrammarBtn?.addEventListener('click', async () => {
    hideMessages();
    const text = textInput.value.trim();
    const lang = languageSelect.value;

    if (!text) {
      showMessage(errorMessageDiv, 'Please enter some text to check.', 'error');
      return;
    }
    
    if (!loggedInUser?.userId && getFreeUsageCount() >= 3) {
      showMessage(errorMessageDiv, '⚠️ You have used all 3 free grammar checks. Please log in to continue.', 'error');
      return showLoginModal();
    }

    showLoading(true);
    try {
      const detectedLang = await detectLanguage(text);
      if (detectedLang !== lang) {
        showMessage(errorMessageDiv, `⚠️ Detected language is "${getLanguageName(detectedLang)}", but you selected "${getLanguageName(lang)}".`, 'error');
        return;
      }

      if (!loggedInUser?.userId) incrementFreeUsageCount();

      const { matches = [] } = await checkGrammar(text);
      localStorage.setItem('lastGrammarMatches', JSON.stringify(matches));

      if (loggedInUser?.userId) {
        await logUsageActivity({
          action: 'grammar_check',
          language: detectedLang, 
          details: {
            text_length: text.length,
            errors_found: matches.length,
            timestamp: new Date().toISOString()
          }
        });
      }

      if (!matches.length) {
        highlightedTextDiv.textContent = text;
        showNoSuggestions();
        acceptAllBtn?.classList.add('hidden');
        hidePlaceholder();
        showMessage(successMessageDiv, 'No grammar errors found! Your text looks great.', 'success');
      } else {
        displayResults(text, matches);
        showMessage(successMessageDiv, `Found ${matches.length} grammar issue${matches.length === 1 ? '' : 's'} to review.`, 'success');
      }

      errorCountSpan.textContent = matches.length;
    } catch (err) {
      console.error('Error checking grammar:', err);
      showMessage(errorMessageDiv, 'Grammar check failed. Please try again.', 'error');
    } finally {
      showLoading(false);
      updateStats();
    }
  });

  textInput.addEventListener('input', () => {
    const text = textInput.value.trim();
    updateStats();
    hideMessages();
    
    if (text) {
      highlightedTextDiv.textContent = text;
      hidePlaceholder();
    } else {
      highlightedTextDiv.innerHTML = `
        <div class="placeholder-text">
          <i class="fas fa-magic"></i>
          <p>Your corrected text will appear here.</p>
          <small>Start by entering text and clicking "Check Grammar"</small>
        </div>
      `;
    }
    
    errorCountSpan.textContent = '0';
    suggestionsList.innerHTML = '';
    suggestionsList.classList.add('hidden');
    noSuggestionsDiv.classList.add('hidden');
    acceptAllBtn?.classList.add('hidden');
  });

  // Initialize
  populateLanguages();
  updateStats();
  // Set initial placeholder if no text
  if (!textInput.value.trim()) {
    highlightedTextDiv.innerHTML = `
      <div class="placeholder-text">
        <i class="fas fa-magic"></i>
        <p>Your corrected text will appear here.</p>
        <small>Start by entering text and clicking "Check Grammar"</small>
      </div>
    `;
  }
});


```

### frontend\public\js\index.js
```js
// frontend/public/js/index.js

import { registerUser } from './api.js'; 
import { showCustomAlert, togglePassword } from './utils.js';

document.addEventListener("DOMContentLoaded", () => {
    const registerForm = document.getElementById("registerForm");
    const usernameInput = document.getElementById("username");
    const passwordInput = document.getElementById("password");
    const confirmPasswordInput = document.getElementById("confirmPassword");
    const phoneInput = document.getElementById("phone");
    const emailInput = document.getElementById("email");
    const fullNameInput = document.getElementById("fullName");

    const usernameError = document.getElementById("usernameError");
    const passwordError = document.getElementById("passwordError");
    const confirmPasswordError = document.getElementById("confirmPasswordError");
    const phoneError = document.getElementById("phoneError");
    const emailError = document.getElementById("emailError");
    const fullNameError = document.getElementById("fullNameError");
    const registerSuccess = document.getElementById("registerSuccess");
    const registerGeneralError = document.getElementById("registerGeneralError");

    // Show/Hide loading state on submit button
    function toggleSubmitButton(isLoading = false) {
        const submitBtn = document.querySelector('.submit-btn');
        const btnText = submitBtn?.querySelector('.btn-text');
        const btnLoading = submitBtn?.querySelector('.btn-loading');
        
        if (submitBtn && btnText && btnLoading) {
            if (isLoading) {
                btnText.classList.add('hidden');
                btnLoading.classList.remove('hidden');
                submitBtn.disabled = true;
            } else {
                btnText.classList.remove('hidden');
                btnLoading.classList.add('hidden');
                submitBtn.disabled = false;
            }
        }
    }

    // Enhanced error display with styling
    function displayError(element, message) {
        if (element) {
            element.textContent = message;
            element.style.color = '#ef4444';
            element.style.display = 'block';
        }
    }

    function clearError(element) {
        if (element) {
            element.textContent = "";
            element.style.display = 'none';
        }
    }

    function displaySuccess(element, message) {
        if (element) {
            element.textContent = message;
            element.style.color = '#10b981';
            element.style.display = 'block';
        }
    }

    function clearMessages() {
        clearError(usernameError);
        clearError(passwordError);
        clearError(confirmPasswordError);
        clearError(phoneError);
        clearError(emailError);
        clearError(fullNameError);
        clearError(registerSuccess);
        clearError(registerGeneralError);
    }

    function validateForm() {
        let isValid = true;
        let firstErrorField = null;
        
        clearMessages();

        // ✅ ADDED: Full Name validation
        if (fullNameInput.value.trim().length < 2) {
            displayError(fullNameError, "Full name must be at least 2 characters.");
            if (!firstErrorField) firstErrorField = fullNameInput;
            isValid = false;
        }

        // Username validation
        if (usernameInput.value.trim().length < 3) {
            displayError(usernameError, "Username must be at least 3 characters.");
            if (!firstErrorField) firstErrorField = usernameInput;
            isValid = false;
        }

        // Password validation
        if (passwordInput.value.length < 6) {
            displayError(passwordError, "Password must be at least 6 characters.");
            if (!firstErrorField) firstErrorField = passwordInput;
            isValid = false;
        }

        // Confirm password validation
        if (passwordInput.value !== confirmPasswordInput.value) {
            displayError(confirmPasswordError, "Passwords do not match.");
            if (!firstErrorField) firstErrorField = confirmPasswordInput;
            isValid = false;
        }

        // Email validation (enhanced)
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(emailInput.value.trim())) {
            displayError(emailError, "Please enter a valid email address.");
            if (!firstErrorField) firstErrorField = emailInput;
            isValid = false;
        }

        // Phone validation (optional but if provided must be valid)
        if (phoneInput.value.trim() !== "") {
            const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
            if (!phoneRegex.test(phoneInput.value.trim())) {
                displayError(phoneError, "Please enter a valid phone number.");
                if (!firstErrorField) firstErrorField = phoneInput;
                isValid = false;
            }
        }

        if (firstErrorField) {
            firstErrorField.focus();
        }

        return isValid;
    }

    // Enhanced real-time validation
    fullNameInput?.addEventListener('input', () => {
        if (fullNameInput.value.trim().length >= 2) {
            clearError(fullNameError);
        }
    });

    usernameInput?.addEventListener('input', () => {
        if (usernameInput.value.trim().length >= 3) {
            clearError(usernameError);
        }
    });

    passwordInput?.addEventListener('input', () => {
        if (passwordInput.value.length >= 6) {
            clearError(passwordError);
        }
        if (confirmPasswordInput.value && passwordInput.value === confirmPasswordInput.value) {
            clearError(confirmPasswordError);
        }
    });

    confirmPasswordInput?.addEventListener('input', () => {
        if (passwordInput.value === confirmPasswordInput.value) {
            clearError(confirmPasswordError);
        }
    });

    emailInput?.addEventListener('input', () => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (emailRegex.test(emailInput.value.trim())) {
            clearError(emailError);
        }
    });

    phoneInput?.addEventListener('input', () => {
        const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
        if (phoneInput.value.trim() === "" || phoneRegex.test(phoneInput.value.trim())) {
            clearError(phoneError);
        }
    });

    document.querySelectorAll('.toggle-password').forEach(btn => {
        btn.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            togglePassword(this.querySelector('i')); 
        });
    });

    registerForm?.addEventListener("submit", async function(e) {
        e.preventDefault();
        clearMessages();

        if (validateForm()) {
            const fullName = fullNameInput.value.trim();
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            const email = emailInput.value.trim();
            const phone = phoneInput.value.trim();

            try {
                toggleSubmitButton(true);

                const data = await registerUser({ fullName, username, password, email, phone });

                if (data.success) {
                    showCustomAlert("Registration successful! Redirecting to login...", 'success');
                    displaySuccess(registerSuccess, "Registration successful! Redirecting to login...");

                    const params = new URLSearchParams(window.location.search);
                    const redirectTo = params.get('redirect');

                    setTimeout(() => {
                        const authContainer = document.querySelector('.auth-container');
                        if (authContainer) {
                            authContainer.style.transform = 'translateY(-20px)';
                            authContainer.style.opacity = '0';
                            authContainer.style.transition = 'all 0.3s ease-out';
                        }
                    }, 1000);

                    setTimeout(() => {
                        if (redirectTo) {
                            window.location.href = redirectTo;
                        } else {
                            window.location.href = "login.html?message=registration_success";
                        }
                    }, 1500);
                } else {
                    const errorMessage = data.error || "Registration failed. Please try again.";
                    showCustomAlert(errorMessage, 'error');
                    displayError(registerGeneralError, errorMessage);
                }
            } catch (error) {
                console.error('Error during registration API call:', error);
                const errorMsg = "Network error or server unavailable. Please try again later.";
                showCustomAlert(errorMsg, 'error');
                displayError(registerGeneralError, errorMsg);
            } finally {
                toggleSubmitButton(false);
            }
        } else {
            displayError(registerGeneralError, "Please correct the errors above.");
        }
    });

    const animationParams = new URLSearchParams(window.location.search);
    if (animationParams.get("animate") === "right") {
        const authContainer = document.querySelector('.auth-container');
        if (authContainer) {
            authContainer.classList.add("slide-in-right");
        }
    }

    const switchFormLinks = document.querySelectorAll('.switch-form-link');
    switchFormLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const href = link.getAttribute('href');
            
            if (href) {
                const authContainer = document.querySelector('.auth-container');
                if (authContainer) {
                    authContainer.style.transform = 'translateX(-100px)';
                    authContainer.style.opacity = '0';
                    authContainer.style.transition = 'all 0.3s ease-out';
                }
                
                setTimeout(() => {
                    window.location.href = href;
                }, 300);
            }
        });
    });

    // Enhanced back arrow functionality
    const backArrowBtn = document.querySelector('.back-arrow-btn');
    if (backArrowBtn) {
        backArrowBtn.addEventListener('click', (e) => {
            e.preventDefault();
            
            const authContainer = document.querySelector('.auth-container');
            if (authContainer) {
                authContainer.style.transform = 'scale(0.95)';
                authContainer.style.opacity = '0';
                authContainer.style.transition = 'all 0.3s ease-out';
            }
            
            setTimeout(() => {
                window.location.href = backArrowBtn.href;
            }, 300);
        });
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.activeElement?.blur();
            clearMessages();
        }
        
        if (e.key === 'Enter' && e.target.tagName !== 'BUTTON') {
            const submitBtn = document.querySelector('.submit-btn');
            if (submitBtn && !submitBtn.disabled) {
                submitBtn.click();
            }
        }
    });

    setTimeout(() => {
        if (!fullNameInput?.value) {
            fullNameInput?.focus();
        } else if (!usernameInput?.value) {
            usernameInput?.focus();
        } else if (!passwordInput?.value) {
            passwordInput?.focus();
        } else if (!confirmPasswordInput?.value) {
            confirmPasswordInput?.focus();
        } else if (!emailInput?.value) {
            emailInput?.focus();
        }
    }, 100);

    function resetForm() {
        registerForm?.reset();
        clearMessages();
        fullNameInput?.focus(); 
    }

    const resetBtn = document.querySelector('.reset-btn');
    if (resetBtn) {
        resetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            resetForm();
        });
    }

    // Password strength indicator (optional enhancement)
    passwordInput?.addEventListener('input', () => {
        const password = passwordInput.value;
        const strengthIndicator = document.querySelector('.password-strength');
        
        if (strengthIndicator) {
            let strength = 0;
            if (password.length >= 6) strength++;
            if (password.match(/[a-z]/)) strength++;
            if (password.match(/[A-Z]/)) strength++;
            if (password.match(/[0-9]/)) strength++;
            if (password.match(/[^a-zA-Z0-9]/)) strength++;
            
            strengthIndicator.className = `password-strength strength-${strength}`;
            
            const strengthTexts = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'];
            strengthIndicator.textContent = strengthTexts[strength] || '';
        }
    });
});
```

### frontend\public\js\login.js
```js
// frontend/public/js/login.js

import { loginUser, logUsageActivity } from './api.js';
import { showCustomAlert, togglePassword } from './utils.js';

function displayError(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = '#ef4444'; 
        element.style.display = 'block';
    }
}

function clearError(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = '';
        element.style.display = 'none';
    }
}

function displaySuccess(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = '#10b981'; 
        element.style.display = 'block';
    }
}

// Show/Hide loading state on submit button
function toggleSubmitButton(isLoading = false) {
    const submitBtn = document.querySelector('.submit-btn');
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnLoading = submitBtn?.querySelector('.btn-loading');
    
    if (submitBtn && btnText && btnLoading) {
        if (isLoading) {
            btnText.classList.add('hidden');
            btnLoading.classList.remove('hidden');
            submitBtn.disabled = true;
        } else {
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            submitBtn.disabled = false;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const usernameInput = document.getElementById('loginUsername');
    const passwordInput = document.getElementById('loginPassword');
    const loginGeneralError = document.getElementById('loginGeneralError');
    const loginSuccess = document.getElementById('loginSuccess');

    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');

    // 👁️ Enhanced toggle password functionality
    document.querySelectorAll('.toggle-password').forEach(btn => {
    btn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();

        togglePassword(this.querySelector('i'));
        });
    });

    // Show message if exists in URL params
    if (message === 'registration_success') {
        showCustomAlert("Registration successful! Please log in.", 'success');
        displaySuccess('loginSuccess', 'Registration successful! Please log in.');
        history.replaceState({}, document.title, window.location.pathname);
    } else if (message === 'login_required') {
        showCustomAlert("Please log in to access the grammar checker.", 'info');
        history.replaceState({}, document.title, window.location.pathname);
    }

    // Enhanced animation for page transition
    const animateParam = urlParams.get('animate');
    if (animateParam === 'left') {
        const authContainer = document.querySelector('.auth-container');
        if (authContainer) {
            authContainer.classList.add('slide-in-left');
        }
        history.replaceState({}, document.title, window.location.pathname);
    }

    // Enhanced form validation
    function validateLoginForm() {
        let isValid = true;
        
        clearError('loginGeneralError');
        
        const username = usernameInput?.value.trim();
        const password = passwordInput?.value;
        
        if (!username) {
            displayError('loginGeneralError', 'Username is required.');
            usernameInput?.focus();
            isValid = false;
        } else if (username.length < 3) {
            displayError('loginGeneralError', 'Username must be at least 3 characters.');
            usernameInput?.focus();
            isValid = false;
        }
        
        if (!password) {
            displayError('loginGeneralError', 'Password is required.');
            if (isValid) passwordInput?.focus(); 
            isValid = false;
        } else if (password.length < 6) {
            displayError('loginGeneralError', 'Password must be at least 6 characters.');
            if (isValid) passwordInput?.focus();
            isValid = false;
        }
        
        return isValid;
    }

    // Real-time validation
    usernameInput?.addEventListener('input', () => {
        if (usernameInput.value.trim().length >= 3) {
            clearError('loginGeneralError');
        }
    });

    passwordInput?.addEventListener('input', () => {
        if (passwordInput.value.length >= 6) {
            clearError('loginGeneralError');
        }
    });

    // Enhanced form submission
    if (loginForm) {
        loginForm.addEventListener('submit', async (event) => {
            event.preventDefault();

            clearError('loginGeneralError');
            clearError('loginSuccess');

            if (!validateLoginForm()) {
                return;
            }

            const username = usernameInput.value.trim();
            const password = passwordInput.value;

            try {
                toggleSubmitButton(true);
                
                const response = await loginUser(username, password);
                console.log("Login API response:", response);

                if (response.success && response.userId) {
                    const userToStore = {
                        userId: response.userId,
                        username: response.username,
                        email: response.email,
                        phone: response.phone,
                        userRole: response.userRole
                    };

                    const storageKey = userToStore.userRole === 'admin' ? 'loggedInAs_admin' : 'loggedInAs_user';
                    localStorage.setItem(storageKey, JSON.stringify(userToStore));

                    await logUsageActivity({
                    action: 'login',
                    language: null,
                    details: { 
                     login_method: 'username_password',
                     user_role: userToStore.userRole 
                    }
                    });
                    showCustomAlert("Login successful! Redirecting...", 'success');
                    displaySuccess('loginSuccess', 'Login successful! Redirecting...');

                    const redirectTo = urlParams.get('redirect') ||
                        (userToStore.userRole === 'admin' ? '/admin.html' : '/GrammarChecker1.html');

                    setTimeout(() => {
                        const authContainer = document.querySelector('.auth-container');
                        if (authContainer) {
                            authContainer.style.transform = 'translateY(-20px)';
                            authContainer.style.opacity = '0';
                            authContainer.style.transition = 'all 0.3s ease-out';
                        }
                    }, 1000);

                    setTimeout(() => {
                        window.location.href = redirectTo;
                    }, 1500);
                } else {
                    const errorMessage = response.error || 'Login failed. Invalid credentials or missing user data from server.';
                    displayError('loginGeneralError', errorMessage);
                    showCustomAlert(errorMessage, 'error');
                }

            } catch (error) {
                console.error('Error during login API call:', error);
                const errorMsg = "Network error or server unavailable. Please try again later.";
                showCustomAlert(errorMsg, 'error');
                displayError('loginGeneralError', errorMsg);
            } finally {
                toggleSubmitButton(false);
            }
        });
    }

    document.querySelectorAll('.social-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const provider = btn.classList.contains('social-btn-google') ? 'Google' : 'Facebook';
            showCustomAlert(`${provider} login is not implemented yet.`, 'info');
        });
    });

    const switchFormLinks = document.querySelectorAll('.switch-form-link');
    switchFormLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const href = link.getAttribute('href');
            
            if (href) {
                const authContainer = document.querySelector('.auth-container');
                if (authContainer) {
                    authContainer.style.transform = 'translateX(100px)';
                    authContainer.style.opacity = '0';
                    authContainer.style.transition = 'all 0.3s ease-out';
                }
                
                setTimeout(() => {
                    window.location.href = href;
                }, 300);
            }
        });
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.activeElement?.blur();
            clearError('loginGeneralError');
        }
        
        if (e.key === 'Enter' && e.target.tagName !== 'BUTTON') {
            const submitBtn = document.querySelector('.submit-btn');
            if (submitBtn && !submitBtn.disabled) {
                submitBtn.click();
            }
        }
    });

    setTimeout(() => {
        if (!usernameInput?.value) {
            usernameInput?.focus();
        } else if (!passwordInput?.value) {
            passwordInput?.focus();
        }
    }, 100);
});
```

### frontend\public\js\notifications.js
```js
// frontend/public/js/notifications.js
class NotificationManager {
    constructor() {
        this.notifications = [];
        this.unreadCount = 0;
        this.userId = null;
        this.userRole = null;
        
        // DOM elements
        this.notificationIcon = document.querySelector('.notification-icon');
        this.notificationDropdown = document.getElementById('notificationDropdown');
        this.notificationList = document.getElementById('notificationList');
        this.seeAllBtn = document.getElementById('seeAllBtn');
        
        // Create badge element
        this.createNotificationBadge();
        
        // Bind events
        this.bindEvents();
        
        console.log('📱 NotificationManager initialized');
    }

    createNotificationBadge() {
        this.badge = document.createElement('span');
        this.badge.className = 'notification-badge hidden';
        this.badge.id = 'notificationBadge';
        this.notificationIcon.appendChild(this.badge);
        
        const style = document.createElement('style');
        style.textContent = `
            .notification-icon {
                position: relative;
                cursor: pointer;
                padding: 10px;
                border-radius: 50%;
                transition: background-color 0.3s;
            }
            
            .notification-icon:hover {
                background-color: rgba(0, 0, 0, 0.1);
            }
            
            .notification-badge {
                position: absolute;
                top: 5px;
                right: 5px;
                background-color: #ff4444;
                color: white;
                border-radius: 50%;
                width: 18px;
                height: 18px;
                font-size: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                animation: pulse 2s infinite;
            }
            
            .notification-badge.hidden {
                display: none !important;
            }
            
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            
            .notification-dropdown {
                position: absolute;
                top: 100%;
                right: 0;
                width: 350px;
                max-height: 400px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                overflow: hidden;
            }
            
            .notification-dropdown.hidden {
                display: none;
            }
            
            .notification-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                border-bottom: 1px solid #eee;
                background-color: #f8f9fa;
            }
            
            .notification-header h4 {
                margin: 0;
                font-size: 16px;
                color: #333;
            }
            
            .notification-list {
                list-style: none;
                margin: 0;
                padding: 0;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .notification-item {
                padding: 12px 15px;
                border-bottom: 1px solid #eee;
                cursor: pointer;
                transition: background-color 0.2s;
                position: relative;
            }
            
            .notification-item:hover {
                background-color: #f8f9fa;
            }
            
            .notification-item.unread {
                background-color: #e3f2fd;
                border-left: 3px solid #2196f3;
            }
            
            .notification-item.unread::before {
                content: '';
                position: absolute;
                top: 15px;
                right: 15px;
                width: 8px;
                height: 8px;
                background-color: #2196f3;
                border-radius: 50%;
            }
            
            .notification-title {
                font-weight: 600;
                font-size: 14px;
                color: #333;
                margin-bottom: 4px;
            }
            
            .notification-message {
                font-size: 13px;
                color: #666;
                margin-bottom: 6px;
                line-height: 1.4;
            }
            
            .notification-time {
                font-size: 11px;
                color: #999;
            }
            
            .notification-actions {
                padding: 10px 15px;
                border-top: 1px solid #eee;
                background-color: #f8f9fa;
                display: flex;
                gap: 10px;
            }
            
            .btn-link {
                background: none;
                border: none;
                color: #007bff;
                cursor: pointer;
                font-size: 12px;
                text-decoration: underline;
            }
            
            .btn-link:hover {
                color: #0056b3;
            }
            
            .no-notifications {
                padding: 30px;
                text-align: center;
                color: #666;
            }
            
            .no-notifications i {
                font-size: 24px;
                margin-bottom: 10px;
                color: #ccc;
            }
        `;
        document.head.appendChild(style);
    }

    bindEvents() {
        this.notificationIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown();
        });
        
        document.addEventListener('click', (e) => {
            if (!this.notificationIcon.contains(e.target) && 
                !this.notificationDropdown.contains(e.target)) {
                this.closeDropdown();
            }
        });
        
        this.seeAllBtn.addEventListener('click', () => {
              this.markAllAsRead();
        });
    }

    async init(userId, userRole) {
        this.userId = userId;
        this.userRole = userRole;
        
        console.log(`📱 Initializing notifications for user ${userId}`);
        
        await this.loadNotifications();
        
        this.startPeriodicRefresh();
    }

    async loadNotifications() {
        if (!this.userId) {
            console.warn('⚠️ No user ID available for loading notifications');
            return;
        }

        try {
            const response = await fetch(`/api/notifications/user/${this.userId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                this.notifications = data.notifications;
                this.unreadCount = data.meta.unreadCount;
                
                console.log(`📱 Loaded ${this.notifications.length} notifications, ${this.unreadCount} unread`);
                
                this.updateUI();
            } else {
                console.error('❌ Failed to load notifications:', data.error);
            }

        } catch (error) {
            console.error('❌ Error loading notifications:', error);
        }
    }

    updateUI() {
        this.updateBadge();
        this.renderNotifications();
    }

    updateBadge() {
        if (this.unreadCount > 0) {
            this.badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount.toString();
            this.badge.classList.remove('hidden');
        } else {
            this.badge.classList.add('hidden');
        }
    }

    renderNotifications() {
        if (this.notifications.length === 0) {
            this.notificationList.innerHTML = `
                <li class="no-notifications">
                    <i class="fas fa-bell-slash"></i>
                    <p>No notifications yet</p>
                </li>
            `;
            return;
        }

        this.notificationList.innerHTML = this.notifications
            .slice(0, 10) 
            .map(notification => this.createNotificationHTML(notification))
            .join('');

        const existingActions = document.querySelector('.notification-actions');
        if (existingActions) {
        existingActions.remove();
        }

        this.bindNotificationItemEvents();
    }
    createNotificationHTML(notification) {
        const isUnread = !notification.IsRead;
        const timeAgo = this.getTimeAgo(new Date(notification.CreatedAt));
        
        return `
            <li class="notification-item ${isUnread ? 'unread' : ''}" 
                data-notification-id="${notification.NotificationID}">
                <div class="notification-title">${this.escapeHtml(notification.Title)}</div>
                <div class="notification-message">${this.escapeHtml(notification.Message)}</div>
                <div class="notification-time">${timeAgo}</div>
            </li>
        `;
    }

    bindNotificationItemEvents() {
        const items = this.notificationList.querySelectorAll('.notification-item');
        items.forEach(item => {
            item.addEventListener('click', () => {
                const notificationId = item.dataset.notificationId;
                this.markAsRead(notificationId);
            });
        });
    }

    async markAsRead(notificationId) {
        try {
            const response = await fetch(`/api/notifications/${notificationId}/read`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                const notification = this.notifications.find(n => n.NotificationID == notificationId);
                if (notification && !notification.IsRead) {
                    notification.IsRead = true;
                    notification.ReadAt = new Date().toISOString();
                    this.unreadCount = Math.max(0, this.unreadCount - 1);
                    
                    console.log(`✅ Marked notification ${notificationId} as read`);
                    this.updateUI();
                }
            }

        } catch (error) {
            console.error('❌ Error marking notification as read:', error);
        }
    }

    async markAllAsRead() {
        if (this.unreadCount === 0) return;

        try {
            const response = await fetch(`/api/notifications/user/${this.userId}/mark-all-read`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                this.notifications.forEach(notification => {
                    if (!notification.IsRead) {
                        notification.IsRead = true;
                        notification.ReadAt = new Date().toISOString();
                    }
                });
                
                this.unreadCount = 0;
                
                console.log(`✅ Marked all notifications as read`);
                this.updateUI();
                this.closeDropdown();
                
                this.showToast('All notifications marked as read', 'success');
            }

        } catch (error) {
            console.error('❌ Error marking all notifications as read:', error);
            this.showToast('Error marking notifications as read', 'error');
        }
    }

    toggleDropdown() {
        const isHidden = this.notificationDropdown.classList.contains('hidden');
        
        if (isHidden) {
            this.openDropdown();
        } else {
            this.closeDropdown();
        }
    }

    openDropdown() {
        this.notificationDropdown.classList.remove('hidden');
        
        this.loadNotifications();
    }

    closeDropdown() {
        this.notificationDropdown.classList.add('hidden');
    }

    startPeriodicRefresh() {
        setInterval(() => {
            if (this.userId) {
                this.loadNotifications();
            }
        }, 30000);
    }

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `notification-toast notification-toast-${type}`;
        toast.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'exclamation' : 'info'}-circle"></i>
            <span>${message}</span>
        `;
        
        const style = document.createElement('style');
        style.textContent = `
            .notification-toast {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 16px;
                border-radius: 6px;
                color: white;
                font-size: 14px;
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 8px;
                animation: slideInRight 0.3s ease-out;
            }
            
            .notification-toast-success { background-color: #28a745; }
            .notification-toast-error { background-color: #dc3545; }
            .notification-toast-info { background-color: #17a2b8; }
            
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        `;
        
        if (!document.querySelector('style[data-toast-styles]')) {
            style.setAttribute('data-toast-styles', 'true');
            document.head.appendChild(style);
        }
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 3000);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    getTimeAgo(date) {
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        if (diffInSeconds < 60) return 'Just now';
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
        if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
        
        return date.toLocaleDateString();
    }
}

window.notificationManager = new NotificationManager();
export { NotificationManager };
```

### frontend\public\js\sectionManager.js
```js
// js/sectionManager.js
class SectionManager {
  constructor() {
    this.currentSection = 'grammar';
    this.init();
  }
  
  init() {
    this.setupNavigation();
    console.log('Section Manager initialized');
  }
  
  setupNavigation() {
    // Add click handlers to nav links
    document.querySelectorAll('.nav-link').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const section = link.dataset.section;
        this.switchTo(section);
      });
    });
  }
  
  switchTo(sectionName) {
    console.log(`Switching from ${this.currentSection} to ${sectionName}`);
    
    // Update navigation
    this.updateNavigation(sectionName);
    
    // Hide current section
    this.hideSection(this.currentSection);
    
    // Show new section
    setTimeout(() => {
      this.showSection(sectionName);
      this.currentSection = sectionName;
    }, 150);
  }
  
  updateNavigation(activeSection) {
    // Remove active from all nav links
    document.querySelectorAll('.nav-link').forEach(link => {
      link.classList.remove('active');
    });
    
    // Add active to clicked nav link
    const activeLink = document.querySelector(`[data-section="${activeSection}"]`);
    if (activeLink) {
      activeLink.classList.add('active');
    }
  }
  
  hideSection(sectionName) {
    const section = document.getElementById(`${sectionName}-section`);
    if (section) {
      section.classList.remove('active');
      section.classList.add('hidden');
    }
  }
  
  showSection(sectionName) {
    const section = document.getElementById(`${sectionName}-section`);
    if (section) {
      section.classList.remove('hidden');
      section.classList.add('active');
    }
  }
}

// Export for use in main JS file
export { SectionManager };
```

### frontend\public\js\utils.js
```js
// frontend/public/js/utils.js

/**
 * Displays a custom alert message on the screen.
 * @param {string} message 
 * @param {string} type 
 * @param {number} duration 
 */
export function showCustomAlert(message, type = 'info', duration = 3000) {
    const existingAlert = document.getElementById('customAlert');
    if (existingAlert) {
        existingAlert.remove();
    }

    const alertDiv = document.createElement('div');
    alertDiv.id = 'customAlert';
    alertDiv.textContent = message;

    alertDiv.style.position = 'fixed';
    alertDiv.style.top = '20px';
    alertDiv.style.left = '50%';
    alertDiv.style.transform = 'translateX(-50%)';
    alertDiv.style.padding = '15px 30px';
    alertDiv.style.borderRadius = '8px';
    alertDiv.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
    alertDiv.style.zIndex = '9999';
    alertDiv.style.fontSize = '1.1em';
    alertDiv.style.fontWeight = 'bold';
    alertDiv.style.textAlign = 'center';
    alertDiv.style.opacity = '0';
    alertDiv.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';

    // Type-specific styling
    switch (type) {
        case 'success':
            alertDiv.style.backgroundColor = '#d4edda';
            alertDiv.style.color = '#155724';
            alertDiv.style.border = '1px solid #c3e6cb';
            break;
        case 'error':
            alertDiv.style.backgroundColor = '#f8d7da';
            alertDiv.style.color = '#721c24';
            alertDiv.style.border = '1px solid #f5c6cb';
            break;
        case 'info':
        default:
            alertDiv.style.backgroundColor = '#d1ecf1';
            alertDiv.style.color = '#0c5460';
            alertDiv.style.border = '1px solid #bee5eb';
            break;
    }

    document.body.appendChild(alertDiv);

    setTimeout(() => {
        alertDiv.style.opacity = '1';
        alertDiv.style.transform = 'translateX(-50%) translateY(0)';
    }, 10); 

    // Animate out and remove
    setTimeout(() => {
        alertDiv.style.opacity = '0';
        alertDiv.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => {
            alertDiv.remove();
        }, 500); 
    }, duration);
}


/**
 * Toggles visibility of a password input field when eye icon is clicked.
 * @param {HTMLElement} iconElement 
 */
export function togglePassword(iconElement) {
    const wrapper = iconElement.closest('.password-wrapper, .input-group');
    if (!wrapper) return;

    const input = wrapper.querySelector('input[type="password"], input[type="text"]');
    if (!input) return;

    const isPassword = input.getAttribute('type') === 'password';
    input.setAttribute('type', isPassword ? 'text' : 'password');

    iconElement.classList.toggle('fa-eye', !isPassword);
    iconElement.classList.toggle('fa-eye-slash', isPassword);
}

```

### frontend\public\js\admin\admin-api.js
```js
/**
 * admin-api.js
 * API functions for user management
 */

'use strict';

// API management functions
const AdminAPI = {
  async loadUsers() {
    showLoading(true);

    try {
      log('Starting to load users...');
      let response;
      let usersData = [];

      // Try main API endpoint
      try {
        response = await fetch(`${CONFIG.API_BASE_URL}/admin/users`);
        if (response.ok) {
          const data = await response.json();
          usersData = data.users || data.data || data;
        }
      } catch (err) {
        log('Admin endpoint failed, trying fallback', err, 'warn');
      }

      // Try fallback endpoint if main failed
      if (!usersData || usersData.length === 0) {
        try {
          const res = await fetch('/api/admin/users/mock');
          if (res.ok) {
            const mockData = await res.json();
            usersData = mockData.users || mockData.data || mockData;
            log('Loaded data from /api/admin/users/mock', { count: usersData.length });
            updateConnectionStatus('offline');
            showToast('Warning', 'Using mock data from server - database unavailable', 'warning', 4000);
          }
        } catch (err) {
          log('Mock endpoint also failed', err, 'error');
        }
      }

      // Validate data
      if (!usersData || usersData.length === 0) {
        showError('Failed to load users. Please check your database connection.');
        updateConnectionStatus('offline');
        return;
      }

      // Normalize data
      const normalizedUsers = this.normalizeUsersData(usersData);

      // Update state
      AdminState.setUsers(normalizedUsers);
      updateStatistics();
      renderUserTable();
      updateConnectionStatus('online');
      
      showToast('Success', `Loaded ${normalizedUsers.length} users`, 'success', 2000);
      log('Users loaded successfully', { count: normalizedUsers.length });
      
    } catch (err) {
      log('Error loading users', err, 'error');
      showError('Failed to load users. Please check your database connection.');
      updateConnectionStatus('offline');
    } finally {
      showLoading(false);
    }
  },

  // Normalize user data from different API formats
  normalizeUsersData(usersData) {
    console.log('=== DEBUG normalizeUsersData ===');
    console.log('Raw usersData:', usersData);
    console.log('First user UpdatedAt:', usersData[0]?.UpdatedAt);
    
    return usersData.map((user, idx) => ({
        id: Number(user.UserID ?? user.id ?? (idx + 1)),
        username: user.Username || user.username || `user${idx + 1}`,
        fullName: user.FullName || user.fullName || user.name || 'Unknown User',
        email: user.Email || user.email || `user${idx + 1}@example.com`,
        phone: user.Phone || user.phone || '',
        role: (user.UserRole || user.role || 'user').toLowerCase(),
        accountType: user.AccountType || user.accountType || (user.isPremium ? 'plus' : 'free'),
        status: user.UserStatus || user.status || (user.isActive ? 'active' : 'inactive'),
        createdAt: user.CreatedAt || user.createdAt || new Date().toISOString(),
        updatedAt: user.UpdatedAt || user.updatedAt || null,
        
        _debugUpdatedAt: user.UpdatedAt,
        _debugupdatedAt: user.updatedAt
    }));
},

  // Create new user
  async createUser(userData) {
    try {
      log('Creating new user', userData);
      
      let response;
      try {
        response = await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/register`, {
          method: 'POST',
          body: JSON.stringify(userData)
        });
      } catch (error) {
        log('Authenticated create failed, trying alternative', error, 'warn');
        response = await makeAPICall('/users', 'POST', userData);
      }
      
      // Format the new user data
      const newUser = response.user || response.data || response;
      const formattedUser = {
        id: newUser.UserID || newUser.id || Date.now(),
        username: newUser.Username || newUser.username || userData.username,
        fullName: newUser.FullName || newUser.fullName || userData.fullName,
        email: newUser.Email || newUser.email || userData.email,
        phone: newUser.Phone || newUser.phone || userData.phone || '',
        role: newUser.UserRole || newUser.role || userData.role || 'user',
        accountType: newUser.AccountType || newUser.accountType || userData.accountType || 'free',
        status: newUser.UserStatus || newUser.status || userData.status || 'active',
        createdAt: newUser.CreatedAt || newUser.createdAt || new Date().toISOString()
      };
      
      // Add to state
      AdminState.addUser(formattedUser);
      updateStatistics();
      renderUserTable();
      
      showToast('Success', `User "${userData.username}" created successfully`, 'success');
      log('User created successfully', formattedUser);
      
      return formattedUser;
    } catch (error) {
      log('Error creating user', error, 'error');
      throw new Error('Failed to create user: ' + error.message);
    }
  },

  // Update existing user
async updateUser(userId, userData) {
  try {
    log('Starting user update', { userId, userData });
    
    const currentAdmin = getUserData();
    if (!currentAdmin || currentAdmin.userRole !== 'admin') {
      throw new Error('Admin access required');
    }
    
    const currentUserData = AdminState.getUserById(userId);
    if (!currentUserData) {
      throw new Error('User not found in local data');
    }
    
    // Create detailed update payload
    const updatePayload = {
      username: userData.username || currentUserData.username,
      email: userData.email || currentUserData.email,
      phone: userData.phone !== undefined ? userData.phone : (currentUserData.phone || ''),
      fullName: userData.fullName || currentUserData.fullName
    };
    
    if (userData.hasOwnProperty('status')) {
      updatePayload.status = userData.status;
    } else {
      updatePayload.status = currentUserData.status;
    }
    
    if (userData.hasOwnProperty('accountType')) {
      updatePayload.accountType = userData.accountType;
    } else {
      updatePayload.accountType = currentUserData.accountType;
    }
    
    if (userData.hasOwnProperty('role')) {
      updatePayload.role = userData.role;
    } else {
      updatePayload.role = currentUserData.role;
    }
    
    // Add password only if provided
    if (userData.password && userData.password.trim()) {
      updatePayload.password = userData.password.trim();
    }
    
    log('Final update payload', updatePayload);
    
    let response;
    try {
      response = await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/admin/update/${userId}`, {
        method: 'PUT',
        body: JSON.stringify(updatePayload)
      });
    } catch (error) {
      log('Authenticated update failed, trying alternative', error, 'warn');
      response = await makeAPICall(`/users/${userId}`, 'PUT', updatePayload);
    }

    // Log response để debug
    log('API response received', response);
    
    if (response && response.user) {
      const apiUser = response.user;
      log('API returned user data', apiUser);
      
      const updatedUser = {
        id: Number(userId),
        username: apiUser.Username || apiUser.username,
        fullName: apiUser.FullName || apiUser.fullName,
        email: apiUser.Email || apiUser.email,
        phone: apiUser.Phone || apiUser.phone || '',
        role: (apiUser.UserRole || apiUser.role || 'user').toLowerCase(),
        accountType: apiUser.AccountType || apiUser.accountType || 'free',
        status: apiUser.UserStatus || apiUser.status || 'active',
        createdAt: apiUser.CreatedAt || apiUser.createdAt,
        updatedAt: apiUser.UpdatedAt || apiUser.updatedAt // Get from database
      };
      
      log('Using UpdatedAt from API response', updatedUser.updatedAt);
      
      // Update state and UI immediately
      AdminState.updateUser(userId, updatedUser);
      updateStatistics();
      renderUserTable();
      
      const changes = [];
      if (currentUserData.status !== updatedUser.status) {
        changes.push(`Status: ${currentUserData.status} → ${updatedUser.status}`);
      }
      if (currentUserData.accountType !== updatedUser.accountType) {
        changes.push(`Account Type: ${currentUserData.accountType} → ${updatedUser.accountType}`);
      }
      if (currentUserData.role !== updatedUser.role) {
        changes.push(`Role: ${currentUserData.role} → ${updatedUser.role}`);
      }
      
      let message = `User "${updatedUser.username}" updated successfully`;
      if (changes.length > 0) {
        message += `\nChanges: ${changes.join(', ')}`;
      }
      
      showToast('Success', message, 'success', 4000);
      log('User update completed successfully', { updatedUser, changes });
      
      return updatedUser;
      
    } else {
      const updatedUser = {
        id: Number(userId),
        username: updatePayload.username,
        fullName: updatePayload.fullName,
        email: updatePayload.email,
        phone: updatePayload.phone,
        role: updatePayload.role,
        accountType: updatePayload.accountType,
        status: updatePayload.status,
        createdAt: currentUserData.createdAt,
        updatedAt: new Date().toISOString() 
      };
      
      // Update state and UI immediately
      AdminState.updateUser(userId, updatedUser);
      updateStatistics();
      renderUserTable();
      
      const changes = [];
      if (currentUserData.status !== updatedUser.status) {
        changes.push(`Status: ${currentUserData.status} → ${updatedUser.status}`);
      }
      if (currentUserData.accountType !== updatedUser.accountType) {
        changes.push(`Account Type: ${currentUserData.accountType} → ${updatedUser.accountType}`);
      }
      if (currentUserData.role !== updatedUser.role) {
        changes.push(`Role: ${currentUserData.role} → ${updatedUser.role}`);
      }
      
      let message = `User "${updatedUser.username}" updated successfully`;
      if (changes.length > 0) {
        message += `\nChanges: ${changes.join(', ')}`;
      }
      
      showToast('Success', message, 'success', 4000);
      log('User update completed successfully (fallback mode)', { updatedUser, changes });
      
      return updatedUser;
    }
    
  } catch (error) {
    log('Error updating user', error, 'error');
    throw new Error('Failed to update user: ' + error.message);
  }
},

  // Delete user
  async deleteUser(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    if (!confirm(`Are you sure you want to delete user "${user.username}"?\n\nThis action cannot be undone.`)) {
      return;
    }
    
    showLoading(true);
    
    try {
      log('Deleting user', { userId, user });
      
      try {
        await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/admin/delete/${userId}`, {
          method: 'DELETE'
        });
      } catch (error) {
        log('Authenticated delete failed, trying alternative', error, 'warn');
        await makeAPICall(`/users/${userId}`, 'DELETE');
      }
      
      // Remove user from state and update UI
      AdminState.removeUser(userId);
      updateStatistics();
      renderUserTable();
      
      showToast('Success', `User "${user.username}" deleted successfully`, 'success');
      log('User deleted successfully', { userId, username: user.username });
      
    } catch (error) {
      log('Delete error', error, 'error');
      showToast('Error', 'Failed to delete user: ' + error.message, 'error');
    } finally {
      showLoading(false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
async function loadUsers() {
  return AdminAPI.loadUsers();
}

async function createUser(userData) {
  return AdminAPI.createUser(userData);
}

async function updateUser(userId, userData) {
  return AdminAPI.updateUser(userId, userData);
}

async function deleteUser(userId) {
  return AdminAPI.deleteUser(userId);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminAPI = AdminAPI;
  window.loadUsers = loadUsers;
  window.createUser = createUser;
  window.updateUser = updateUser;
  window.deleteUser = deleteUser;
}
```

### frontend\public\js\admin\admin-auth.js
```js
/**
 * admin-auth.js
 * Authentication and authorization functions
 */

'use strict';

// Authentication management
const AdminAuth = {
  validateAuthentication() {
    const userData = getUserData();
    
    if (!userData) {
      log('No authentication data found', null, 'warn');
      
      if (isAdminPanel()) {
        showToast('Admin Access Required', 'Please login with admin credentials to access this panel', 'error', 3000);
      } else {
        showToast('Authentication Required', 'Please login to access this page', 'error', 3000);
      }
      
      setTimeout(() => {
        window.location.href = 'login.html';
      }, 3000);
      return false;
    }
    
    if (isAdminPanel() && userData.userRole.toLowerCase() !== 'admin') {
      log('Non-admin user trying to access admin panel', userData, 'error');
      showToast('Access Denied', 'Admin privileges required for this panel', 'error', 3000);
      setTimeout(() => {
        window.location.href = 'login.html';
      }, 3000);
      return false;
    }
    
    log('Authentication validated successfully', { 
      userRole: userData.userRole, 
      username: userData.username,
      isAdminPanel: isAdminPanel()
    });
    return true;
  },

  // Make authenticated API request
  async makeAuthenticatedRequest(url, options = {}) {
    const userData = getUserData();
    
    if (!userData) {
      log('No user data available for authentication', null, 'error');
      throw new Error('Authentication required. Please login again.');
    }
    
    if (isAdminPanel() && userData.userRole !== 'admin') {
      log('Non-admin user trying to access admin functionality', userData, 'error');
      throw new Error('Admin privileges required for this operation.');
    }
    
    const defaultHeaders = {
      'Content-Type': 'application/json',
      'x-user-role': userData.userRole,
      'x-user-id': userData.userId || userData.id,
      'x-username': userData.username
    };
    
    // Add admin token if available
    const adminToken = localStorage.getItem('admin_token');
    if (adminToken) {
      defaultHeaders['Authorization'] = `Bearer ${adminToken}`;
    }
    
    const requestOptions = {
      ...options,
      headers: {
        ...defaultHeaders,
        ...options.headers
      }
    };
    
    log(`Making authenticated API request to: ${url}`, { 
      method: options.method || 'GET', 
      userRole: userData.userRole,
      storageKey: getStorageKey(userData.userRole)
    });
    
    try {
      const response = await fetch(url, requestOptions);
      const data = await response.json();
      
      log(`API response received`, { status: response.status, ok: response.ok });
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error(data.error || 'Access denied. Insufficient privileges.');
        }
        if (response.status === 401) {
          // Clear appropriate storage
          const storageKey = getStorageKey(userData.userRole);
          localStorage.removeItem(storageKey);
          localStorage.removeItem('admin_token');
          throw new Error('Authentication expired. Please login again.');
        }
        throw new Error(data.error || `API request failed with status ${response.status}`);
      }
      
      return data;
    } catch (networkError) {
      log('Network error in authenticated request', networkError, 'error');
      throw new Error(`Network error: ${networkError.message}`);
    }
  },

  // Login user with role-based storage
  loginUser(loginResponse) {
    try {
      const userData = {
        userId: loginResponse.userId || loginResponse.user?.id || loginResponse.id,
        username: loginResponse.username || loginResponse.user?.username,
        userRole: loginResponse.userRole || loginResponse.user?.role || loginResponse.role,
        email: loginResponse.email || loginResponse.user?.email,
        phone: loginResponse.phone || loginResponse.user?.phone || '',
        fullName: loginResponse.fullName || loginResponse.user?.fullName || loginResponse.name
      };
      
      // Validate required fields
      if (!userData.userId || !userData.username || !userData.userRole) {
        throw new Error('Incomplete login data received');
      }
      
      // Store with appropriate key
      const storedData = setUserData(userData);
      
      log(`User logged in with role: ${userData.userRole}`, storedData);
      
      // Redirect based on role
      if (userData.userRole === 'admin') {
        window.location.href = 'admin.html';
      } else {
        window.location.href = 'dashboard.html';
      }
      
      return storedData;
    } catch (error) {
      log('Login failed', error, 'error');
      throw error;
    }
  },

  // Logout with proper cleanup
  logout() {
    const userData = getUserData();
    const userRole = userData?.userRole || 'unknown';
    
    if (confirm(`Are you sure you want to logout?`)) {
      log(`${userRole} user logging out`);
      
      // Clear appropriate storage
      if (userData) {
        const storageKey = getStorageKey(userData.userRole);
        localStorage.removeItem(storageKey);
      }
      
      // Clear tokens
      localStorage.removeItem('admin_token');
      
      // Clear any other session data
      if (AppState?.autoRefreshTimer) {
        clearInterval(AppState.autoRefreshTimer);
      }
      
      showToast('Logging out', `${userRole} session ended. Goodbye!`, 'info', 1000);
      
      setTimeout(() => {
        window.location.href = 'login.html';
      }, 1000);
    }
  }
};

// Legacy API call function for backward compatibility
async function makeAPICall(endpoint, method = 'GET', data = null) {
  const config = {
    method,
    headers: {
      'Content-Type': 'application/json',
    }
  };
  
  // Add authentication headers
  const userData = getUserData();
  if (userData) {
    config.headers['x-user-role'] = userData.userRole;
  }
  
  // Add admin token if available (for backward compatibility)
  const token = localStorage.getItem('admin_token');
  if (token) {
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  
  if (data) {
    config.body = JSON.stringify(data);
  }
  
  try {
    log(`Making API call to: ${CONFIG.API_BASE_URL}${endpoint}`, { method, data });
    const response = await fetch(`${CONFIG.API_BASE_URL}${endpoint}`, config);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const responseData = await response.json();
    log(`API call successful`, responseData);
    return responseData;
  } catch (error) {
    log('API call failed', error, 'error');
    throw error;
  }
}

// Legacy wrapper functions for backward compatibility
function validateAuthentication() {
  return AdminAuth.validateAuthentication();
}

async function makeAuthenticatedRequest(url, options = {}) {
  return AdminAuth.makeAuthenticatedRequest(url, options);
}

function handleLogout() {
  AdminAuth.logout();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminAuth = AdminAuth;
  window.validateAuthentication = validateAuthentication;
  window.makeAuthenticatedRequest = makeAuthenticatedRequest;
  window.makeAPICall = makeAPICall;
  window.handleLogout = handleLogout;
  window.loginUser = AdminAuth.loginUser;
}
```

### frontend\public\js\admin\admin-config.js
```js
/**
 * admin-config.js
 * Configuration and constants for admin panel
 */

'use strict';

const CONFIG = {
  API_BASE_URL: window.location.origin + '/api',
  ADMIN_STORAGE_KEY: 'loggedInAs_admin',
  USER_STORAGE_KEY: 'loggedInAs_user', 
  LEGACY_STORAGE_KEY: 'loggedInAs',
  DEBUG_MODE: false,
  AUTO_REFRESH_INTERVAL: 3000000, 
  NOTIFICATION_DURATION: 5000,
  SEARCH_DEBOUNCE_DELAY: 300
};

// Export for global access
if (typeof window !== 'undefined') {
  window.AdminConfig = CONFIG;
}
```

### frontend\public\js\admin\admin-debug.js
```js
/**
 * admin-debug.js
 * Debug helpers and development tools
 */

'use strict';

// Debug management functions
const AdminDebug = {
  debugAuth() {
    console.log('=== Authentication Debug ===');
    console.log('Admin Storage Key:', CONFIG.ADMIN_STORAGE_KEY);
    console.log('User Storage Key:', CONFIG.USER_STORAGE_KEY);
    console.log('Legacy Storage Key:', CONFIG.LEGACY_STORAGE_KEY);
    console.log('Raw Admin Storage:', localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY));
    console.log('Raw User Storage:', localStorage.getItem(CONFIG.USER_STORAGE_KEY));
    console.log('Raw Legacy Storage:', localStorage.getItem(CONFIG.LEGACY_STORAGE_KEY));
    console.log('Admin Token:', localStorage.getItem('admin_token'));
    console.log('Parsed User Data:', getUserData());
    console.log('Is Admin Panel:', isAdminPanel());
    console.log('==============================');
  },

  // Debug storage state
  debugStorage() {
    console.log('=== Storage Debug ===');
    console.log('Is Admin Panel:', isAdminPanel());
    console.log('Admin Storage:', localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY));
    console.log('User Storage:', localStorage.getItem(CONFIG.USER_STORAGE_KEY));
    console.log('Legacy Storage:', localStorage.getItem(CONFIG.LEGACY_STORAGE_KEY));
    console.log('Current User:', getUserData());
    console.log('Storage Key Function Test:', getStorageKey('admin'), getStorageKey('user'));
    console.log('====================');
  },

  // Debug form state
  debugForm() {
    console.log('=== Form Debug ===');
    console.log('Edit Mode:', AppState.isEditMode);
    console.log('Editing User ID:', AppState.currentEditingUserId);
    
    if (AppState.currentEditingUserId) {
      const user = AdminState.getUserById(AppState.currentEditingUserId);
      console.log('User Being Edited:', user);
    }
    
    console.log('Form Elements:', {
      username: elements.username?.value,
      email: elements.email?.value,
      fullName: elements.fullName?.value,
      isActive: elements.isActive?.checked,
      isPlusAccount: elements.isPlusAccount?.checked,
      isAdmin: elements.isAdmin?.checked
    });
    
    try {
      console.log('Form Data:', getFormData());
    } catch (error) {
      console.log('Form Data Error:', error);
    }
    
    console.log('==================');
  },

  // Debug app state
  debugAppState() {
    console.log('=== App State Debug ===');
    console.log('All Users Count:', AppState.allUsers.length);
    console.log('Filtered Users Count:', AppState.filteredUsers.length);
    console.log('Edit Mode:', AppState.isEditMode);
    console.log('Current Editing User ID:', AppState.currentEditingUserId);
    console.log('Loading State:', AppState.isLoading);
    console.log('Debug Mode:', AppState.isDebugMode);
    console.log('Search Term:', elements.searchInput?.value);
    
    if (AppState.allUsers.length > 0) {
      console.log('First User Sample:', AppState.allUsers[0]);
      
      const stats = {
        total: AppState.allUsers.length,
        active: AppState.allUsers.filter(u => u.status === 'active').length,
        inactive: AppState.allUsers.filter(u => u.status === 'inactive').length,
        plus: AppState.allUsers.filter(u => u.accountType === 'plus').length,
        free: AppState.allUsers.filter(u => u.accountType === 'free').length,
        admin: AppState.allUsers.filter(u => u.role === 'admin').length
      };
      console.log('User Statistics:', stats);
    }
    
    console.log('========================');
  },

  // Clear all sessions
  clearAllSessions() {
    localStorage.removeItem(CONFIG.ADMIN_STORAGE_KEY);
    localStorage.removeItem(CONFIG.USER_STORAGE_KEY);
    localStorage.removeItem(CONFIG.LEGACY_STORAGE_KEY);
    localStorage.removeItem('admin_token');
    console.log('All sessions cleared');
    showToast('Debug', 'All sessions cleared', 'info', 2000);
  },

  // Set temporary admin data for testing
  setTempAdminData() {
    const tempAdminData = {
      userId: 999,
      username: 'debug_admin',
      userRole: 'admin',
      email: 'debug@admin.com',
      loginTime: new Date().toISOString()
    };
    
    localStorage.setItem(CONFIG.ADMIN_STORAGE_KEY, JSON.stringify(tempAdminData));
    console.log('Temporary admin data set:', tempAdminData);
    showToast('Debug', 'Temporary admin data set', 'info', 2000);
    return tempAdminData;
  },

  // Test API endpoints
  async testAPIEndpoints() {
    console.log('=== API Endpoints Test ===');
    
    const endpoints = [
      { url: `${CONFIG.API_BASE_URL}/admin/users`, method: 'GET', description: 'Load Users' },
      { url: `${CONFIG.API_BASE_URL}/users/register`, method: 'POST', description: 'Create User' },
      { url: `${CONFIG.API_BASE_URL}/users/admin/update/1`, method: 'PUT', description: 'Update User' },
      { url: `${CONFIG.API_BASE_URL}/users/admin/delete/1`, method: 'DELETE', description: 'Delete User' }
    ];
    
    for (const endpoint of endpoints) {
      try {
        console.log(`Testing ${endpoint.description}...`);
        const response = await fetch(endpoint.url, {
          method: endpoint.method,
          headers: { 'Content-Type': 'application/json' }
        });
        console.log(`${endpoint.description}:`, response.status, response.statusText);
      } catch (error) {
        console.log(`${endpoint.description} Error:`, error.message);
      }
    }
    
    console.log('=============================');
  },

  // Performance monitoring
  startPerformanceMonitoring() {
    const originalFetch = window.fetch;
    let requestCount = 0;
    let totalTime = 0;
    
    window.fetch = function(...args) {
      const startTime = performance.now();
      requestCount++;
      
      console.log(`[API Request #${requestCount}]`, args[0]);
      
      return originalFetch.apply(this, args)
        .then(response => {
          const endTime = performance.now();
          const duration = endTime - startTime;
          totalTime += duration;
          
          console.log(`[API Response #${requestCount}]`, {
            status: response.status,
            duration: `${duration.toFixed(2)}ms`,
            avgDuration: `${(totalTime / requestCount).toFixed(2)}ms`
          });
          
          return response;
        })
        .catch(error => {
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          console.log(`[API Error #${requestCount}]`, {
            error: error.message,
            duration: `${duration.toFixed(2)}ms`
          });
          
          throw error;
        });
    };
    
    console.log('Performance monitoring started');
    showToast('Debug', 'Performance monitoring started', 'info', 2000);
  },

  // Export debug data
  exportDebugData() {
    const debugData = {
      timestamp: new Date().toISOString(),
      appState: {
        allUsers: AppState.allUsers.length,
        filteredUsers: AppState.filteredUsers.length,
        isEditMode: AppState.isEditMode,
        currentEditingUserId: AppState.currentEditingUserId,
        isLoading: AppState.isLoading,
        isDebugMode: AppState.isDebugMode
      },
      storage: {
        adminStorage: localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY),
        userStorage: localStorage.getItem(CONFIG.USER_STORAGE_KEY),
        legacyStorage: localStorage.getItem(CONFIG.LEGACY_STORAGE_KEY),
        adminToken: localStorage.getItem('admin_token')
      },
      config: CONFIG,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    const dataStr = JSON.stringify(debugData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `admin-debug-${new Date().toISOString().slice(0, 19)}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('Debug data exported');
    showToast('Debug', 'Debug data exported to file', 'success', 2000);
  }
};

// Global debug functions for easy access in console
function debugAuth() {
  AdminDebug.debugAuth();
}

function debugStorage() {
  AdminDebug.debugStorage();
}

function debugForm() {
  AdminDebug.debugForm();
}

function debugAppState() {
  AdminDebug.debugAppState();
}

function clearAllSessions() {
  AdminDebug.clearAllSessions();
}

function setTempAdminData() {
  return AdminDebug.setTempAdminData();
}

// Global exports and console helpers
if (typeof window !== 'undefined') {
  window.AdminDebug = AdminDebug;
  window.debugAuth = debugAuth;
  window.debugStorage = debugStorage;
  window.debugForm = debugForm;
  window.debugAppState = debugAppState;
  window.clearAllSessions = clearAllSessions;
  window.setTempAdminData = setTempAdminData;
  
  // Quick debug shortcuts
  window.d = {
    auth: debugAuth,
    storage: debugStorage,
    form: debugForm,
    state: debugAppState,
    clear: clearAllSessions,
    temp: setTempAdminData,
    export: () => AdminDebug.exportDebugData(),
    api: () => AdminDebug.testAPIEndpoints(),
    perf: () => AdminDebug.startPerformanceMonitoring()
  };
  
  console.log('Debug helpers loaded. Use window.d for shortcuts:', window.d);
}
```

### frontend\public\js\admin\admin-events.js
```js
/**
 * admin-events.js
 * Event handlers and listeners
 */

'use strict';

// Event management functions
const AdminEvents = {
  initializeEventListeners() {
    if (elements.logoutBtn) {
      elements.logoutBtn.addEventListener('click', handleLogout);
    }
    
    if (elements.searchInput) {
      elements.searchInput.addEventListener('input', this.handleSearch);
    }
    if (elements.refreshBtn) {
      elements.refreshBtn.addEventListener('click', refreshUsers);
    }
    if (elements.debugBtn) {
      elements.debugBtn.addEventListener('click', toggleDebug);
    }
    
    if (elements.addUserBtn) {
      elements.addUserBtn.addEventListener('click', showAddUserModal);
    }
    if (elements.cancelBtn) {
      elements.cancelBtn.addEventListener('click', hideUserModal);
    }
    if (elements.userForm) {
      elements.userForm.addEventListener('submit', handleFormSubmit);
    }
    
    if (elements.quickToggleCancelBtn) {
      elements.quickToggleCancelBtn.addEventListener('click', hideQuickToggleModal);
    }
    if (elements.quickToggleConfirmBtn) {
      elements.quickToggleConfirmBtn.addEventListener('click', handleQuickToggleConfirm);
    }
    
    this.setupModalCloseEvents();
    this.setupToastEvents();
    this.setupFormValidationEvents();
    this.setupCheckboxEvents();
    this.setupKeyboardShortcuts();
    monitorStorageChanges();
    
    log('Event listeners initialized successfully');
  },

  // Setup table event listeners
  setupTableEventListeners() {
    if (!elements.userTableBody) return;
    
    elements.userTableBody.removeEventListener('click', this.handleTableClick);
    elements.userTableBody.addEventListener('click', this.handleTableClick);
  },

  handleTableClick(e) {
    const btn = e.target.closest('button');
    if (!btn) return;

    const userId = Number(btn.dataset?.userId || btn.closest('tr')?.dataset?.userId);
    if (!userId || Number.isNaN(userId)) return;

    e.preventDefault();
    e.stopPropagation();

    if (btn.classList.contains('action-edit')) {
      showEditUserModal(userId);
    } else if (btn.classList.contains('action-delete')) {
      deleteUser(userId);
    }
  },

  // Handle search input
  handleSearch() {
    if (!elements.searchInput) return;
    
    if (AppState.searchTimeout) {
      clearTimeout(AppState.searchTimeout);
    }
    
    // Debounce search
    AppState.searchTimeout = setTimeout(() => {
      const searchTerm = elements.searchInput.value.toLowerCase().trim();
      
      AdminState.filterUsers(searchTerm);
      renderUserTable();
      
      if (searchTerm && AppState.filteredUsers.length !== AppState.allUsers.length) {
        showToast('Search Results', `Found ${AppState.filteredUsers.length} of ${AppState.allUsers.length} users`, 'info', 2000);
      }
      
      log(`Search performed: "${searchTerm}", showing ${AppState.filteredUsers.length}/${AppState.allUsers.length} users`);
    }, CONFIG.SEARCH_DEBOUNCE_DELAY);
  },

  // Setup modal close events
  setupModalCloseEvents() {
    if (elements.userModal) {
      elements.userModal.addEventListener('click', function(e) {
        if (e.target === elements.userModal) {
          hideUserModal();
        }
      });
    }
    
    if (elements.quickToggleModal) {
      elements.quickToggleModal.addEventListener('click', function(e) {
        if (e.target === elements.quickToggleModal) {
          hideQuickToggleModal();
        }
      });
    }
  },

  // Setup toast events
  setupToastEvents() {
    if (elements.toastContainer) {
      elements.toastContainer.addEventListener('click', function(e) {
        if (e.target.classList.contains('toast-close')) {
          const toastId = e.target.closest('.toast').id;
          removeToast(toastId);
        }
      });
    }
  },

  // Setup form validation events
  setupFormValidationEvents() {
    if (elements.username) {
      elements.username.addEventListener('blur', validateUsername);
    }
    if (elements.email) {
      elements.email.addEventListener('blur', validateEmail);
    }
    if (elements.fullName) {
      elements.fullName.addEventListener('blur', validateFullName);
    }
    if (elements.password) {
      elements.password.addEventListener('input', validatePassword);
    }
  },

  // Setup checkbox events
  setupCheckboxEvents() {
    if (elements.isActive) {
      elements.isActive.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
      });
    }
    
    if (elements.isPlusAccount) {
      elements.isPlusAccount.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
        
        if (elements.isPlusAccount.checked) {
          showToast('Plus Account', 'User will get premium features access', 'warning', 3000);
        }
      });
    }
    
    if (elements.isAdmin) {
      elements.isAdmin.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
        
        if (elements.isAdmin.checked) {
          showToast('Admin Role', 'User will get full admin panel access', 'warning', 3000);
        }
      });
    }
  },

  // Setup keyboard shortcuts
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
      // Ctrl/Cmd + K: Focus search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        if (elements.searchInput) {
          elements.searchInput.focus();
          elements.searchInput.select();
        }
      }
      
      // Ctrl/Cmd + N: Add new user
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        showAddUserModal();
      }
      
      // Escape: Close modals
      if (e.key === 'Escape') {
        if (elements.userModal?.classList.contains('show')) {
          hideUserModal();
        }
        if (elements.quickToggleModal?.classList.contains('show')) {
          hideQuickToggleModal();
        }
      }
      
      // Ctrl/Cmd + R: Refresh users
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        refreshUsers();
      }
    });
    
    log('Keyboard shortcuts setup completed');
  }
};

document.addEventListener('DOMContentLoaded', function() {
    console.log('Setting up dashboard button event listener');
    
    const dashboardBtn = document.getElementById('dashboardBtn');
    if (dashboardBtn) {
        console.log('Dashboard button found, adding event listener');
        dashboardBtn.addEventListener('click', function(e) {
            console.log('Dashboard button clicked - redirecting...');
            e.preventDefault();
            e.stopPropagation();
            window.location.href = 'admin-dashboard.html';
        });
    } else {
        console.error('Dashboard button not found in DOM');
    }
});

setTimeout(function() {
    const dashboardBtn = document.getElementById('dashboardBtn');
    if (dashboardBtn && !dashboardBtn.hasAttribute('data-listener-added')) {
        console.log('Adding backup dashboard listener');
        dashboardBtn.setAttribute('data-listener-added', 'true');
        dashboardBtn.addEventListener('click', function(e) {
            console.log('Backup dashboard listener triggered');
            e.preventDefault();
            window.location.href = 'admin-dashboard.html';
        });
    }
}, 300000);

// Legacy wrapper functions for backward compatibility
function initializeEventListeners() {
  AdminEvents.initializeEventListeners();
}

function setupTableEventListeners() {
  AdminEvents.setupTableEventListeners();
}

function handleTableClick(e) {
  AdminEvents.handleTableClick(e);
}

function handleSearch() {
  AdminEvents.handleSearch();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminEvents = AdminEvents;
  window.initializeEventListeners = initializeEventListeners;
  window.setupTableEventListeners = setupTableEventListeners;
  window.handleTableClick = handleTableClick;
  window.handleSearch = handleSearch;
}
```

### frontend\public\js\admin\admin-forms.js
```js
/**
 * admin-forms.js
 * Form handling and validation functions
 */

'use strict';

// Form management functions
const AdminForms = {
  getFormData() {
    const data = {
      username: elements.username?.value?.trim() || '',
      email: elements.email?.value?.trim() || '',
      phone: elements.phone?.value?.trim() || '',
      fullName: elements.fullName?.value?.trim() || ''
    };

    if (elements.password?.value && elements.password.value.trim()) {
      data.password = elements.password.value.trim();
    }

    if (AppState.isEditMode && AppState.currentEditingUserId) {
      const isActiveEl = document.getElementById('isActive');
      const isPlusEl = document.getElementById('isPlusAccount'); 
      const isAdminEl = document.getElementById('isAdmin');
      
      data.status = isActiveEl && isActiveEl.checked ? 'active' : 'inactive';
      data.accountType = isPlusEl && isPlusEl.checked ? 'plus' : 'free';
      data.role = isAdminEl && isAdminEl.checked ? 'admin' : 'user';
      
      log('Edit mode form data extracted', {
        formData: data,
        checkboxElements: {
          isActive: isActiveEl?.checked,
          isPlusAccount: isPlusEl?.checked,
          isAdmin: isAdminEl?.checked
        },
        editingUserId: AppState.currentEditingUserId
      });
    } else {
      data.status = 'active';
      data.accountType = 'free';
      data.role = 'user';
      
      log('Add mode form data extracted', data);
    }

    return data;
  },

  // Populate form fields with user data
  populateFormFields(user) {
    if (elements.editUserId) elements.editUserId.value = user.id;
    if (elements.username) elements.username.value = user.username || '';
    if (elements.email) elements.email.value = user.email || '';
    if (elements.phone) elements.phone.value = user.phone || '';
    if (elements.fullName) elements.fullName.value = user.fullName || '';
    if (elements.password) elements.password.value = '';
    if (elements.isActive) {
      elements.isActive.checked = (user.status === 'active');
      log('Set isActive checkbox', { userStatus: user.status, checked: elements.isActive.checked });
    }
    
    if (elements.isPlusAccount) {
      elements.isPlusAccount.checked = (user.accountType === 'plus');
      log('Set isPlusAccount checkbox', { userAccountType: user.accountType, checked: elements.isPlusAccount.checked });
    }
    
    if (elements.isAdmin) {
      elements.isAdmin.checked = (user.role === 'admin');
      log('Set isAdmin checkbox', { userRole: user.role, checked: elements.isAdmin.checked });
    }
    
    log('Form fields populated', {
      user: user,
      checkboxStates: {
        isActive: elements.isActive?.checked,
        isPlusAccount: elements.isPlusAccount?.checked,
        isAdmin: elements.isAdmin?.checked
      }
    });
  },

  // Validate entire form
  validateForm() {
    let isValid = true;
    
    isValid = this.validateUsername() && isValid;
    isValid = this.validateEmail() && isValid;
    isValid = this.validateFullName() && isValid;
    
    if (!AppState.isEditMode) {
      isValid = this.validatePassword() && isValid;
    }
    
    return isValid;
  },

  // Validate username field
  validateUsername() {
    if (!elements.username) return true;
    
    const username = elements.username.value.trim();
    
    if (!username) {
      this.showFieldError('username', 'Username is required');
      return false;
    }
    
    if (username.length < 3) {
      this.showFieldError('username', 'Username must be at least 3 characters');
      return false;
    }
    
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      this.showFieldError('username', 'Username can only contain letters, numbers, and underscores');
      return false;
    }
    
    const existingUser = AppState.allUsers.find(u => 
      u.username.toLowerCase() === username.toLowerCase() && 
      (!AppState.isEditMode || Number(u.id) !== Number(AppState.currentEditingUserId))
    );
    
    if (existingUser) {
      this.showFieldError('username', 'Username already exists');
      return false;
    }
    
    this.clearFieldError('username');
    return true;
  },

  // Validate email field
  validateEmail() {
    if (!elements.email) return true;
    
    const email = elements.email.value.trim();
    
    if (!email) {
      this.showFieldError('email', 'Email is required');
      return false;
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      this.showFieldError('email', 'Please enter a valid email address');
      return false;
    }
    
    const existingUser = AppState.allUsers.find(u => 
      u.email.toLowerCase() === email.toLowerCase() && 
      (!AppState.isEditMode || Number(u.id) !== Number(AppState.currentEditingUserId))
    );
    
    if (existingUser) {
      this.showFieldError('email', 'Email already exists');
      return false;
    }
    
    this.clearFieldError('email');
    return true;
  },

  // Validate full name field
  validateFullName() {
    if (!elements.fullName) return true;
    
    const fullName = elements.fullName.value.trim();
    
    if (!fullName) {
      this.showFieldError('fullName', 'Full name is required');
      return false;
    }
    
    if (fullName.length < 2) {
      this.showFieldError('fullName', 'Full name must be at least 2 characters');
      return false;
    }
    
    this.clearFieldError('fullName');
    return true;
  },

  // Validate password field
  validatePassword() {
    if (!elements.password) return true;
    
    const password = elements.password.value;
    
    if (!AppState.isEditMode && !password) {
      this.showFieldError('password', 'Password is required');
      return false;
    }
    
    if (password && password.length < 6) {
      this.showFieldError('password', 'Password must be at least 6 characters');
      return false;
    }
    
    this.clearFieldError('password');
    return true;
  },

  // Show field validation error
  showFieldError(fieldName, message) {
    const errorElement = document.getElementById(fieldName + 'Error');
    const inputElement = elements[fieldName];
    
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.color = '#dc3545';
      errorElement.style.fontSize = '12px';
      errorElement.style.fontWeight = '500';
    }
    
    if (inputElement) {
      inputElement.classList.add('has-error');
      inputElement.style.borderColor = '#667eea';
      inputElement.style.boxShadow = 'none';
      inputElement.style.transform = 'none';
      
      // Add shake animation
      inputElement.style.animation = 'shake 0.3s ease-in-out';
      setTimeout(() => {
        if (inputElement) inputElement.style.animation = '';
      }, 300);
    }
  },

  // Clear field validation error
  clearFieldError(fieldName) {
    const errorElement = document.getElementById(fieldName + 'Error');
    const inputElement = elements[fieldName];
    
    if (errorElement) errorElement.textContent = '';
    
    if (inputElement) {
      inputElement.classList.remove('has-error');
      inputElement.style.borderColor = '#667eea';
      inputElement.style.boxShadow = 'none';
      inputElement.style.transform = 'none';
    }
  },

  // Clear all validation errors
  clearValidationErrors() {
    const errorFields = ['username', 'email', 'fullName', 'password'];
    errorFields.forEach(field => this.clearFieldError(field));
    
    const formError = document.getElementById('formError');
    if (formError) formError.textContent = '';
  },

  // Handle form submission
  async handleFormSubmit(e) {
    e.preventDefault();
    
    if (!this.validateForm()) {
      showToast('Validation Error', 'Please fix the errors below', 'error');
      return;
    }
    
    showButtonLoading(elements.saveBtn, elements.saveBtnText, elements.saveBtnLoader, true);
    
    try {
      const formData = this.getFormData();
      
      if (AppState.isEditMode && AppState.currentEditingUserId) {
        // Update existing user - DO NOT reload after update
        await updateUser(AppState.currentEditingUserId, formData);
      } else {
        // Create new user - reload to get fresh data from server
        await createUser(formData);
        await loadUsers();
      }
      
      hideUserModal();
      
    } catch (error) {
      log('Form submission error', error, 'error');
      showToast('Error', error.message || 'Operation failed', 'error');
    } finally {
      showButtonLoading(elements.saveBtn, elements.saveBtnText, elements.saveBtnLoader, false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
function getFormData() {
  return AdminForms.getFormData();
}

function populateFormFields(user) {
  return AdminForms.populateFormFields(user);
}

function validateForm() {
  return AdminForms.validateForm();
}

function validateUsername() {
  return AdminForms.validateUsername();
}

function validateEmail() {
  return AdminForms.validateEmail();
}

function validateFullName() {
  return AdminForms.validateFullName();
}

function validatePassword() {
  return AdminForms.validatePassword();
}

function showFieldError(fieldName, message) {
  return AdminForms.showFieldError(fieldName, message);
}

function clearFieldError(fieldName) {
  return AdminForms.clearFieldError(fieldName);
}

function clearValidationErrors() {
  return AdminForms.clearValidationErrors();
}

async function handleFormSubmit(e) {
  return AdminForms.handleFormSubmit(e);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminForms = AdminForms;
  window.getFormData = getFormData;
  window.populateFormFields = populateFormFields;
  window.validateForm = validateForm;
  window.validateUsername = validateUsername;
  window.validateEmail = validateEmail;
  window.validateFullName = validateFullName;
  window.validatePassword = validatePassword;
  window.showFieldError = showFieldError;
  window.clearFieldError = clearFieldError;
  window.clearValidationErrors = clearValidationErrors;
  window.handleFormSubmit = handleFormSubmit;
}
```

### frontend\public\js\admin\admin-main.js
```js
/**
 * admin-main.js
 * Main initialization and entry point
 */

'use strict';

// Main admin panel initialization
const AdminMain = {
  async init() {
    try {
      log('Initializing Enhanced Admin Panel v8.0.0 (Complete Modular System)...');
        if (!validateAuthentication()) {
        return;
      }
      initializeElements();
      initializeEventListeners();
      setupInputFixes();
      setupPasswordToggle();
      const userData = getUserData();
      if (userData && elements.adminUsername) {
        elements.adminUsername.textContent = userData.username || 'admin';
      }
      await loadUsers();
      if (userData) {
        showToast('Admin Panel Ready', `Welcome ${userData.username}! Complete modular system loaded.`, 'success', 3000);
      }
      this.setupAutoRefresh();
      
      log('Enhanced admin panel initialization complete');
      
    } catch (error) {
      log('Initialization failed', error, 'error');
      showError('Initialization failed: ' + error.message);
    }
  },

  // Setup auto-refresh functionality
  setupAutoRefresh() {
    if (CONFIG.AUTO_REFRESH_INTERVAL > 0) {
      AppState.autoRefreshTimer = setInterval(() => {
        if (!AppState.isEditMode && !AppState.isLoading) {
          log('Auto-refresh triggered');
          loadUsers();
        }
      }, CONFIG.AUTO_REFRESH_INTERVAL);
      
      log(`Auto-refresh setup: every ${CONFIG.AUTO_REFRESH_INTERVAL / 1000} seconds`);
    }
  },

  // Add CSS animations
  addCSSAnimations() {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-10px); }
      }
      
      @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .modal.show {
        animation: fadeIn 0.3s ease-out;
      }
      
      .toast {
        animation: fadeIn 0.3s ease-out;
      }
      
      .loading-spinner .spinner {
        animation: spin 1s linear infinite;
      }
      
      .btn:hover {
        transform: translateY(-1px);
        transition: transform 0.2s ease;
      }
      
      .btn:active {
        transform: translateY(0);
      }
    `;
    document.head.appendChild(style);
    log('CSS animations added');
  },

  // Setup legacy globals for backward compatibility
  setupLegacyGlobals() {
    window.AdminPanel = {
      init: this.init.bind(this),
      loadUsers,
      showAddUserModal,
      showEditUserModal,
      deleteUser,
      toggleDebug,
      handleLogout,
      exportUsers,
      log,
      AppState,
      CONFIG,
      AdminAPI,
      AdminAuth,
      AdminUI,
      AdminForms,
      AdminModals,
      AdminEvents,
      AdminDebug,
      AdminStorage
    };
    
    log('Legacy globals setup for backward compatibility');
  },

  // Handle page unload
  cleanup() {
    if (AppState.autoRefreshTimer) {
      clearInterval(AppState.autoRefreshTimer);
      AppState.autoRefreshTimer = null;
    }
    
    if (AppState.searchTimeout) {
      clearTimeout(AppState.searchTimeout);
      AppState.searchTimeout = null;
    }
    
    log('Admin panel cleanup completed');
  },

  // Development mode setup
  setupDevelopmentMode() {
    if (CONFIG.DEBUG_MODE || window.location.hostname === 'localhost') {
      // Add development helpers
      window.dev = {
        loadMockData: () => {
          const mockUsers = [
            { id: 1, username: 'admin', fullName: 'System Admin', email: 'admin@test.com', role: 'admin', accountType: 'plus', status: 'active' },
            { id: 2, username: 'user1', fullName: 'Test User 1', email: 'user1@test.com', role: 'user', accountType: 'free', status: 'active' },
            { id: 3, username: 'user2', fullName: 'Test User 2', email: 'user2@test.com', role: 'user', accountType: 'plus', status: 'inactive' }
          ];
          AdminState.setUsers(mockUsers);
          updateStatistics();
          renderUserTable();
          showToast('Development', 'Mock data loaded', 'info', 2000);
        },
        
        resetApp: () => {
          AdminState.setUsers([]);
          updateStatistics();
          renderUserTable();
          showToast('Development', 'App state reset', 'info', 2000);
        },
        
        testToasts: () => {
          showToast('Success', 'This is a success message', 'success', 3000);
          setTimeout(() => showToast('Error', 'This is an error message', 'error', 3000), 500);
          setTimeout(() => showToast('Warning', 'This is a warning message', 'warning', 3000), 1000);
          setTimeout(() => showToast('Info', 'This is an info message', 'info', 3000), 1500);
        },
        
        simulateError: () => {
          throw new Error('Simulated error for testing');
        }
      };
      
      console.log('Development mode enabled. Use window.dev for dev helpers:', window.dev);
    }
  }
};

// Initialize when DOM is loaded
function initializeAdminPanel() {
  AdminMain.addCSSAnimations();
  AdminMain.setupLegacyGlobals();
  AdminMain.setupDevelopmentMode();
  AdminMain.init();
  window.addEventListener('beforeunload', AdminMain.cleanup);
}

// Auto-start based on document ready state
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAdminPanel);
} else {
  initializeAdminPanel();
}

// Global export
if (typeof window !== 'undefined') {
  window.AdminMain = AdminMain;
}

// Final initialization log
log('Admin panel main script loaded successfully', { 
  version: '8.0.0', 
  features: [
    'Complete Modular Architecture',
    'Separate Storage Keys', 
    'Immediate UI Updates',
    'No Function Conflicts',
    'Enhanced Error Handling',
    'Debug Tools',
    'Development Helpers'
  ],
  timestamp: new Date().toISOString() 
});
```

### frontend\public\js\admin\admin-modals.js
```js
/**
 * admin-modals.js
 * Modal management functions
 */

'use strict';

// Modal management functions
const AdminModals = {
  showAddUserModal() {
    this.resetModalState();
    
    if (elements.modalTitle) elements.modalTitle.textContent = 'Add New User';
    if (elements.saveBtnText) elements.saveBtnText.textContent = 'Create User';
    if (elements.passwordRequired) elements.passwordRequired.style.display = 'inline';
    if (elements.passwordHint) elements.passwordHint.style.display = 'none';
    if (elements.accountSettings) elements.accountSettings.style.display = 'none';
    
    this.showModal();
    log('Add user modal opened');
  },

  // Show edit user modal
  showEditUserModal(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    this.resetModalState();
    AdminState.setEditMode(userId);
    
    // Update modal UI
    if (elements.modalTitle) elements.modalTitle.textContent = 'Edit User';
    if (elements.saveBtnText) elements.saveBtnText.textContent = 'Update User';
    if (elements.passwordRequired) elements.passwordRequired.style.display = 'none';
    if (elements.passwordHint) elements.passwordHint.style.display = 'block';
    if (elements.accountSettings) elements.accountSettings.style.display = 'block';
    if (elements.roleSelection) elements.roleSelection.style.display = 'block';
    
    // Populate form fields
    populateFormFields(user);
    
    this.showModal();
    log('Edit user modal opened', { userId, user });
  },

  // Show modal
  showModal() {
    if (elements.userForm) elements.userForm.reset();
    
    // Populate form if in edit mode
    if (AppState.isEditMode && AppState.currentEditingUserId) {
      const user = AdminState.getUserById(AppState.currentEditingUserId);
      if (user) populateFormFields(user);
    }
    
    clearValidationErrors();
    
    if (elements.userModal) elements.userModal.classList.add('show');
    
    // Apply styling fixes
    setTimeout(() => {
      fixInputStyling();
      if (elements.username) elements.username.focus();
    }, 100);
  },

  // Hide user modal
  hideUserModal() {
    if (elements.userModal) elements.userModal.classList.remove('show');
    this.resetModalState();
    setTimeout(fixInputStyling, 100);
  },

  resetModalState() {
    AdminState.clearEditMode();
    
    if (elements.userForm) {
      elements.userForm.reset();
      const inputs = elements.userForm.querySelectorAll('input, select');
      inputs.forEach(input => {
        input.style.borderColor = '#e9ecef';
        input.style.boxShadow = 'none';
        input.classList.remove('error', 'success');
      });
    }
    clearValidationErrors();
  },

  // Show quick toggle modal
  showQuickToggle(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    if (!elements.quickToggleModal) {
      console.error('Quick toggle modal not found');
      return;
    }
    
    AdminState.setEditMode(userId);
    if (elements.quickToggleUsername) {
      elements.quickToggleUsername.textContent = user.username;
    }
    
    const options = [
      {
        id: 'status',
        label: 'Account Status',
        current: user.status,
        new: user.status === 'active' ? 'inactive' : 'active'
      },
      {
        id: 'accountType',
        label: 'Account Type',
        current: user.accountType,
        new: user.accountType === 'free' ? 'plus' : 'free'
      }
    ];
    
    if (user.role !== 'admin') {
      options.push({
        id: 'role',
        label: 'User Role',
        current: user.role,
        new: user.role === 'user' ? 'admin' : 'user'
      });
    }
    
    if (elements.quickToggleOptions) {
      elements.quickToggleOptions.innerHTML = options.map(option => `
        <div class="quick-toggle-option" data-field="${option.id}">
          <div class="quick-toggle-label">${option.label}</div>
          <div class="quick-toggle-badges">
            <span class="quick-toggle-badge current">${option.current}</span>
            <span style="margin: 0 0.5rem;">→</span>
            <span class="quick-toggle-badge new">${option.new}</span>
          </div>
        </div>
      `).join('');
      
      elements.quickToggleOptions.querySelectorAll('.quick-toggle-option').forEach(option => {
        option.addEventListener('click', function() {
          this.classList.toggle('active');
        });
      });
    }
    
    elements.quickToggleModal.classList.add('show');
    log('Quick toggle modal opened', { userId, user });
  },

  // Hide quick toggle modal
  hideQuickToggleModal() {
    if (elements.quickToggleModal) {
      elements.quickToggleModal.classList.remove('show');
    }
    AdminState.clearEditMode();
  },

  // Handle quick toggle confirmation
  async handleQuickToggleConfirm() {
    if (!elements.quickToggleOptions) return;
    
    const selectedOptions = elements.quickToggleOptions.querySelectorAll('.quick-toggle-option.active');
    
    if (selectedOptions.length === 0) {
      showToast('No Changes', 'Please select at least one option to change', 'warning');
      return;
    }
    
    showButtonLoading(elements.quickToggleConfirmBtn, elements.quickToggleBtnText, elements.quickToggleBtnLoader, true);
    
    try {
      const currentUser = AdminState.getUserById(AppState.currentEditingUserId);
      const changes = {};
      
      selectedOptions.forEach(option => {
        const field = option.dataset.field;
        const newBadge = option.querySelector('.quick-toggle-badge.new');
        const newValue = newBadge.textContent;
        changes[field] = newValue;
      });
      
      await updateUser(AppState.currentEditingUserId, {
        ...currentUser,
        ...changes
      });
      
      this.hideQuickToggleModal();
      
    } catch (error) {
      log('Quick toggle error', error, 'error');
      showToast('Error', error.message || 'Update failed', 'error');
    } finally {
      showButtonLoading(elements.quickToggleConfirmBtn, elements.quickToggleBtnText, elements.quickToggleBtnLoader, false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
function showAddUserModal() {
  AdminModals.showAddUserModal();
}

function showEditUserModal(userId) {
  AdminModals.showEditUserModal(userId);
}

function showModal() {
  AdminModals.showModal();
}

function hideUserModal() {
  AdminModals.hideUserModal();
}

function resetModalState() {
  AdminModals.resetModalState();
}

function showQuickToggle(userId) {
  AdminModals.showQuickToggle(userId);
}

function hideQuickToggleModal() {
  AdminModals.hideQuickToggleModal();
}

async function handleQuickToggleConfirm() {
  return AdminModals.handleQuickToggleConfirm();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminModals = AdminModals;
  window.showAddUserModal = showAddUserModal;
  window.showEditUserModal = showEditUserModal;
  window.showModal = showModal;
  window.hideUserModal = hideUserModal;
  window.resetModalState = resetModalState;
  window.showQuickToggle = showQuickToggle;
  window.hideQuickToggleModal = hideQuickToggleModal;
  window.handleQuickToggleConfirm = handleQuickToggleConfirm;
}
```

### frontend\public\js\admin\admin-state.js
```js
/**
 * admin-state.js
 * Application state management
 */

'use strict';

// Global application state
const AppState = {
  allUsers: [],
  filteredUsers: [],
  currentEditingUserId: null,
  isEditMode: false,
  isDebugMode: false,
  isLoading: false,
  autoRefreshTimer: null,
  searchTimeout: null,
  currentUser: null
};

// DOM elements cache
let elements = {};

const AdminState = {
  setUsers(users) {
    AppState.allUsers = users;
    AppState.filteredUsers = [...users];
  },

  addUser(user) {
    AppState.allUsers.push(user);
    AppState.filteredUsers = [...AppState.allUsers];
  },

  updateUser(userId, updatedUser) {
    const index = AppState.allUsers.findIndex(u => Number(u.id) === Number(userId));
    if (index >= 0) {
      AppState.allUsers[index] = updatedUser;
      AppState.filteredUsers = [...AppState.allUsers];
    }
  },

  removeUser(userId) {
    AppState.allUsers = AppState.allUsers.filter(u => Number(u.id) !== Number(userId));
    AppState.filteredUsers = [...AppState.allUsers];
  },

  filterUsers(searchTerm) {
    if (!searchTerm) {
      AppState.filteredUsers = [...AppState.allUsers];
    } else {
      AppState.filteredUsers = AppState.allUsers.filter(user =>
        user.username.toLowerCase().includes(searchTerm) ||
        user.fullName.toLowerCase().includes(searchTerm) ||
        user.email.toLowerCase().includes(searchTerm) ||
        (user.phone && user.phone.toLowerCase().includes(searchTerm))
      );
    }
  },

  getUserById(userId) {
    return AppState.allUsers.find(u => Number(u.id) === Number(userId));
  },

  // Edit mode management
  setEditMode(userId) {
    AppState.isEditMode = true;
    AppState.currentEditingUserId = userId;
  },

  clearEditMode() {
    AppState.isEditMode = false;
    AppState.currentEditingUserId = null;
  },

  // Loading state
  setLoading(isLoading) {
    AppState.isLoading = isLoading;
  },

  // Debug mode
  toggleDebug() {
    AppState.isDebugMode = !AppState.isDebugMode;
  }
};

// Export to global scope
if (typeof window !== 'undefined') {
  window.AppState = AppState;
  window.AdminState = AdminState;
  window.elements = elements;
}
```

### frontend\public\js\admin\admin-storage.js
```js
/**
 * admin-storage.js
 * Storage management with separate keys for admin and user
 */

'use strict';

// Storage management functions
const AdminStorage = {
  getStorageKey(userRole) {
    return userRole === 'admin' ? CONFIG.ADMIN_STORAGE_KEY : CONFIG.USER_STORAGE_KEY;
  },

  setUserData(userData) {
    try {
      const storageKey = this.getStorageKey(userData.userRole);
      const dataToStore = {
        userId: userData.userId || userData.user?.id || userData.id,
        username: userData.username || userData.user?.username,
        userRole: userData.userRole || userData.user?.role || userData.role,
        email: userData.email || userData.user?.email,
        phone: userData.phone || userData.user?.phone || '',
        fullName: userData.fullName || userData.user?.fullName || userData.name,
        loginTime: new Date().toISOString()
      };
      
      if (!dataToStore.userId || !dataToStore.username || !dataToStore.userRole) {
        throw new Error('Incomplete user data');
      }
      
      localStorage.setItem(storageKey, JSON.stringify(dataToStore));
      
      // Cleanup: remove legacy storage and other role's data
      localStorage.removeItem(CONFIG.LEGACY_STORAGE_KEY);
      if (userData.userRole === 'admin') {
        localStorage.removeItem(CONFIG.USER_STORAGE_KEY);
      } else {
        localStorage.removeItem(CONFIG.ADMIN_STORAGE_KEY);
      }
      
      log(`User data stored with key: ${storageKey}`, dataToStore);
      return dataToStore;
    } catch (error) {
      log('Error storing user data', error, 'error');
      throw error;
    }
  },

  // Get user data for current context
  getUserData() {
    try {
      let userData = null;
      let storageKey = null;
      
      if (isAdminPanel()) {
        storageKey = CONFIG.ADMIN_STORAGE_KEY;
        const adminData = localStorage.getItem(storageKey);
        if (adminData) {
          userData = JSON.parse(adminData);
          log('Retrieved admin data from admin storage', userData);
        }
      } else {
        storageKey = CONFIG.USER_STORAGE_KEY;
        const regularUserData = localStorage.getItem(storageKey);
        if (regularUserData) {
          userData = JSON.parse(regularUserData);
          log('Retrieved user data from user storage', userData);
        }
      }
      
      if (!userData) {
        userData = this.migrateLegacyData();
      }
      
      if (userData) {
        if (!userData.username || !userData.userRole) {
          log('Invalid user data structure', userData, 'warn');
          return null;
        }
        
        if (isAdminPanel() && userData.userRole !== 'admin') {
          log('Non-admin user trying to access admin panel', userData, 'warn');
          return null;
        }
      }
      
      return userData;
    } catch (error) {
      log('Error parsing user data from localStorage', error, 'error');
      return null;
    }
  },

  // Migrate from legacy storage format
  migrateLegacyData() {
    try {
      const legacyData = localStorage.getItem(CONFIG.LEGACY_STORAGE_KEY);
      if (!legacyData) return null;
      
      const userData = JSON.parse(legacyData);
      if (!userData.userRole) return null;
      
      log('Migrating legacy data', userData);
      
      const newStorageKey = this.getStorageKey(userData.userRole);
      localStorage.setItem(newStorageKey, legacyData);
      
      localStorage.removeItem(CONFIG.LEGACY_STORAGE_KEY);
      
      log(`Legacy data migrated to: ${newStorageKey}`);
      return userData;
    } catch (error) {
      log('Error migrating legacy data', error, 'error');
      return null;
    }
  },

  // Clear user data
  clearUserData(userRole) {
    const storageKey = this.getStorageKey(userRole);
    localStorage.removeItem(storageKey);
    localStorage.removeItem('admin_token');
    log(`Cleared data for role: ${userRole}`);
  },

  // Check if current user is admin
  isCurrentUserAdmin() {
    const userData = this.getUserData();
    return userData && userData.userRole === 'admin';
  }
};

// Storage change monitoring
function monitorStorageChanges() {
  window.addEventListener('storage', function(e) {
    if (e.key === CONFIG.ADMIN_STORAGE_KEY || e.key === CONFIG.USER_STORAGE_KEY || e.key === CONFIG.LEGACY_STORAGE_KEY) {
      log('Storage change detected', { key: e.key, newValue: e.newValue ? 'Data present' : 'Data removed' });
      
      const currentUser = AdminStorage.getUserData();
      if (!currentUser && isAdminPanel()) {
        showToast('Session Changed', 'Admin session was modified in another tab', 'warning', 3000);
      }
    }
  });
  
  log('Storage monitoring initialized');
}

// Legacy wrapper functions for backward compatibility
function getUserData() {
  return AdminStorage.getUserData();
}

function setUserData(userData) {
  return AdminStorage.setUserData(userData);
}

function getStorageKey(userRole) {
  return AdminStorage.getStorageKey(userRole);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminStorage = AdminStorage;
  window.getUserData = getUserData;
  window.setUserData = setUserData;
  window.getStorageKey = getStorageKey;
  window.monitorStorageChanges = monitorStorageChanges;
}
```

### frontend\public\js\admin\admin-ui.js
```js
/**
 * admin-ui.js
 * UI update and management functions
 */

'use strict';

// UI management functions
const AdminUI = {
  updateStatistics() {
    const stats = {
      total: AppState.allUsers.length,
      active: AppState.allUsers.filter(u => u.status === 'active').length,
      inactive: AppState.allUsers.filter(u => u.status === 'inactive').length,
      plus: AppState.allUsers.filter(u => u.accountType === 'plus').length,
      free: AppState.allUsers.filter(u => u.accountType === 'free').length,
      admin: AppState.allUsers.filter(u => u.role === 'admin').length
    };
    
    if (elements.totalUsers) elements.totalUsers.textContent = stats.total;
    if (elements.activeUsers) elements.activeUsers.textContent = stats.active;
    if (elements.plusUsers) elements.plusUsers.textContent = stats.plus;
    
    log('Statistics updated', stats);
  },

  // Render user table
  renderUserTable() {
    if (!elements.userTableBody) {
      console.error('User table body element not found');
      return;
    }
    
    if (AppState.filteredUsers.length === 0) {
      elements.userTableBody.innerHTML = `
        <tr>
          <td colspan="11" class="empty">
            ${AppState.allUsers.length === 0 ? 'No users found in database.' : 'No users match your search criteria.'}
          </td>
        </tr>
      `;
      return;
    }
    
    elements.userTableBody.innerHTML = AppState.filteredUsers.map(user => `
      <tr data-user-id="${user.id}">
        <td>${user.id}</td>
        <td><strong>${user.username}</strong></td>
        <td>${user.fullName}</td>
        <td>${user.email}</td>
        <td>${user.phone || '-'}</td>
        <td>
          <span class="role-badge role-${user.role}">${user.role}</span>
        </td>
        <td>
          <span class="account-type-badge ${user.accountType}">${user.accountType}</span>
        </td>
        <td>
          <span class="status-badge status-${user.status}">${user.status}</span>
        </td>
        <td>${formatDate(user.createdAt)}</td>
        <td>${user.updatedAt ? formatDate(user.updatedAt) : '-'}</td>  
        <td>
          <div class="actions">
            <button class="btn btn-small btn-primary action-edit" data-user-id="${user.id}" title="Edit User">
              ✏️ Edit
            </button>
            <button class="btn btn-small btn-danger action-delete" data-user-id="${user.id}" title="Delete User">
              🗑️ Delete
            </button>
          </div>
        </td>
      </tr>
    `).join('');
    
    setupTableEventListeners();
    log('User table rendered', { displayedCount: AppState.filteredUsers.length });
  },

  // Update connection status indicator
  updateConnectionStatus(status = 'loading') {
    const statusMap = {
      online: { class: 'status-online', text: 'Connected to Database' },
      offline: { class: 'status-offline', text: 'Database Offline' },
      loading: { class: 'status-loading', text: 'Connecting...' }
    };
    
    const config = statusMap[status] || statusMap.loading;
    
    if (elements.connectionStatus) {
      elements.connectionStatus.className = `status-indicator ${config.class}`;
    }
    if (elements.connectionText) {
      elements.connectionText.textContent = config.text;
    }
    
    log(`Connection status updated: ${status} - ${config.text}`);
  },

  // Show/hide loading overlay
  showLoading(show) {
    if (elements.loadingOverlay) {
      elements.loadingOverlay.style.display = show ? 'flex' : 'none';
    }
    AppState.isLoading = show;
  },

  // Show/hide button loading state
  showButtonLoading(button, textElement, loaderElement, show) {
    if (!button) return;
    
    if (show) {
      button.disabled = true;
      if (textElement) textElement.style.display = 'none';
      if (loaderElement) loaderElement.style.display = 'inline-block';
    } else {
      button.disabled = false;
      if (textElement) textElement.style.display = 'inline';
      if (loaderElement) loaderElement.style.display = 'none';
    }
  },

  // Show toast notification
  showToast(title, message, type = 'info', duration = 3000) {
    if (!elements.toastContainer) {
      log('Toast container not found', null, 'warn');
      return;
    }
    
    const toastId = 'toast-' + Date.now();
    
    const icons = {
      success: '✅',
      error: '❌',
      warning: '⚠️',
      info: 'ℹ️'
    };
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.id = toastId;
    toast.innerHTML = `
      <div class="toast-content">
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-message">
          <div class="toast-title">${title}</div>
          <div class="toast-text">${message}</div>
        </div>
        <button class="toast-close" data-toast-id="${toastId}">×</button>
      </div>
      <div class="toast-progress"></div>
    `;
    
    elements.toastContainer.appendChild(toast);
    
    setTimeout(() => this.removeToast(toastId), duration);
    log(`Toast shown: ${type} - ${title}: ${message}`);
  },

  // Remove toast notification
  removeToast(toastId) {
    const toast = document.getElementById(toastId);
    if (toast) {
      toast.style.animation = 'slideOutRight 0.3s ease-out forwards';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }
  },

  // Show error in table
  showError(message) {
    if (elements.userTableBody) {
      elements.userTableBody.innerHTML = `
        <tr>
          <td colspan="11" class="error">
            <span class="status-indicator status-offline"></span>
            <strong>Error:</strong> ${message}
            <br><button class="btn btn-small retry-btn" style="margin-top: 1rem;">🔄 Retry</button>
          </td>
        </tr>
      `;
      
      const retryBtn = elements.userTableBody.querySelector('.retry-btn');
      if (retryBtn) {
        retryBtn.addEventListener('click', loadUsers);
      }
    }
    
    this.updateConnectionStatus('offline');
  },

  // Refresh users
  refreshUsers() {
    this.showToast('Refreshing', 'Loading latest user data from database...', 'info', 1000);
    loadUsers();
  },

  // Toggle debug panel
  toggleDebug() {
    AppState.isDebugMode = !AppState.isDebugMode;
    
    if (!elements.debugInfo || !elements.debugBtn) return;
    
    const isVisible = elements.debugInfo.style.display !== 'none';
    
    if (isVisible) {
      elements.debugInfo.style.display = 'none';
      elements.debugBtn.textContent = '🔍 Debug';
    } else {
      elements.debugInfo.style.display = 'block';
      elements.debugBtn.textContent = '🔍 Hide Debug';
      this.updateDebugInfo();
    }
    
    log(`Debug mode ${AppState.isDebugMode ? 'enabled' : 'disabled'}`);
  },

  // Update debug information
  updateDebugInfo() {
    if (!elements.debugContent) return;
    
    const debugData = {
      'Total Users': AppState.allUsers.length,
      'Filtered Users': AppState.filteredUsers.length,
      'Edit Mode': AppState.isEditMode,
      'Current User': AppState.currentEditingUserId ? 
        AdminState.getUserById(AppState.currentEditingUserId)?.username || 'Unknown' : 'None',
      'Search Term': elements.searchInput?.value || 'Empty',
      'API Base URL': CONFIG.API_BASE_URL,
      'Storage Key': CONFIG.ADMIN_STORAGE_KEY,
      'Last Updated': new Date().toLocaleString(),
      'Sample User Data': AppState.allUsers.length > 0 ? JSON.stringify(AppState.allUsers[0], null, 2) : 'No users loaded'
    };
    
    elements.debugContent.innerHTML = Object.entries(debugData)
      .map(([key, value]) => `<div><strong>${key}:</strong> ${value}</div>`)
      .join('');
  }
};

// Legacy wrapper functions for backward compatibility
function updateStatistics() {
  AdminUI.updateStatistics();
}

function renderUserTable() {
  AdminUI.renderUserTable();
}

function updateConnectionStatus(status) {
  AdminUI.updateConnectionStatus(status);
}

function showLoading(show) {
  AdminUI.showLoading(show);
}

function showButtonLoading(button, textElement, loaderElement, show) {
  AdminUI.showButtonLoading(button, textElement, loaderElement, show);
}

function showToast(title, message, type, duration) {
  AdminUI.showToast(title, message, type, duration);
}

function removeToast(toastId) {
  AdminUI.removeToast(toastId);
}

function showError(message) {
  AdminUI.showError(message);
}

function refreshUsers() {
  AdminUI.refreshUsers();
}

function toggleDebug() {
  AdminUI.toggleDebug();
}

function updateDebugInfo() {
  AdminUI.updateDebugInfo();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminUI = AdminUI;
  window.updateStatistics = updateStatistics;
  window.renderUserTable = renderUserTable;
  window.updateConnectionStatus = updateConnectionStatus;
  window.showLoading = showLoading;
  window.showButtonLoading = showButtonLoading;
  window.showToast = showToast;
  window.removeToast = removeToast;
  window.showError = showError;
  window.refreshUsers = refreshUsers;
  window.toggleDebug = toggleDebug;
  window.updateDebugInfo = updateDebugInfo;
}
```

### frontend\public\js\admin\admin-utils.js
```js
/**
 * admin-utils.js
 * Utility functions for admin panel
 */

'use strict';

// Logging function
function log(message, data = null, level = 'info') {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] 🔍 Admin Panel: ${message}`;
  
  switch (level) {
    case 'error':
      console.error(logMessage, data || '');
      break;
    case 'warn':
      console.warn(logMessage, data || '');
      break;
    default:
      console.log(logMessage, data || '');
  }
  
  // Add to debug panel if enabled
  if (AppState.isDebugMode) {
    const debugContent = document.getElementById('debugContent');
    if (debugContent) {
      const debugEntry = document.createElement('div');
      debugEntry.innerHTML = `
        <div style="margin-bottom: 0.5rem; padding: 0.5rem; border-left: 3px solid ${level === 'error' ? '#dc3545' : level === 'warn' ? '#ffc107' : '#28a745'};">
          <strong>[${new Date().toLocaleTimeString()}]</strong> ${message}
          ${data ? `<pre style="margin-top: 0.25rem; font-size: 0.75rem;">${JSON.stringify(data, null, 2)}</pre>` : ''}
        </div>
      `;
      debugContent.appendChild(debugEntry);
      debugContent.scrollTop = debugContent.scrollHeight;
    }
  }
}

// Format date helper
function formatDate(dateString) {
  if (!dateString) return 'N/A';
  try {
    const parts = dateString.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})/);
    if (parts) {
      const [, year, month, day, hour, minute] = parts;
      return `${new Date(year, month-1, day).toLocaleDateString('en-US', {month: 'short'})} ${day}, ${year}, ${hour.padStart(2,'0')}:${minute}`;
    }
    return dateString; 
  } catch (e) {
    return 'Invalid Date';
  }
}

// Delay helper
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function isAdminPanel() {
  return window.location.pathname.includes('admin') || 
         window.location.href.includes('admin') ||
         document.title.toLowerCase().includes('admin') ||
         document.getElementById('adminUsername') !== null;
}

// Initialize DOM elements
function initializeElements() {
  elements = {
    adminUsername: document.getElementById('adminUsername'),
    connectionStatus: document.getElementById('connectionStatus'),
    connectionText: document.getElementById('connectionText'),
    logoutBtn: document.getElementById('logoutBtn'),
    
    totalUsers: document.getElementById('totalUsers'),
    activeUsers: document.getElementById('activeUsers'),
    plusUsers: document.getElementById('plusUsers'),
    
    searchInput: document.getElementById('searchInput'),
    userTableBody: document.getElementById('userTableBody'),
    refreshBtn: document.getElementById('refreshBtn'),
    debugBtn: document.getElementById('debugBtn'),
    debugInfo: document.getElementById('debugInfo'),
    debugContent: document.getElementById('debugContent'),
    
    userModal: document.getElementById('userModal'),
    modalTitle: document.getElementById('modalTitle'),
    userForm: document.getElementById('userForm'),
    addUserBtn: document.getElementById('addUserBtn'),
    cancelBtn: document.getElementById('cancelBtn'),
    saveBtn: document.getElementById('saveBtn'),
    saveBtnText: document.getElementById('saveBtnText'),
    saveBtnLoader: document.getElementById('saveBtnLoader'),
    
    editUserId: document.getElementById('editUserId'),
    username: document.getElementById('username'),
    email: document.getElementById('email'),
    phone: document.getElementById('phone'),
    fullName: document.getElementById('fullName'),
    password: document.getElementById('password'),
    passwordRequired: document.getElementById('passwordRequired'),
    passwordHint: document.getElementById('passwordHint'),
    
    accountSettings: document.getElementById('accountSettings'),
    isActive: document.getElementById('isActive'),
    isPlusAccount: document.getElementById('isPlusAccount'),
    isAdmin: document.getElementById('isAdmin'),
    roleSelection: document.getElementById('roleSelection'),
    
    quickToggleModal: document.getElementById('quickToggleModal'),
    quickToggleUsername: document.getElementById('quickToggleUsername'),
    quickToggleOptions: document.getElementById('quickToggleOptions'),
    quickToggleCancelBtn: document.getElementById('quickToggleCancelBtn'),
    quickToggleConfirmBtn: document.getElementById('quickToggleConfirmBtn'),
    quickToggleBtnText: document.getElementById('quickToggleBtnText'),
    quickToggleBtnLoader: document.getElementById('quickToggleBtnLoader'),
    
    loadingOverlay: document.getElementById('loadingOverlay'),
    toastContainer: document.getElementById('toastContainer')
  };
  
  log('DOM elements initialized');
}

// Fix input styling issues
function fixInputStyling() {
  const inputs = document.querySelectorAll('input, select');
  
  inputs.forEach(input => {
    input.removeAttribute('aria-invalid');
    input.removeAttribute('aria-describedby');
    
    input.classList.remove('invalid', 'valid', 'error');
    
    // Force reset styling
    input.style.borderColor = '#667eea';
    input.style.boxShadow = 'none';
    input.style.outline = 'none';
    input.style.transform = 'none';
    input.style.backfaceVisibility = 'hidden';
    
    // Override events
    const events = ['focus', 'blur', 'invalid', 'input'];
    events.forEach(eventType => {
      input.addEventListener(eventType, function(e) {
        if (eventType === 'invalid') {
          e.preventDefault();
          e.stopPropagation();
        }
        
        this.style.borderColor = eventType === 'focus' ? '#4f46e5' : '#667eea';
        this.style.boxShadow = eventType === 'focus' ? '0 0 0 3px rgba(102, 126, 234, 0.15)' : 'none';
        this.style.outline = 'none';
        this.style.transform = 'none';
      });
    });
  });
}

// Setup input fixes
function setupInputFixes() {
  const userModal = document.getElementById('userModal');
  if (userModal) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          if (userModal.classList.contains('show')) {
            setTimeout(fixInputStyling, 50);
            setTimeout(fixInputStyling, 200);
            setTimeout(fixInputStyling, 500);
          }
        }
      });
    });
    
    observer.observe(userModal, {
      attributes: true,
      attributeFilter: ['class']
    });
  }
}

// Setup password toggle
function setupPasswordToggle() {
  document.addEventListener('click', (e) => {
    if (e.target.closest('#togglePassword') || e.target.closest('.toggle-password')) {
      const toggleBtn = e.target.closest('#togglePassword') || e.target.closest('.toggle-password');
      const passwordInput = document.getElementById('password');
      
      if (passwordInput) {
        const isHidden = passwordInput.getAttribute('type') === 'password';
        passwordInput.setAttribute('type', isHidden ? 'text' : 'password');
        
        const icon = toggleBtn.querySelector('i');
        if (icon) {
          icon.classList.toggle('fa-eye', !isHidden);
          icon.classList.toggle('fa-eye-slash', isHidden);
        }
      }
    }
  }
);
}

// Export functions
function exportUsers(format = 'csv') {
  const exportData = AppState.filteredUsers.map(user => ({
    ID: user.id,
    Username: user.username,
    'Full Name': user.fullName,
    Email: user.email,
    Phone: user.phone || '',
    Role: user.role,
    'Account Type': user.accountType,
    Status: user.status,
    'Created At': formatDate(user.createdAt)
  }));
  
  if (format === 'csv') {
    exportToCSV(exportData, 'users.csv');
  } else if (format === 'json') {
    exportToJSON(exportData, 'users.json');
  }
  
  showToast('Export', `Exported ${exportData.length} users as ${format.toUpperCase()}`, 'success');
}

function exportToCSV(data, filename) {
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => 
        JSON.stringify(row[header] || '')
      ).join(',')
    )
  ].join('\n');
  
  downloadFile(csvContent, filename, 'text/csv');
}

function exportToJSON(data, filename) {
  const jsonContent = JSON.stringify(data, null, 2);
  downloadFile(jsonContent, filename, 'application/json');
}

function downloadFile(content, filename, contentType) {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Global exports
if (typeof window !== 'undefined') {
  window.log = log;
  window.formatDate = formatDate;
  window.delay = delay;
  window.isAdminPanel = isAdminPanel;
  window.initializeElements = initializeElements;
  window.fixInputStyling = fixInputStyling;
  window.setupInputFixes = setupInputFixes;
  window.setupPasswordToggle = setupPasswordToggle;
  window.exportUsers = exportUsers;
}
```

### frontend\public\js\admin\dashboard.js
```js
// frontend/public/js/admin/dashboard.js
class DashboardManager {
    constructor() {
        this.charts = {};
        this.data = {};
        this.isLoading = false;
        
        // Initialize dashboard
        this.init();
    }

    async init() {
        console.log('Initializing dashboard...');
        
        this.updateConnectionStatus('connecting', 'Connecting to database...');
        
        if (!this.checkAdminAuth()) {
            this.updateConnectionStatus('error', 'Authentication failed');
            window.location.href = 'login.html';
            return;
        }
        
        this.setupEventListeners();
        
        await this.loadDashboardData();
    }

    updateConnectionStatus(status, text) {
        const statusIndicator = document.getElementById('connectionStatus');
        const connectionText = document.getElementById('connectionText');
        
        console.log(`Updating connection status to: ${status} - ${text}`);
        
        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            switch(status) {
                case 'connecting':
                    statusIndicator.classList.add('status-loading');
                    break;
                case 'connected':
                    statusIndicator.classList.add('status-success');
                    break;
                case 'error':
                    statusIndicator.classList.add('status-error');
                    break;
            }
            console.log('Status indicator classes:', statusIndicator.className);
        } else {
            console.error('Status indicator element not found');
        }
        
        if (connectionText) {
            connectionText.textContent = text;
            console.log('Connection text updated to:', text);
        } else {
            console.error('Connection text element not found');
        }
    }

    checkAdminAuth() {
        const userData = JSON.parse(localStorage.getItem('loggedInAs_admin')) ||
                        JSON.parse(localStorage.getItem('loggedInAs'));
        
        if (!userData || userData.userRole !== 'admin') {
            console.error('Admin authentication required');
            return false;
        }
        
        // Update header username
        document.getElementById('adminUsername').textContent = userData.username || 'Admin';
        return true;
    }

    setupEventListeners() {
        console.log('Setting up dashboard event listeners...');

        document.getElementById('backToAdminBtn')?.addEventListener('click', (e) => {
            console.log('Back to Admin Panel button clicked');
            e.preventDefault();
            window.location.href = 'admin.html';
        });

        document.getElementById('refreshDashboardBtn')?.addEventListener('click', (e) => {
            console.log('Refresh dashboard button clicked');
            e.preventDefault();
            this.loadDashboardData();
        });

        document.getElementById('exportStatsBtn')?.addEventListener('click', (e) => {
            console.log('Export stats button clicked');
            e.preventDefault();
            this.exportStatistics();
        });

        document.getElementById('timeframeSelect')?.addEventListener('change', (e) => {
            console.log('Timeframe changed:', e.target.value);
            this.updateTimelineChart(e.target.value);
        });

        console.log('Dashboard event listeners setup complete');
    }

    async loadDashboardData() {
        if (this.isLoading) return;
        
        this.isLoading = true;
        this.showLoading(true);
        this.updateConnectionStatus('connecting', 'Loading data...');
        
        try {
            console.log('Loading dashboard data...');
            
            const [overviewData, accountTypesData, languagesData, timeframeData] = await Promise.all([
                this.fetchOverviewStats(),
                this.fetchAccountTypesStats(),
                this.fetchLanguageStats(),
                this.fetchTimeframeStats('day')
            ]);

            this.data = {
                overview: overviewData,
                accountTypes: accountTypesData,
                languages: languagesData,
                timeframe: timeframeData
            };

            this.updateOverviewCards();
            this.updateCharts();
            
            console.log('Dashboard data loaded successfully:', this.data);
            this.updateConnectionStatus('connected', 'Connected to Database');

        } catch (error) {
            console.error('Error loading dashboard data:', error);
            this.updateConnectionStatus('error', 'Connection failed');
            this.showError(true);
            this.showToast('Error', 'Failed to load dashboard data: ' + error.message, 'error');
        } finally {
            this.isLoading = false;
            this.showLoading(false);
        }
    }

    async fetchWithAuth(url, options = {}) {
        const userData = JSON.parse(localStorage.getItem('loggedInAs_admin')) ||
                        JSON.parse(localStorage.getItem('loggedInAs'));
        
        const headers = {
            'Content-Type': 'application/json',
            'x-user-role': 'admin',
            'x-user-id': userData?.userId?.toString() || '',
            ...options.headers
        };

        console.log('Fetching:', url, 'with headers:', headers);

        const response = await fetch(url, {
            ...options,
            headers
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        if (!data.success) {
            throw new Error(data.error || 'API request failed');
        }

        return data.data;
    }

    async fetchOverviewStats() {
        return await this.fetchWithAuth('/api/stats/overview');
    }

    async fetchAccountTypesStats() {
        return await this.fetchWithAuth('/api/stats/account-types');
    }

    async fetchLanguageStats(days = 30) {
        return await this.fetchWithAuth(`/api/stats/languages?days=${days}`);
    }

    async fetchTimeframeStats(range = 'day') {
        return await this.fetchWithAuth(`/api/stats/timeframe?range=${range}&action=grammar_check`);
    }

    updateOverviewCards() {
        console.log('Updating overview cards with data:', this.data.overview);
        
        const { overview } = this.data;
        if (!overview) {
            console.warn('No overview data available');
            return;
        }

        // Update user stats
        document.getElementById('totalUsersCount').textContent = overview.total_users || 0;
        document.getElementById('activeUsersCount').textContent = overview.active_users || 0;

        // Calculate mock data if needed
        const totalUsers = overview.total_users || 0;
        const grammarChecks = Math.floor(totalUsers * 25) || 0;
        const todayChecks = Math.floor(grammarChecks * 0.1) || 0;

        document.getElementById('grammarChecksCount').textContent = grammarChecks;
        document.getElementById('todayChecksCount').textContent = todayChecks;

        // Update language stats
        const languageCount = this.data.languages?.languages?.length || 0;
        document.getElementById('languagesCount').textContent = languageCount;
        document.getElementById('mostUsedLanguage').textContent = 
            this.data.languages?.most_used?.language_name || 'N/A';

        // Update notification stats
        document.getElementById('totalNotificationsCount').textContent = overview.total_notifications || 0;
        document.getElementById('unreadNotificationsCount').textContent = overview.unread_notifications || 0;
    }

    updateCharts() {
        console.log('Updating charts...');
        this.updateAccountTypesChart();
        this.updateLanguagesChart();
        this.updateTimelineChart();
    }

    updateAccountTypesChart() {
        const canvas = document.getElementById('accountTypesChart');
        const { accountTypes } = this.data;
        
        if (!canvas || !accountTypes?.breakdown) {
            console.warn('Cannot update account types chart: missing canvas or data');
            return;
        }

        // Destroy existing chart
        if (this.charts.accountTypes) {
            this.charts.accountTypes.destroy();
        }

        const ctx = canvas.getContext('2d');
        
        this.charts.accountTypes = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: accountTypes.breakdown.map(item => 
                    item.type.charAt(0).toUpperCase() + item.type.slice(1)
                ),
                datasets: [{
                    data: accountTypes.breakdown.map(item => item.count),
                    backgroundColor: [
                        '#28a745',
                        '#ffc107',
                        '#17a2b8',
                        '#dc3545'
                    ],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 20,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.label;
                                const value = context.parsed;
                                const percentage = accountTypes.breakdown[context.dataIndex].percentage;
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    updateLanguagesChart() {
        const canvas = document.getElementById('languagesChart');
        const { languages } = this.data;
        
        if (!canvas || !languages?.languages) {
            console.warn('Cannot update languages chart: missing canvas or data');
            return;
        }

        // Destroy existing chart
        if (this.charts.languages) {
            this.charts.languages.destroy();
        }

        const ctx = canvas.getContext('2d');
        
        // Take top 6 languages
        const topLanguages = languages.languages.slice(0, 6);
        
        this.charts.languages = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topLanguages.map(item => item.language_name),
                datasets: [{
                    label: 'Usage Count',
                    data: topLanguages.map(item => item.usage_count),
                    backgroundColor: [
                        '#007bff',
                        '#28a745',
                        '#ffc107',
                        '#dc3545',
                        '#17a2b8',
                        '#6f42c1'
                    ],
                    borderWidth: 1,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            afterLabel: (context) => {
                                const lang = topLanguages[context.dataIndex];
                                return `Percentage: ${lang.percentage}%`;
                            }
                        }
                    }
                }
            }
        });
    }

    updateTimelineChart(range = null) {
        const canvas = document.getElementById('timelineChart');
        let { timeframe } = this.data;
        
        if (!canvas) {
            console.warn('Timeline chart canvas not found');
            return;
        }

        // If range is specified, fetch new data
        if (range && range !== timeframe?.range) {
            this.fetchTimeframeStats(range).then(data => {
                this.data.timeframe = data;
                this.updateTimelineChart();
            }).catch(console.error);
            return;
        }

        if (!timeframe?.data) {
            console.warn('No timeline data available');
            return;
        }

        // Destroy existing chart
        if (this.charts.timeline) {
            this.charts.timeline.destroy();
        }

        const ctx = canvas.getContext('2d');
        
        this.charts.timeline = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeframe.data.map(item => item.period),
                datasets: [{
                    label: 'Activities',
                    data: timeframe.data.map(item => item.count),
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        titleCallback: (tooltipItems) => {
                            return `Period: ${tooltipItems[0].label}`;
                        }
                    }
                }
            }
        });
    }

    async exportStatistics() {
        try {
            console.log('Starting export...');
            this.showExportLoading(true);
            
            const exportData = await this.fetchWithAuth('/api/stats/export');
            
            // Convert to CSV and download
            this.downloadAsExcel(exportData);
            
            this.showToast('Success', 'Statistics exported successfully', 'success');
            
        } catch (error) {
            console.error('Export error:', error);
            this.showToast('Error', 'Error exporting statistics: ' + error.message, 'error');
        } finally {
            this.showExportLoading(false);
        }
    }

    downloadAsExcel(data) {
        // Create CSV content
        let csvContent = "data:text/csv;charset=utf-8,";
        
        // Add headers
        csvContent += "User ID,Username,Email,Role,Account Type,Status,Created At,Total Notifications,Unread Notifications\n";
        
        // Add data rows
        data.data.forEach(user => {
            const row = [
                user.user_id,
                user.username,
                user.email,
                user.role,
                user.account_type,
                user.status,
                user.created_at,
                user.notification_count,
                user.unread_notifications
            ];
            csvContent += row.map(field => `"${field}"`).join(',') + '\n';
        });

        // Create download link
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', `grammar_checker_stats_${new Date().toISOString().split('T')[0]}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    showLoading(show) {
        const loading = document.getElementById('dashboardLoading');
        const error = document.getElementById('dashboardError');
        
        if (loading) {
            loading.classList.toggle('hidden', !show);
        }
        if (error) {
            error.classList.add('hidden');
        }
    }

    showError(show) {
        const loading = document.getElementById('dashboardLoading');
        const error = document.getElementById('dashboardError');
        
        if (loading) {
            loading.classList.add('hidden');
        }
        if (error) {
            error.classList.toggle('hidden', !show);
        }
    }

    showExportLoading(show) {
        const exportBtn = document.getElementById('exportStatsBtn');
        if (exportBtn) {
            const icon = exportBtn.querySelector('i');
            
            if (show) {
                exportBtn.disabled = true;
                icon.className = 'fas fa-spinner fa-spin';
                exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Exporting...';
            } else {
                exportBtn.disabled = false;
                icon.className = 'fas fa-download';
                exportBtn.innerHTML = '<i class="fas fa-download"></i> Export Excel';
            }
        }
    }

    // Toast notification function
    showToast(title, message, type = 'info', duration = 5000) {
        const container = document.getElementById('toastContainer');
        if (!container) {
            console.log('Toast:', title, '-', message);
            return;
        }

        const toastId = 'toast-' + Date.now();
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.id = toastId;
        
        const icons = {
            success: '✅',
            error: '❌', 
            warning: '⚠️',
            info: 'ℹ️'
        };

        toast.innerHTML = `
            <div class="toast-content">
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">
                    <div class="toast-title">${title}</div>
                    <div class="toast-text">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.parentElement.remove()">&times;</button>
            </div>
            <div class="toast-progress ${type}"></div>
        `;

        container.appendChild(toast);

        setTimeout(() => {
            if (document.getElementById(toastId)) {
                document.getElementById(toastId).remove();
            }
        }, duration);
    }
}

// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing dashboard...');
  if (!window.__dashboardInitialized) {
    window.__dashboardInitialized = true;
    new DashboardManager();
  }
});
```

### frontend\public\js\introduction\demoHandler.js
```js
// demoHandler.js - Xử lý demo kiểm tra ngữ pháp

import { showToast } from './utils.js';
import { validateLanguageMatch, LANGUAGE_NAMES } from './languageUtils.js';
import { 
    getCurrentUsage, 
    getRemainingUsage, 
    hasRemainingUsage, 
    incrementUsage,
    getMaxFreeUsage 
} from './usageManager.js';
import { 
    performDemoGrammarCheck, 
    updateTextStats, 
    displayResults 
} from './grammarChecker.js';
import { showUsageLimitModal } from './uiComponents.js';

// Main demo grammar check function
export async function checkDemoGrammar() {
    const demoText = document.getElementById('demoText');
    const demoLanguage = document.getElementById('demoLanguage');
    const demoResults = document.getElementById('demoResults');
    const demoErrorsList = document.getElementById('demoErrorsList');
    const demoIssueCount = document.getElementById('demoIssueCount');
    const remainingUsesEl = document.getElementById('remainingUses');
    const demoCheckBtn = document.getElementById('demoCheckBtn');
    
    // Validate input
    if (!demoText || !demoText.value.trim()) {
        showToast('⚠️ Please enter some text to check.', 'error');
        return;
    }
    
    const text = demoText.value.trim();
    const language = demoLanguage ? demoLanguage.value : 'en-US';
    
    // Check usage limits
    if (!hasRemainingUsage()) {
        const maxUsage = getMaxFreeUsage();
        showToast(`⚠️ Free usage limit reached (${maxUsage}/${maxUsage}). Please register or login to continue.`, 'error');
        showUsageLimitModal();
        return;
    }
    
    // Language validation
    if (!validateLanguageMatch(text, language)) {
        const detectedLang = detectLanguage(text);
        showToast(
            `⚠️ Language mismatch: Text appears to be ${LANGUAGE_NAMES[detectedLang] || 'unknown'} but ${LANGUAGE_NAMES[language]} is selected.`, 
            'error'
        );
        return;
    }
    
    try {
        // Show loading state
        if (demoCheckBtn) {
            demoCheckBtn.disabled = true;
            demoCheckBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
        }
        
        // Perform grammar check
        const result = await performDemoGrammarCheck(text, language);
        
        if (result.success) {
            // Update usage count
            incrementUsage();
            
            const remaining = getRemainingUsage();
            if (remainingUsesEl) {
                remainingUsesEl.textContent = remaining;
            }
            
            // Show success message
            if (remaining > 0) {
                showToast(`✅ Grammar check completed! ${remaining} free checks remaining.`, 'success');
            } else {
                showToast('✅ Grammar check completed! This was your last free check.', 'info');
            }
            
            // Update stats
            updateTextStats(text);
            
            const matches = result.data.matches;
            if (demoIssueCount) demoIssueCount.textContent = matches.length;
            
            // Display results
            if (demoResults) demoResults.style.display = 'block';
            if (demoErrorsList) {
                displayResults(matches, demoErrorsList);
            }
            
        } else {
            showToast('❌ Grammar check failed. Please try again.', 'error');
        }
        
    } catch (error) {
        console.error('Demo grammar check failed:', error);
        showToast('❌ Error: ' + error.message, 'error');
    } finally {
        // Reset button state
        if (demoCheckBtn) {
            demoCheckBtn.disabled = false;
            demoCheckBtn.innerHTML = '<i class="fas fa-check-circle"></i> Check Grammar';
        }
    }
}
```

### frontend\public\js\introduction\grammarChecker.js
```js
// grammarChecker.js - Logic kiểm tra ngữ pháp demo

// Mock grammar errors for demo
const DEMO_ERRORS = [
    {
        pattern: /there house/gi,
        message: "Did you mean 'their house'?",
        original: "there house",
        suggestion: "their house",
        type: "Grammar"
    },
    {
        pattern: /alot/gi,
        message: "Did you mean 'a lot'?",
        original: "alot",
        suggestion: "a lot", 
        type: "Spelling"
    },
    {
        pattern: /your welcome/gi,
        message: "Did you mean 'you're welcome'?",
        original: "your welcome",
        suggestion: "you're welcome",
        type: "Grammar"
    }
];

// Find errors in text
function findErrors(text) {
    const errors = [];
    
    // Check for predefined errors
    DEMO_ERRORS.forEach(errorDef => {
        const matches = [...text.matchAll(errorDef.pattern)];
        matches.forEach(match => {
            errors.push({
                message: errorDef.message,
                original: errorDef.original,
                suggestion: errorDef.suggestion,
                type: errorDef.type,
                offset: match.index
            });
        });
    });
    
    // Check for missing capitals at sentence start
    const sentences = text.split(/[.!?]+/).filter(s => s.trim());
    sentences.forEach((sentence, index) => {
        const trimmed = sentence.trim();
        if (trimmed && trimmed[0] !== trimmed[0].toUpperCase()) {
            errors.push({
                message: "Sentence should start with a capital letter",
                original: trimmed[0],
                suggestion: trimmed[0].toUpperCase(),
                type: "Capitalization",
                offset: text.indexOf(trimmed)
            });
        }
    });
    
    return errors;
}

// Simulate API call for grammar checking
export async function performDemoGrammarCheck(text, language) {
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const mockErrors = findErrors(text);
    
    return {
        success: true,
        data: {
            matches: mockErrors,
            text: text
        }
    };
}

// Update text statistics
export function updateTextStats(text) {
    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const chars = text.length;
    
    const wordCountEl = document.getElementById('demoWordCount');
    const charCountEl = document.getElementById('demoCharCount');
    
    if (wordCountEl) wordCountEl.textContent = words;
    if (charCountEl) charCountEl.textContent = chars;
    
    return { words, chars };
}

// Display grammar check results
export function displayResults(matches, container) {
    if (!container) return;
    
    if (matches.length === 0) {
        container.innerHTML = `
            <div class="demo-no-errors">
                🎉 Great! No grammar issues found in your text.
            </div>
        `;
    } else {
        container.innerHTML = matches.map((match, index) => `
            <div class="demo-error-item">
                <div class="demo-error-type">${match.type || 'Grammar'}</div>
                <div class="demo-error-message"><strong>Issue:</strong> ${match.message}</div>
                <div class="demo-suggestion">
                    <strong>Original:</strong> <span style="background: #ffebee; padding: 2px 6px; border-radius: 3px; color: #c62828;">"${match.original}"</span> → 
                    <strong>Suggestion:</strong> <span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; color: #2e7d32;">"${match.suggestion}"</span>
                </div>
            </div>
        `).join('');
    }
}
```

### frontend\public\js\introduction\intro-main.js
```js
// main.js - File chính được tối ưu hóa

import { showToast, showCustomAlert, isLoggedIn } from './utils.js';
import { getRemainingUsage, getMaxFreeUsage } from './usageManager.js';
import { 
    initSmoothScrolling, 
    initAccordion, 
    updateButtonVisibility,
    initPageTransitions,
    showUsageLimitModal,
    closeUsageLimitModal 
} from './uiComponents.js';
import { checkDemoGrammar } from './demoHandler.js';

// Event handlers for buttons
function setupButtonHandlers() {
    const tryItFreeBtn = document.getElementById('tryItFreeBtn');
    const learnMoreBtn = document.getElementById('learnMoreBtn');
    const checkGrammarNav = document.getElementById('checkGrammarNav');
    const upgradeAccountBtn = document.getElementById('upgradeAccountBtn');
    const goToRegisterBtn = document.getElementById('goToRegisterBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');

    // Try it Free Button
    if (tryItFreeBtn) {
        tryItFreeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            
            const remaining = getRemainingUsage();
            const maxUsage = getMaxFreeUsage();
            
            if (remaining > 0) {
                showToast(`You have ${remaining} free uses left. Redirecting to grammar checker...`, 'info', 2000);
                setTimeout(() => {
                    window.location.href = '/GrammarChecker1.html';
                }, 2000);
            } else {
                showToast(`You have run out of uses (${maxUsage}/${maxUsage}), you need to register an account.`, 'error', 5000);
                showUsageLimitModal();
            }
        });
    }

    // Learn More Button - scroll to about section
    if (learnMoreBtn) {
        learnMoreBtn.addEventListener('click', (e) => {
            e.preventDefault();
            const aboutSection = document.getElementById('about');
            if (aboutSection) {
                const headerHeight = document.querySelector('header')?.offsetHeight || 0;
                const targetPosition = aboutSection.offsetTop - headerHeight - 20;
                
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    }

    // Check Grammar Navigation
    if (checkGrammarNav) {
        checkGrammarNav.addEventListener('click', (e) => {
            e.preventDefault();
            if (isLoggedIn()) {
                window.location.href = '/GrammarChecker1.html';
            } else {
                showCustomAlert("Please log in to access the full grammar checker.", 'info', 3000);
                setTimeout(() => {
                    window.location.href = '/login.html?redirect=/GrammarChecker1.html&message=login_required';
                }, 1500);
            }
        });
    }

    // Upgrade Button
    if (upgradeAccountBtn) {
        upgradeAccountBtn.addEventListener('click', (e) => {
            e.preventDefault();
            showCustomAlert("This feature is coming soon! Stay tuned for premium plans.", 'info');
        });
    }

    // Modal handlers
    if (goToRegisterBtn) {
        goToRegisterBtn.addEventListener('click', () => {
            closeUsageLimitModal();
            window.location.href = '/index.html';
        });
    }

    if (closeModalBtn) {
        closeModalBtn.addEventListener('click', closeUsageLimitModal);
    }
}

// Setup modal event listeners
function setupModalHandlers() {
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('close') && e.target.dataset.modal === 'usageLimitModal') {
            closeUsageLimitModal();
        }
    });

    window.addEventListener('click', (event) => {
        const modal = document.getElementById('usageLimitModal');
        if (event.target === modal) {
            closeUsageLimitModal();
        }
    });
}

// Main initialization function
function initializeApp() {
    console.log('🚀 Initializing Enhanced AI Grammar Editor...');
    
    initSmoothScrolling();
    initAccordion();
    updateButtonVisibility();
    initPageTransitions();
    
    setupButtonHandlers();
    setupModalHandlers();
    
    const demoCheckBtn = document.getElementById('demoCheckBtn');
    if (demoCheckBtn) {
        demoCheckBtn.addEventListener('click', checkDemoGrammar);
    }
    
    console.log('✅ Enhanced AI Grammar Editor initialization complete');
}

// Main DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', initializeApp);

window.showToast = showToast;
window.showCustomAlert = showCustomAlert;
window.closeUsageLimitModal = closeUsageLimitModal;
```

### frontend\public\js\introduction\languageUtils.js
```js
// languageUtils.js - Xử lý phát hiện và validate ngôn ngữ

// Language detection patterns
const LANGUAGE_PATTERNS = {
    'de-DE': /[äöüßÄÖÜ]|ich|der|die|das|und|ist|sind/gi,
    'fr': /[àâäéèêëïîôöùûüÿç]|je|le|la|les|et|est|sont/gi,
    'es': /[ñáéíóúü]|el|la|los|las|y|es|son/gi,
    'nl': /ij|zij|wij|de|het|en|is|zijn/gi
};

// Language names mapping
export const LANGUAGE_NAMES = {
    'en-US': 'English (US)',
    'en-GB': 'English (UK)', 
    'de-DE': 'German',
    'fr': 'French',
    'es': 'Spanish',
    'nl': 'Dutch'
};

// Detect language based on text content
export function detectLanguage(text) {
    for (const [lang, pattern] of Object.entries(LANGUAGE_PATTERNS)) {
        if (pattern.test(text)) {
            return lang;
        }
    }
    return 'en-US';
}

// Validate if text matches selected language
export function validateLanguageMatch(text, selectedLanguage) {
    const detectedLanguage = detectLanguage(text);
    
    // Handle English variants
    if ((selectedLanguage === 'en-US' || selectedLanguage === 'en-GB') && 
        (detectedLanguage === 'en-US' || detectedLanguage === 'en-GB')) {
        return true;
    }
    
    return detectedLanguage === selectedLanguage;
}
```

### frontend\public\js\introduction\uiComponents.js
```js
// uiComponents.js - Các component và tương tác UI

import { isLoggedIn } from './utils.js';

// Modal Functions
export function showUsageLimitModal() {
    const modal = document.getElementById('usageLimitModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

export function closeUsageLimitModal() {
    const modal = document.getElementById('usageLimitModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Smooth scrolling for navigation links
export function initSmoothScrolling() {
    const navLinks = document.querySelectorAll('nav a[href^="#"]');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
                const headerHeight = document.querySelector('header').offsetHeight;
                const targetPosition = targetElement.offsetTop - headerHeight - 20;
                
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    });
}

// Initialize accordion functionality
export function initAccordion() {
    const accordionHeaders = document.querySelectorAll('.accordion-header');
    accordionHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const content = header.nextElementSibling;
            const isActive = header.classList.contains('active');
            
            // Close all other accordions
            accordionHeaders.forEach(h => {
                h.classList.remove('active');
                const c = h.nextElementSibling;
                if (c) c.style.maxHeight = '0';
            });
            
            // Toggle current accordion
            if (!isActive) {
                header.classList.add('active');
                if (content) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            }
        });
    });
}

// Update button visibility based on login status
export function updateButtonVisibility() {
    const tryItFreeBtn = document.getElementById('tryItFreeBtn');
    const upgradeAccountBtn = document.getElementById('upgradeAccountBtn');
    const authButtons = document.querySelector('.auth-buttons');
    
    const loggedIn = isLoggedIn();
    
    if (tryItFreeBtn) tryItFreeBtn.style.display = loggedIn ? 'none' : 'inline-block';
    if (upgradeAccountBtn) upgradeAccountBtn.style.display = loggedIn ? 'inline-block' : 'none';
    if (authButtons) authButtons.style.display = loggedIn ? 'none' : 'flex';
}

// Add page transition effects
export function initPageTransitions() {
    const links = document.querySelectorAll('a[href]:not([href^="#"]):not([target="_blank"])');
    links.forEach(link => {
        link.addEventListener('click', (e) => {
            if (link.onclick) return; // Skip if has custom onclick
            
            e.preventDefault();
            const href = link.getAttribute('href');
            
            // Add fade out effect
            document.body.style.opacity = '0.7';
            document.body.style.transition = 'opacity 0.3s ease';
            
            setTimeout(() => {
                window.location.href = href;
            }, 300);
        });
    });
}
```

### frontend\public\js\introduction\usageManager.js
```js
// usageManager.js 

const USAGE_KEY = 'freeUsageCount';
const MAX_FREE_USAGE = 3;

// Get current usage count
export function getCurrentUsage() {
    return parseInt(localStorage.getItem(USAGE_KEY) || '0');
}

export function getRemainingUsage() {
    return Math.max(0, MAX_FREE_USAGE - getCurrentUsage());
}

export function hasRemainingUsage() {
    return getCurrentUsage() < MAX_FREE_USAGE;
}

export function incrementUsage() {
    const currentUsage = getCurrentUsage();
    const newUsage = currentUsage + 1;
    localStorage.setItem(USAGE_KEY, newUsage.toString());
    return newUsage;
}

export function resetUsage() {
    localStorage.removeItem(USAGE_KEY);
    return 0;
}

export function getMaxFreeUsage() {
    return MAX_FREE_USAGE;
}

export function updateRemainingUsesDisplay() {
    const remainingUsesEl = document.getElementById('remainingUses');
    if (remainingUsesEl) {
        remainingUsesEl.textContent = getRemainingUsage();
    }
}
```

### frontend\public\js\introduction\utils.js
```js
// utils.js 

// Toast notification system
export function showToast(message, type = 'success', duration = 4000) {
    const existingToasts = document.querySelectorAll('.toast');
    existingToasts.forEach(toast => toast.remove());
    
    const toast = document.createElement('div');
    toast.className = `toast show ${type}`;
    toast.innerHTML = `<span id="toastMessage">${message}</span>`;
    
    const colors = {
        error: '#e74c3c',
        info: '#3498db',
        success: '#27ae60'
    };
    
    toast.style.backgroundColor = colors[type] || colors.success;
    toast.style.cssText += `
        position: fixed;
        bottom: 30px;
        right: 30px;
        color: white;
        padding: 16px 20px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 9999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        min-width: 300px;
        text-align: center;
        visibility: visible;
        opacity: 1;
        transform: translateX(0);
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        if (toast.parentNode) {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }
    }, duration);
}

export function showLoading(show = true) {
    let overlay = document.getElementById('loadingOverlay');
    
    if (overlay) {
        overlay.style.display = show ? 'flex' : 'none';
    }
}

export function showCustomAlert(message, type = 'info', duration = 3000) {
    showToast(message, type, duration);
}

export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Check if user is logged in
export function isLoggedIn() {
    return localStorage.getItem('loggedInAs') !== null;
}
```
