# ==================================================
# Path: D:\buituan\project\Grammar_Checker
# Detected tech: angular, javascript, python, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
Grammar_Checker/
â”œâ”€â”€ .git/
â”œâ”€â”€ .vscode/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ grammar_checkers/
â”‚   â”‚   â”œâ”€â”€ rules/
â”‚   â”‚   â”‚   â”œâ”€â”€ chinese_rules.json
â”‚   â”‚   â”‚   â”œâ”€â”€ italian_rules.json
â”‚   â”‚   â”‚   â”œâ”€â”€ japanese_rules.json
â”‚   â”‚   â”‚   â”œâ”€â”€ russian_rules.json
â”‚   â”‚   â”‚   â””â”€â”€ spanish_rules.json
â”‚   â”‚   â”œâ”€â”€ chineseChecker.js
â”‚   â”‚   â”œâ”€â”€ index.js
â”‚   â”‚   â”œâ”€â”€ italianChecker.js
â”‚   â”‚   â”œâ”€â”€ japaneseChecker.js
â”‚   â”‚   â”œâ”€â”€ russianChecker.js
â”‚   â”‚   â””â”€â”€ spanishChecker.js
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ grammar.js
â”‚   â”‚   â”œâ”€â”€ notificationRoutes.js
â”‚   â”‚   â”œâ”€â”€ statsRoutes.js
â”‚   â”‚   â”œâ”€â”€ usageRoutes.js
â”‚   â”‚   â””â”€â”€ userRoutes.js
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ cohereService.js
â”‚   â”‚   â”œâ”€â”€ languageDetectionService.js
â”‚   â”‚   â”œâ”€â”€ languageToolService.js
â”‚   â”‚   â”œâ”€â”€ libreTranslateService.js
â”‚   â”‚   â””â”€â”€ notificationCleanup.js
â”‚   â””â”€â”€ server.js
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€ public/
â”‚       â”œâ”€â”€ css/
â”‚       â”‚   â”œâ”€â”€ admin/
â”‚       â”‚   â”‚   â”œâ”€â”€ badges.css
â”‚       â”‚   â”‚   â”œâ”€â”€ base.css
â”‚       â”‚   â”‚   â”œâ”€â”€ buttons.css
â”‚       â”‚   â”‚   â”œâ”€â”€ cards.css
â”‚       â”‚   â”‚   â”œâ”€â”€ checkboxes.css
â”‚       â”‚   â”‚   â”œâ”€â”€ dashboard.css
â”‚       â”‚   â”‚   â”œâ”€â”€ forms.css
â”‚       â”‚   â”‚   â”œâ”€â”€ header.css
â”‚       â”‚   â”‚   â”œâ”€â”€ main.css
â”‚       â”‚   â”‚   â”œâ”€â”€ modals.css
â”‚       â”‚   â”‚   â”œâ”€â”€ notifications.css
â”‚       â”‚   â”‚   â”œâ”€â”€ responsive.css
â”‚       â”‚   â”‚   â””â”€â”€ tables.css
â”‚       â”‚   â”œâ”€â”€ grammar-checker/
â”‚       â”‚   â”‚   â”œâ”€â”€ buttons.css
â”‚       â”‚   â”‚   â”œâ”€â”€ contact-footer.css
â”‚       â”‚   â”‚   â”œâ”€â”€ feature-grids.css
â”‚       â”‚   â”‚   â”œâ”€â”€ forms-controls.css
â”‚       â”‚   â”‚   â”œâ”€â”€ grammar-panels.css
â”‚       â”‚   â”‚   â”œâ”€â”€ header-navigation.css
â”‚       â”‚   â”‚   â”œâ”€â”€ main.css
â”‚       â”‚   â”‚   â”œâ”€â”€ modals-messages.css
â”‚       â”‚   â”‚   â”œâ”€â”€ panels-sections.css
â”‚       â”‚   â”‚   â”œâ”€â”€ reset-base.css
â”‚       â”‚   â”‚   â”œâ”€â”€ responsive.css
â”‚       â”‚   â”‚   â”œâ”€â”€ user-dropdown-responsive.css
â”‚       â”‚   â”‚   â”œâ”€â”€ utilities-animations.css
â”‚       â”‚   â”‚   â””â”€â”€ variables.css
â”‚       â”‚   â”œâ”€â”€ introduction/
â”‚       â”‚   â”‚   â”œâ”€â”€ base.css
â”‚       â”‚   â”‚   â”œâ”€â”€ buttons.css
â”‚       â”‚   â”‚   â”œâ”€â”€ demo.css
â”‚       â”‚   â”‚   â”œâ”€â”€ faq.css
â”‚       â”‚   â”‚   â”œâ”€â”€ features.css
â”‚       â”‚   â”‚   â”œâ”€â”€ footer.css
â”‚       â”‚   â”‚   â”œâ”€â”€ header.css
â”‚       â”‚   â”‚   â”œâ”€â”€ hero.css
â”‚       â”‚   â”‚   â”œâ”€â”€ main.css
â”‚       â”‚   â”‚   â”œâ”€â”€ modals.css
â”‚       â”‚   â”‚   â”œâ”€â”€ responsive.css
â”‚       â”‚   â”‚   â”œâ”€â”€ sidebar.css
â”‚       â”‚   â”‚   â””â”€â”€ testimonials.css
â”‚       â”‚   â””â”€â”€ style/
â”‚       â”‚       â”œâ”€â”€ accessibility.css
â”‚       â”‚       â”œâ”€â”€ animations.css
â”‚       â”‚       â”œâ”€â”€ brand.css
â”‚       â”‚       â”œâ”€â”€ buttons.css
â”‚       â”‚       â”œâ”€â”€ decorations.css
â”‚       â”‚       â”œâ”€â”€ forms.css
â”‚       â”‚       â”œâ”€â”€ layout.css
â”‚       â”‚       â”œâ”€â”€ main.css
â”‚       â”‚       â”œâ”€â”€ navigation.css
â”‚       â”‚       â”œâ”€â”€ reset.css
â”‚       â”‚       â”œâ”€â”€ responsive.css
â”‚       â”‚       â”œâ”€â”€ utilities.css
â”‚       â”‚       â””â”€â”€ variables.css
â”‚       â”œâ”€â”€ images/
â”‚       â”‚   â”œâ”€â”€ Logo.jpg
â”‚       â”‚   â”œâ”€â”€ facebook-icon.png
â”‚       â”‚   â”œâ”€â”€ future.jpg
â”‚       â”‚   â”œâ”€â”€ instagram-icon.png
â”‚       â”‚   â”œâ”€â”€ linkedin-icon.png
â”‚       â”‚   â”œâ”€â”€ starry-sky.jpg
â”‚       â”‚   â”œâ”€â”€ student.jpg
â”‚       â”‚   â”œâ”€â”€ tiktok-icon.png
â”‚       â”‚   â”œâ”€â”€ trang tri.jpg
â”‚       â”‚   â”œâ”€â”€ twitter-icon.png
â”‚       â”‚   â””â”€â”€ web-icon.png
â”‚       â”œâ”€â”€ js/
â”‚       â”‚   â”œâ”€â”€ admin/
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-api.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-auth.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-config.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-dashboard.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-debug.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-events.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-forms.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-main.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-modals.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-state.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-storage.js
â”‚       â”‚   â”‚   â”œâ”€â”€ admin-ui.js
â”‚       â”‚   â”‚   â””â”€â”€ admin-utils.js
â”‚       â”‚   â”œâ”€â”€ introduction/
â”‚       â”‚   â”‚   â”œâ”€â”€ demoHandler.js
â”‚       â”‚   â”‚   â”œâ”€â”€ grammarChecker.js
â”‚       â”‚   â”‚   â”œâ”€â”€ intro-main.js
â”‚       â”‚   â”‚   â”œâ”€â”€ sidebar.js
â”‚       â”‚   â”‚   â”œâ”€â”€ uiComponents.js
â”‚       â”‚   â”‚   â”œâ”€â”€ usageManager.js
â”‚       â”‚   â”‚   â””â”€â”€ utils.js
â”‚       â”‚   â”œâ”€â”€ GrammarChecker1.js
â”‚       â”‚   â”œâ”€â”€ api.js
â”‚       â”‚   â”œâ”€â”€ authManager.js
â”‚       â”‚   â”œâ”€â”€ bootstrap.bundle.min.js
â”‚       â”‚   â”œâ”€â”€ index.js
â”‚       â”‚   â”œâ”€â”€ login.js
â”‚       â”‚   â”œâ”€â”€ notifications.js
â”‚       â”‚   â””â”€â”€ utils.js
â”‚       â”œâ”€â”€ GrammarChecker1.html
â”‚       â”œâ”€â”€ admin-dashboard.html
â”‚       â”œâ”€â”€ admin.html
â”‚       â”œâ”€â”€ index.html
â”‚       â”œâ”€â”€ introduction.html
â”‚       â””â”€â”€ login.html
â”œâ”€â”€ node_modules/
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ cleanup_usage_logs.sql
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â””â”€â”€ source_dump.txt
```

## FILE CONTENTS

### backend\server.js
```js
// backend/server.js
import express from 'express';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import compression from 'compression';
import sql from 'mssql';
import dotenv from 'dotenv';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';

// Import routes & services
import notificationRoutes from './routes/notificationRoutes.js';
import { startNotificationCleanup } from './services/notificationCleanup.js';
import statsRoutes from './routes/statsRoutes.js';
import grammarRoutes from './routes/grammar.js';
import userRoutes from './routes/userRoutes.js';
import usageRoutes from './routes/usageRoutes.js';
import languageToolService from './services/languageToolService.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, '../.env') });

const app = express();
const PORT = process.env.PORT || 3000;

// === SQL CONFIGURATION ===
const dbConfig = {
  server: process.env.DB_SERVER,
  database: process.env.DB_DATABASE,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  options: {
    encrypt: false,
    trustServerCertificate: true,
    instanceName: process.env.DB_INSTANCE
  }
};

if (dbConfig.user?.trim() && dbConfig.password?.trim()) {
  dbConfig.options.trustedConnection = false;
} else {
  dbConfig.options.trustedConnection = true;
}

console.log('â¡ï¸ Connecting to SQL Server with config:');
console.log('Server:', dbConfig.server);
console.log('Database:', dbConfig.database);
if (dbConfig.user) console.log('User:', dbConfig.user);
console.log(
  'Authentication:',
  dbConfig.options.trustedConnection
    ? 'Windows Authentication'
    : 'SQL Server Authentication'
);

// === CONNECT TO DATABASE ===
async function connectToDatabase() {
  try {
    const pool = new sql.ConnectionPool(dbConfig);
    await pool.connect();
    app.locals.db = pool;
    console.log('âœ… Connected to SQL Server database.');
    startNotificationCleanup(pool);
  } catch (err) {
    console.error('âŒ Database connection failed:', err);
    process.exit(1);
  }
}

// === LANGUAGE TOOL WARMUP ===
async function warmupLanguageTool() {
  console.log('\nğŸ”¥ Waiting for LanguageTool to be ready...');

  const maxRetries = 15;
  const retryDelay = 1000;
  let retries = 0;
  let ready = false;

  while (!ready && retries < maxRetries) {
    try {
      const response = await fetch('http://localhost:8081/v2/languages', {
        signal: AbortSignal.timeout(5000)
      });
      if (response.ok) {
        ready = true;
        console.log('âœ… LanguageTool is ready!\n');
      }
    } catch {
      retries++;
      if (retries < maxRetries) {
        process.stdout.write(`   Attempt ${retries}/${maxRetries}...\r`);
        await new Promise((r) => setTimeout(r, retryDelay));
      }
    }
  }

  if (!ready) {
    console.warn('âš ï¸ LanguageTool did not start in time. Skipping warmup.\n');
    return;
  }

  console.log('=== LanguageTool Warmup Starting ===');
  const testTexts = [
    { text: 'Hello world', lang: 'en-US', name: 'English (US)' },
    { text: 'Bonjour le monde', lang: 'fr', name: 'French' },
    { text: 'Hallo Welt', lang: 'de-DE', name: 'German' },
    { text: 'Hola mundo', lang: 'es', name: 'Spanish' },
    { text: 'OlÃ¡ mundo', lang: 'pt', name: 'Portuguese' },
    { text: 'Ciao mondo', lang: 'it', name: 'Italian' },
    { text: 'ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€', lang: 'ru-RU', name: 'Russian' },
    { text: 'ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ', lang: 'ja-JP', name: 'Japanese' },
    { text: 'ä½ å¥½ä¸–ç•Œ', lang: 'zh-CN', name: 'Chinese' }
  ];

  const results = await Promise.allSettled(
    testTexts.map(async ({ text, lang, name }) => {
      const start = Date.now();
      try {
        await languageToolService.checkGrammar(text, lang);
        const time = Date.now() - start;
        return { name, lang, time, success: true };
      } catch (err) {
        return { name, lang, success: false, error: err.message };
      }
    })
  );

  const successCount = results.filter(
    (r) => r.status === 'fulfilled' && r.value.success
  ).length;

  console.log(`\nâœ… Warmup complete: ${successCount}/${testTexts.length} ready`);
  console.log('=== LanguageTool Ready ===\n');
}

// === MIDDLEWARE ===
app.use(cors());
app.use(compression());
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https:"],
      styleSrc: ["'self'", "'unsafe-inline'", "https:"],
      fontSrc: ["'self'", "https:", "data:"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https:"],
    },
  },
}));

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests. Try again later.',
});
app.use('/api/', limiter);

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// === STATIC FILES ===
app.use(express.static(path.join(__dirname, '../frontend/public'), {
  setHeaders: (res, filePath) => {
    if (filePath.endsWith('.js')) res.setHeader('Content-Type', 'application/javascript');
    if (filePath.includes('admin')) res.setHeader('Access-Control-Allow-Origin', '*');
  },
}));

// === ROUTES ===
app.get('/', (req, res) => {
  console.log(`Request to ${req.path} from ${req.ip}`);
  res.sendFile(path.join(__dirname, '../frontend/public/introduction.html'));
});

app.use('/api/grammar', grammarRoutes);
app.use('/api/users', userRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/stats', statsRoutes);
app.use('/api/usage', usageRoutes);

// === HEALTH & DEBUG ===
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

app.get('/api/check', (req, res) => {
  res.json({ status: 'ok', message: 'API is running.' });
});

app.get('/api/debug/db', async (req, res) => {
  try {
    if (!req.app.locals.db) throw new Error('DB not connected');
    const result = await req.app.locals.db.request().query('SELECT COUNT(*) AS users FROM Users');
    res.json({ success: true, userCount: result.recordset[0].users });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// === GLOBAL ERROR HANDLER ===
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ success: false, message: err.message });
});

// === START SERVER ===
(async () => {
  try {
    await connectToDatabase();
    
    app.listen(PORT, async () => {
      console.log(`ğŸš€ Server running on port ${PORT}`);
      console.log(`ğŸ“Š Admin panel: http://localhost:${PORT}/admin.html`);
      console.log(`ğŸ” API check: http://localhost:${PORT}/api/check`);
      console.log(`ğŸ§  DB debug: http://localhost:${PORT}/api/debug/db`);

      if (!process.env.COHERE_API_KEY) {
        console.warn('âš ï¸ COHERE_API_KEY not found. Cohere will not be used.');
      }

      await warmupLanguageTool().catch((e) =>
        console.warn('LanguageTool warmup skipped:', e.message)
      );
    });
  } catch (err) {
    console.error('âŒ Failed to start server:', err.message);
    process.exit(1);
  }
})();
```

### backend\grammar_checkers\chineseChecker.js
```js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class ChineseGrammarChecker {
  constructor() {
    this.rules = this.loadRules();
    this.measureRules = {
      'è‹¹æœ': ['ä¸ª'],
      'é±¼': ['æ¡'],
      'ä¹¦': ['æœ¬'],
      'çŒ«': ['åª'],
      'ç‹—': ['åª'],
      'é¸¡': ['åª'],
      'äºº': ['ä¸ª'],
      'ä¸œè¥¿': ['ä¸ª'],
      'é—®é¢˜': ['ä¸ª'],
      'å­¦ç”Ÿ': ['ä¸ª'],
      'å¥³å­©': ['ä¸ª'],
      'ç”·å­©': ['ä¸ª']
    };
  }

  loadRules() {
    try {
      const rulesPath = path.join(__dirname, 'rules', 'chinese_rules.json');
      const rulesContent = fs.readFileSync(rulesPath, 'utf-8');
      return JSON.parse(rulesContent);
    } catch (error) {
      console.error('âŒ Failed to load Chinese rules:', error.message);
      return { measureWords: {}, particles: {}, errorPatterns: [], commonMistakes: [], nounExamples: [] };
    }
  }

  check(text) {
    const errors = [];
    this.checkDuplicateParticles(text, errors);
    this.checkMeasureWordsAdvanced(text, errors);
    return this.deduplicateErrors(errors);
  }

  checkDuplicateParticles(text, errors) {
    // Check for duplicate çš„
    let match;
    const dePattern = /çš„{2,}/g;
    while ((match = dePattern.exec(text)) !== null) {
      errors.push({
        message: 'Duplicate particle \'çš„\'',
        shortMessage: 'Duplicate word',
        offset: match.index,
        length: match[0].length,
        replacements: [{ value: 'çš„' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Check for duplicate äº†
    const lePattern = /äº†{2,}/g;
    while ((match = lePattern.exec(text)) !== null) {
      errors.push({
        message: 'Duplicate particle \'äº†\'',
        shortMessage: 'Duplicate word',
        offset: match.index,
        length: match[0].length,
        replacements: [{ value: 'äº†' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Check for duplicate åœ¨
    const zaiPattern = /åœ¨{2,}/g;
    while ((match = zaiPattern.exec(text)) !== null) {
      errors.push({
        message: 'Duplicate particle \'åœ¨\'',
        shortMessage: 'Duplicate word',
        offset: match.index,
        length: match[0].length,
        replacements: [{ value: 'åœ¨' }],
        type: { typeName: 'Grammar' }
      });
    }
  }

  checkMeasureWordsAdvanced(text, errors) {
    // Split by common separators but preserve position info
    const separators = ['å’Œ', 'ã€', 'ï¼Œ', ',', 'ä¸'];
    
    // Find all number + measureword + noun patterns anywhere in text
    const allPatterns = /([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å0-9é›¶]+)\s*([ä¸ªæœ¬åªè¾†ä»¶å¼ æ¡å¯¹é˜Ÿç»„å—ç‰‡åœºç§æ—ç¾¤]?)\s*([^\s\dä¸ªæœ¬åªè¾†ä»¶å¼ æ¡å¯¹é˜Ÿç»„å—ç‰‡åœºç§æ—ç¾¤ï¼Œã€ã€‚!ï¼?ï¼Ÿï¼›:ï¼š]+)/g;
    
    let match;
    const processedOffsets = new Set();

    while ((match = allPatterns.exec(text)) !== null) {
      const number = match[1];
      const measureWord = match[2];
      const noun = match[3];
      const offset = match.index;

      // Skip if already processed
      if (processedOffsets.has(offset)) continue;
      processedOffsets.add(offset);

      // Check if this is a known noun
      if (!this.measureRules[noun]) continue;

      const correctMeasure = this.measureRules[noun][0];
      const measureOffset = offset + number.length;

      // Case 1: Wrong measure word
      if (measureWord && measureWord !== correctMeasure) {
        errors.push({
          message: `Wrong measure word: '${noun}' needs '${correctMeasure}' not '${measureWord}'`,
          shortMessage: 'Wrong measure word',
          offset: measureOffset,
          length: measureWord.length,
          replacements: [{ value: correctMeasure }],
          type: { typeName: 'Grammar' }
        });
      }
      // Case 2: Missing measure word
      else if (!measureWord && noun) {
        errors.push({
          message: `Missing measure word: '${noun}' needs '${correctMeasure}'`,
          shortMessage: 'Missing measure word',
          offset: measureOffset,
          length: noun.length,
          replacements: [{ value: `${correctMeasure}${noun}` }],
          type: { typeName: 'Grammar' }
        });
      }
    }

    // Additional specific pattern matching for tricky cases
    // Find "æ•°å­—+æœ¬+è‹¹æœ" pattern
    const applePattern = /([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å0-9é›¶]+)\s*æœ¬\s*è‹¹æœ/g;
    while ((match = applePattern.exec(text)) !== null) {
      const number = match[1];
      const measureOffset = match.index + number.length;
      
      if (!processedOffsets.has(match.index)) {
        errors.push({
          message: 'Wrong measure word: \'è‹¹æœ\' needs \'ä¸ª\' not \'æœ¬\'',
          shortMessage: 'Wrong measure word',
          offset: measureOffset,
          length: 1,
          replacements: [{ value: 'ä¸ª' }],
          type: { typeName: 'Grammar' }
        });
        processedOffsets.add(match.index);
      }
    }

    // Find "æ•°å­—+åª+ä¹¦" pattern
    const bookPattern = /([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å0-9é›¶]+)\s*åª\s*ä¹¦/g;
    while ((match = bookPattern.exec(text)) !== null) {
      const number = match[1];
      const measureOffset = match.index + number.length;
      
      if (!processedOffsets.has(match.index)) {
        errors.push({
          message: 'Wrong measure word: \'ä¹¦\' needs \'æœ¬\' not \'åª\'',
          shortMessage: 'Wrong measure word',
          offset: measureOffset,
          length: 1,
          replacements: [{ value: 'æœ¬' }],
          type: { typeName: 'Grammar' }
        });
        processedOffsets.add(match.index);
      }
    }
  }

  deduplicateErrors(errors) {
    const uniqueErrors = [];
    const seen = new Set();

    for (const error of errors) {
      const key = `${error.offset}-${error.length}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueErrors.push(error);
      }
    }

    return uniqueErrors;
  }
}

export default ChineseGrammarChecker;
```

### backend\grammar_checkers\index.js
```js
// backend/grammar_checkers/index.js
import RussianGrammarChecker from './russianChecker.js';
import ChineseGrammarChecker from './chineseChecker.js';
import JapaneseGrammarChecker from './japaneseChecker.js';
import SpanishGrammarChecker from './spanishChecker.js';
import ItalianGrammarChecker from './italianChecker.js';

class GrammarCheckerFactory {
  static getChecker(language) {
    switch (language) {
      case 'ru-RU':
      case 'ru':
        return new RussianGrammarChecker();
      
      case 'zh-CN':
      case 'zh':
        return new ChineseGrammarChecker();
      
      case 'ja-JP':
      case 'ja':
        return new JapaneseGrammarChecker();
      
      case 'es-ES':
      case 'es':
        return new SpanishGrammarChecker();
      
      case 'it-IT':
      case 'it':
        return new ItalianGrammarChecker();
      
      default:
        return null;
    }
  }

  static check(text, language) {
    const checker = this.getChecker(language);
    if (!checker) {
      return {
        success: false,
        error: `Grammar checker not available for language: ${language}`
      };
    }

    try {
      const matches = checker.check(text);
      return {
        success: true,
        matches,
        language,
        source: 'custom-grammar-checker'
      };
    } catch (error) {
      console.error(`Error in grammar checker for ${language}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

export default GrammarCheckerFactory;
```

### backend\grammar_checkers\italianChecker.js
```js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class ItalianGrammarChecker {
  constructor() {
    this.rules = this.loadRules();
    this.verbConjugations = this.rules.verbConjugations || {};
    this.pronouns = this.rules.pronouns || {};
    this.articles = this.rules.articles || {};
    this.commonWords = this.rules.commonWords || {};
    this.specificRules = this.rules.specificRules || [];
  }

  loadRules() {
    try {
      const rulesPath = path.join(__dirname, 'rules', 'italian_rules.json');
      const rulesContent = fs.readFileSync(rulesPath, 'utf-8');
      return JSON.parse(rulesContent);
    } catch (error) {
      console.error('âŒ Failed to load Italian rules:', error.message);
      return {
        verbConjugations: {},
        pronouns: {},
        articles: {},
        commonWords: {},
        specificRules: []
      };
    }
  }

  check(text) {
    const errors = [];

    // Check for invalid verb forms like "vano"
    this.checkInvalidVerbForms(text, errors);

    // Check specific rules
    for (const rule of this.specificRules) {
      if (rule.id === 'vano_spelling') {
        const pattern = new RegExp(`(${rule.word})`, 'gi');
        let match;
        
        while ((match = pattern.exec(text)) !== null) {
          console.log(`[Italian] Matched spelling error at index ${match.index}: "${match[0]}"`);
          errors.push({
            message: rule.message,
            shortMessage: 'Spelling error',
            offset: match.index,
            length: match[0].length,
            replacements: rule.suggestions.map(s => ({ value: s })),
            type: { typeName: 'Spelling' }
          });
        }
      }

      if (rule.id === 'lui_parco') {
        const pattern = /(Lui|lui)\s+(vano|vain)/gi;
        let match;
        
        while ((match = pattern.exec(text)) !== null) {
          console.log(`[Italian] Matched error at index ${match.index}: "${match[0]}"`);
          errors.push({
            message: rule.message,
            shortMessage: 'Spelling error',
            offset: match.index,
            length: match[0].length,
            replacements: [{ value: `Lui ${rule.correction}` }],
            type: { typeName: 'Spelling' }
          });
        }
      }
    }

    // Check multiple spaces
    this.checkMultipleSpaces(text, errors);

    return this.deduplicateErrors(errors);
  }

  checkInvalidVerbForms(text, errors) {
    // Check for invalid forms like "vano", "vain"
    const invalidForms = ['vano', 'vain', 'vanu'];
    
    for (const form of invalidForms) {
      const pattern = new RegExp(`\\b(${form})\\b`, 'gi');
      let match;
      
      while ((match = pattern.exec(text)) !== null) {
        console.log(`[Italian] Found invalid verb form "${form}" at index ${match.index}`);
        errors.push({
          message: `'${form}' is not a valid Italian verb form. Did you mean 'va' (singular) or 'vanno' (plural)?`,
          shortMessage: 'Spelling error',
          offset: match.index,
          length: match[0].length,
          replacements: [{ value: 'va' }, { value: 'vanno' }],
          type: { typeName: 'Spelling' }
        });
      }
    }
  }

  checkMultipleSpaces(text, errors) {
    const pattern = /\s{2,}/g;
    let match;
    while ((match = pattern.exec(text)) !== null) {
      errors.push({
        message: 'Multiple consecutive spaces',
        shortMessage: 'Spacing error',
        offset: match.index,
        length: match[0].length,
        replacements: [],
        type: { typeName: 'Formatting' }
      });
    }
  }

  deduplicateErrors(errors) {
    const uniqueErrors = [];
    const seen = new Set();

    for (const error of errors) {
      const key = `${error.offset}-${error.length}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueErrors.push(error);
      }
    }

    return uniqueErrors;
  }
}

export default ItalianGrammarChecker;
```

### backend\grammar_checkers\japaneseChecker.js
```js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class JapaneseGrammarChecker {
  constructor() {
    this.rules = this.loadRules();
    this.particleRules = this.rules.particleRules || {};
    this.particles = this.rules.particles || [];
    this.verbEndings = this.rules.verbEndings || {};
    this.errorPatterns = this.rules.errorPatterns || [];
    this.invalidSequences = this.rules.invalidSequences || [];
    this.characterRanges = this.rules.characterRanges || {};
  }

  loadRules() {
    try {
      const rulesPath = path.join(__dirname, 'rules', 'japanese_rules.json');
      const rulesContent = fs.readFileSync(rulesPath, 'utf-8');
      return JSON.parse(rulesContent);
    } catch (error) {
      console.error('âŒ Failed to load Japanese rules:', error.message);
      return {
        particleRules: {},
        particles: [],
        verbEndings: {},
        errorPatterns: [],
        invalidSequences: [],
        characterRanges: {}
      };
    }
  }

  isJapanese(text) {
    const hiragana = new RegExp(this.characterRanges.hiragana);
    const katakana = new RegExp(this.characterRanges.katakana);
    const kanji = new RegExp(this.characterRanges.kanji);
    return hiragana.test(text) || katakana.test(text) || kanji.test(text);
  }

  check(text) {
    const errors = [];

    if (!this.isJapanese(text)) {
      return errors;
    }

    // Check 1: Double particles (always report)
    for (const particle of this.particles) {
      const doublePattern = new RegExp(particle + particle, 'g');
      let match;
      while ((match = doublePattern.exec(text)) !== null) {
        errors.push({
          message: `Double particle '${particle}' detected`,
          shortMessage: 'Duplicate particle',
          offset: match.index,
          length: 2,
          replacements: [{ value: particle }],
          type: { typeName: 'Grammar' }
        });
      }
    }

    // Check 2: Invalid particle sequences (always report)
    for (const seq of this.invalidSequences) {
      const pattern = new RegExp(seq.sequence.replace(/ /g, '\\s*'), 'g');
      let match;
      while ((match = pattern.exec(text)) !== null) {
        errors.push({
          message: seq.reason,
          shortMessage: 'Particle conflict',
          offset: match.index,
          length: match[0].length,
          replacements: [],
          type: { typeName: 'Grammar' }
        });
      }
    }

    // Check 3: Missing punctuation - STRICT conditions
    // Only flag if ALL conditions are met:
    // 1. Text ends with verb form (ã¾ã™, ãŸ, ã§ã™) - clear sentence end
    // 2. No punctuation at the very end
    // 3. Text is substantial (> 10 chars)
    // 4. Has at least one particle (is a structured sentence)
    
    const endsWithVerbForm = /(ã¾ã™|ã¾ã—ãŸ|ã¦ã„ã‚‹|ãŸ|ã§ã™)$/.test(text);
    const hasNoPunctuation = !/(ã€‚|ï¼|ï¼Ÿ)$/.test(text);
    const hasParticles = /(ã¯|ã‚’|ã«|ã¸|ã§|ã‹ã‚‰|ã¾ã§|ã‚‚|ã‚ˆã‚Š|ã¨|ã‚„)/.test(text);
    
    if (text.length > 10 && endsWithVerbForm && hasNoPunctuation && hasParticles) {
      errors.push({
        message: 'Missing sentence-ending punctuation',
        shortMessage: 'Punctuation error',
        offset: text.length - 1,
        length: 1,
        replacements: [{ value: 'ã€‚' }],
        type: { typeName: 'Punctuation' }
      });
    }

    return this.deduplicateErrors(errors);
  }

  deduplicateErrors(errors) {
    const uniqueErrors = [];
    const seen = new Set();
    
    for (const error of errors) {
      const key = `${error.offset}-${error.length}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueErrors.push(error);
      }
    }

    return uniqueErrors;
  }
}

export default JapaneseGrammarChecker;
```

### backend\grammar_checkers\russianChecker.js
```js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class RussianGrammarChecker {
  constructor() {
    this.rules = this.loadRules();
  }

  loadRules() {
    try {
      const rulesPath = path.join(__dirname, 'rules', 'russian_rules.json');
      const rulesContent = fs.readFileSync(rulesPath, 'utf-8');
      return JSON.parse(rulesContent);
    } catch (error) {
      console.error('âŒ Failed to load Russian rules:', error.message);
      return { specificRules: [] };
    }
  }

  check(text) {
    const errors = [];

    // Rule 1: Ğ¾Ğ½Ğ° + ÑĞºĞ°Ğ·Ğ°Ğ» (feminine + masculine verb)
    const genderPattern1 = /Ğ¾Ğ½Ğ°[^.!?]*?ÑĞºĞ°Ğ·Ğ°Ğ»(?![Ğ°-ÑÑ‘])/gi;
    let match;
    while ((match = genderPattern1.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ÑĞºĞ°Ğ·Ğ°Ğ»');
      errors.push({
        message: 'Gender mismatch: feminine \'Ğ¾Ğ½Ğ°\' requires \'ÑĞºĞ°Ğ·Ğ°Ğ»Ğ°\'',
        shortMessage: 'Gender agreement error',
        offset: match.index + pos,
        length: 6,
        replacements: [{ value: 'ÑĞºĞ°Ğ·Ğ°Ğ»Ğ°' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 2: Ğ¾Ğ½/Ğ¾Ğ½Ğ¾ + ÑĞºĞ°Ğ·Ğ°Ğ»Ğ¸ (singular + plural verb)
    const numberPattern1 = /(Ğ¾Ğ½|Ğ¾Ğ½Ğ¾)[^.!?]*?ÑĞºĞ°Ğ·Ğ°Ğ»Ğ¸(?![Ğ°-ÑÑ‘])/gi;
    while ((match = numberPattern1.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ÑĞºĞ°Ğ·Ğ°Ğ»Ğ¸');
      errors.push({
        message: 'Number mismatch: singular requires singular verb',
        shortMessage: 'Number agreement error',
        offset: match.index + pos,
        length: 7,
        replacements: [{ value: 'ÑĞºĞ°Ğ·Ğ°Ğ»' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 3: Ğ¾Ğ½Ğ¸ + Ğ¸Ğ¼ĞµĞµÑ‚ (plural + singular verb)
    const numberPattern2 = /Ğ¾Ğ½Ğ¸[^.!?]*?Ğ¸Ğ¼ĞµĞµÑ‚(?![Ğ°-ÑÑ‘])/gi;
    while ((match = numberPattern2.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('Ğ¸Ğ¼ĞµĞµÑ‚');
      errors.push({
        message: 'Number mismatch: plural requires plural verb',
        shortMessage: 'Number agreement error',
        offset: match.index + pos,
        length: 5,
        replacements: [{ value: 'Ğ¸Ğ¼ĞµÑÑ‚' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 4: Ğ¸Ğ¼ĞµĞµÑ‚/Ğ¸Ğ¼ĞµĞ»Ğ° + ĞºĞ½Ğ¸Ğ³Ğ° (need accusative)
    const casePattern1 = /(Ğ¸Ğ¼ĞµĞµÑ‚|Ğ¸Ğ¼ĞµĞ»Ğ°)[^.!?]*?ĞºĞ½Ğ¸Ğ³Ğ°(?![Ğ°-ÑÑ‘])/gi;
    while ((match = casePattern1.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ĞºĞ½Ğ¸Ğ³Ğ°');
      errors.push({
        message: 'Case error: need accusative \'ĞºĞ½Ğ¸Ğ³Ñƒ\'',
        shortMessage: 'Case agreement error',
        offset: match.index + pos,
        length: 5,
        replacements: [{ value: 'ĞºĞ½Ğ¸Ğ³Ñƒ' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 5: Ğ² + ÑˆĞºĞ¾Ğ»Ğ° (need locative ÑˆĞºĞ¾Ğ»Ğµ)
    const casePattern2 = /Ğ²\s+ÑˆĞºĞ¾Ğ»Ğ°(?![Ğ°-ÑÑ‘])/gi;
    while ((match = casePattern2.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ÑˆĞºĞ¾Ğ»Ğ°');
      errors.push({
        message: 'Case error: need locative \'ÑˆĞºĞ¾Ğ»Ğµ\'',
        shortMessage: 'Case agreement error',
        offset: match.index + pos,
        length: 5,
        replacements: [{ value: 'ÑˆĞºĞ¾Ğ»Ğµ' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 6: Ğ¾Ğ½/ÑÑ‚Ğ¾Ñ‚ + Ğ¸Ğ¼ĞµĞ»Ğ° (masculine + feminine verb)
    const genderPattern2 = /(Ğ¾Ğ½|ÑÑ‚Ğ¾Ñ‚)[^.!?]*?Ğ¸Ğ¼ĞµĞ»Ğ°(?![Ğ°-ÑÑ‘])/gi;
    while ((match = genderPattern2.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('Ğ¸Ğ¼ĞµĞ»Ğ°');
      errors.push({
        message: 'Gender mismatch: masculine requires \'Ğ¸Ğ¼ĞµĞ»\'',
        shortMessage: 'Gender agreement error',
        offset: match.index + pos,
        length: 5,
        replacements: [{ value: 'Ğ¸Ğ¼ĞµĞ»' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 7: Ñ‡Ğ¸Ñ‚Ğ°Ğ»Ğ° + ĞºĞ½Ğ¸Ğ³Ğ° (read + nominative)
    const casePattern3 = /Ñ‡Ğ¸Ñ‚Ğ°Ğ»Ğ°[^.!?]*?ĞºĞ½Ğ¸Ğ³Ğ°(?![Ğ°-ÑÑ‘])/gi;
    while ((match = casePattern3.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ĞºĞ½Ğ¸Ğ³Ğ°');
      errors.push({
        message: 'Case error: need accusative \'ĞºĞ½Ğ¸Ğ³Ñƒ\'',
        shortMessage: 'Case agreement error',
        offset: match.index + pos,
        length: 5,
        replacements: [{ value: 'ĞºĞ½Ğ¸Ğ³Ñƒ' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 8: ÑĞºĞ°Ğ·Ğ°Ğ» + Ğ¸Ğ¼/Ğ¸Ğ¼Ğ¸ (any pronoun + ÑĞºĞ°Ğ·Ğ°Ğ» after possessive)
    const genderPattern3 = /ÑĞ²Ğ¾Ğ¸Ğ¼[^.!?]*?ÑĞºĞ°Ğ·Ğ°Ğ»(?![Ğ°-ÑÑ‘])/gi;
    while ((match = genderPattern3.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('ÑĞºĞ°Ğ·Ğ°Ğ»');
      errors.push({
        message: 'Gender/context mismatch in verb form',
        shortMessage: 'Gender agreement error',
        offset: match.index + pos,
        length: 6,
        replacements: [{ value: 'ÑĞºĞ°Ğ·Ğ°Ğ»Ğ°' }],
        type: { typeName: 'Grammar' }
      });
    }

    // Rule 9: Ğ¿Ğ¸ÑĞ°Ğ»Ğ° + Ğ¿Ğ¸ÑÑŒĞ¼Ğ° (write + nominative plural)
    const casePattern4 = /Ğ¿Ğ¸ÑĞ°Ğ»Ğ°[^.!?]*?Ğ¿Ğ¸ÑÑŒĞ¼Ğ°(?![Ğ°-ÑÑ‘])/gi;
    while ((match = casePattern4.exec(text)) !== null) {
      const pos = match[0].lastIndexOf('Ğ¿Ğ¸ÑÑŒĞ¼Ğ°');
      errors.push({
        message: 'Case error: need accusative \'Ğ¿Ğ¸ÑÑŒĞ¼Ğ°\'',
        shortMessage: 'Case agreement error',
        offset: match.index + pos,
        length: 6,
        replacements: [{ value: 'Ğ¿Ğ¸ÑÑŒĞ¼Ğ°' }],
        type: { typeName: 'Grammar' }
      });
    }

    return this.deduplicateErrors(errors);
  }

  deduplicateErrors(errors) {
    const uniqueErrors = [];
    const seen = new Set();

    for (const error of errors) {
      const key = `${error.offset}-${error.length}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueErrors.push(error);
      }
    }

    return uniqueErrors;
  }
}

export default RussianGrammarChecker;
```

### backend\grammar_checkers\spanishChecker.js
```js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class SpanishGrammarChecker {
  constructor() {
    this.rules = this.loadRules();
    this.verbConjugations = this.rules.verbConjugations || {};
    this.pronouns = this.rules.pronouns || {};
    this.articles = this.rules.articles || {};
    this.specificRules = this.rules.specificRules || [];
    
    // Singular subjects that should use singular verbs (va, es, estÃ¡)
    this.singularSubjects = ['el', 'la', 'un', 'una', 'este', 'ese', 'aquÃ©l'];
    this.singularVerbs = ['va', 'es', 'estÃ¡', 'tiene', 'hace'];
    this.pluralVerbs = ['van', 'son', 'estÃ¡n', 'tienen', 'hacen'];
  }

  loadRules() {
    try {
      const rulesPath = path.join(__dirname, 'rules', 'spanish_rules.json');
      const rulesContent = fs.readFileSync(rulesPath, 'utf-8');
      return JSON.parse(rulesContent);
    } catch (error) {
      console.error('âŒ Failed to load Spanish rules:', error.message);
      return {
        verbConjugations: {},
        pronouns: {},
        articles: {},
        specificRules: []
      };
    }
  }

  check(text) {
    const errors = [];
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    let offsetAdjustment = 0;

    for (const sentence of sentences) {
      const sentenceErrors = this.checkSentence(sentence, offsetAdjustment);
      errors.push(...sentenceErrors);
      offsetAdjustment += sentence.length;
    }

    return this.deduplicateErrors(errors);
  }

  checkSentence(sentence, baseOffset = 0) {
    const errors = [];
    const words = sentence.trim().split(/\s+/);
    const lowerWords = words.map(w => w.toLowerCase().replace(/[,.!?;:]/g, ''));

    // Pattern: [article/subject] + noun + [plural verb] â†’ should be singular
    for (let i = 0; i < words.length - 2; i++) {
      const currentWord = lowerWords[i];
      const nextWord = lowerWords[i + 1];
      const thirdWord = lowerWords[i + 2];

      // Check for: article/singular subject + noun + plural verb
      if (this.singularSubjects.includes(currentWord)) {
        // Look ahead for plural verbs (van, son, estÃ¡n, tienen, hacen)
        for (let j = i + 2; j < Math.min(i + 6, words.length); j++) {
          const checkWord = lowerWords[j];
          
          if (this.pluralVerbs.includes(checkWord)) {
            // Found singular subject followed by plural verb
            const singularForm = this.getPluralToSingular(checkWord);
            const matchOffset = sentence.indexOf(checkWord);
            
            errors.push({
              message: `Subject-verb agreement error: singular subject requires singular verb '${singularForm}' instead of '${checkWord}'`,
              shortMessage: 'Subject-verb agreement error',
              offset: baseOffset + matchOffset,
              length: checkWord.length,
              replacements: [{ value: singularForm }],
              type: { typeName: 'Grammar' }
            });
            break;
          }
        }
      }

      // Also check for proper nouns or implicit subjects
      // Pattern: [noun] + [plural verb for singular context]
      if (i > 0 && this.singularSubjects.includes(lowerWords[i - 1])) {
        if (this.pluralVerbs.includes(nextWord)) {
          const singularForm = this.getPluralToSingular(nextWord);
          const matchOffset = sentence.indexOf(nextWord);
          
          errors.push({
            message: `Subject-verb agreement error: singular subject requires singular verb '${singularForm}' instead of '${nextWord}'`,
            shortMessage: 'Subject-verb agreement error',
            offset: baseOffset + matchOffset,
            length: nextWord.length,
            replacements: [{ value: singularForm }],
            type: { typeName: 'Grammar' }
          });
        }
      }
    }

    return errors;
  }

  getPluralToSingular(pluralVerb) {
    const map = {
      'van': 'va',
      'son': 'es',
      'estÃ¡n': 'estÃ¡',
      'tienen': 'tiene',
      'hacen': 'hace',
      'vamos': 'voy',
      'somos': 'soy',
      'estamos': 'estoy'
    };
    return map[pluralVerb] || pluralVerb;
  }

  deduplicateErrors(errors) {
    const uniqueErrors = [];
    const seen = new Set();

    for (const error of errors) {
      const key = `${error.offset}-${error.length}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueErrors.push(error);
      }
    }

    return uniqueErrors;
  }
}

export default SpanishGrammarChecker;
```

### backend\routes\grammar.js
```js
import express from 'express';
import languageToolService from '../services/languageToolService.js';
import dotenv from 'dotenv';

dotenv.config();

const router = express.Router();

// Helper function to validate text input
const validateText = (text) => {
  if (!text || typeof text !== 'string' || !text.trim()) {
    return { valid: false, error: 'Text is required and must be a non-empty string.' };
  }
  return { valid: true };
};

// Helper function to clean text
const cleanText = (text) => {
  return text
    .normalize('NFKC')
    .replace(/<[^>]*>/g, ' ')
    .replace(/[^\p{L}\p{N}\s.,!?;:'"()\-]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
};

/**
 * Detect language from input text 
 */
router.post('/detect', async (req, res) => {
  const { text } = req.body;
  const validation = validateText(text);

  if (!validation.valid) {
    return res.status(400).json({ 
      success: false, 
      error: validation.error 
    });
  }

  try {
    const detection = await languageToolService.detectLanguage(text);
    
    res.json({ 
      success: true, 
      data: {
        language: detection.language,
        confidence: detection.confidence,
        reliable: detection.reliable,
        source: detection.source,
        detection_time_ms: detection.detection_time_ms
      }
    });
  } catch (error) {
    console.error('âŒ Language detection failed:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * Get supported languages
 */
router.get('/languages', async (req, res) => {
  try {
    const languages = await languageToolService.getLanguages();
    res.json({ 
      success: true, 
      data: { languages } 
    });
  } catch (error) {
    console.error('âŒ Failed to fetch languages:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * Health check endpoint
 */
router.get('/health', async (req, res) => {
  try {
    console.log('[HEALTH CHECK] Starting health check...');
    
    const health = await languageToolService.healthCheck();
    console.log('[HEALTH CHECK] Result:', JSON.stringify(health, null, 2));
    
    res.json({ 
      success: true, 
      data: health,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ Health check failed:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

/**
 * Get grammar cache statistics
 */
router.get('/cache-stats', async (req, res) => {
  try {
    const stats = languageToolService.getCacheStats();
    res.json({ 
      success: true, 
      data: stats 
    });
  } catch (error) {
    console.error('âŒ Failed to get cache stats:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * Check grammar - Main endpoint
 */
router.post('/check', async (req, res) => {
  const startTime = Date.now();
  const { text, language = 'auto' } = req.body;

  const validation = validateText(text);
  if (!validation.valid) {
    return res.status(400).json({ 
      success: false, 
      error: validation.error
    });
  }

  try {
    console.log('[GRAMMAR CHECK] Request received:', {
      textLength: text.length,
      textPreview: text.substring(0, 80),
      language
    });

    const cleanedText = cleanText(text);

    if (!cleanedText) {
      return res.status(400).json({ 
        success: false, 
        error: 'Text is empty after cleaning.' 
      });
    }

    const result = await languageToolService.checkGrammar(cleanedText, language);
    const totalTime = Date.now() - startTime;

    console.log(`[GRAMMAR CHECK] Completed: ${result.matches.length} matches in ${totalTime}ms`);

    return res.json({
      success: true,
      data: {
        text: result.text,
        language: result.language,
        matches: result.matches,
        language_detection: result.language_detection,
        performance: result.performance
      }
    });

  } catch (error) {
    console.error('[GRAMMAR CHECK] âŒ Failed:', error.message);
    
    const totalTime = Date.now() - startTime;

    return res.status(error.statusCode || 500).json({
      success: false,
      error: error.message || 'Grammar check failed',
      details: process.env.NODE_ENV !== 'production' ? error.stack : undefined,
      performance: {
        total_time_ms: totalTime
      }
    });
  }
});

export default router;
```

### backend\routes\notificationRoutes.js
```js
import express from 'express';
import sql from 'mssql';
import rateLimit from 'express-rate-limit';
import dotenv from 'dotenv';

dotenv.config();

const router = express.Router();

// ========== HELPER FUNCTIONS ==========

function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('âŒ Database pool not available');
        throw new Error('Database pool not available.');
    }
    return req.app.locals.db;
}

// Validate pagination parameters
const validatePagination = (limit, offset) => {
    const parsedLimit = Math.min(Math.max(parseInt(limit) || 50, 1), 500);
    const parsedOffset = Math.max(parseInt(offset) || 0, 0);
    return { limit: parsedLimit, offset: parsedOffset };
};

// Validate date range
const validateDateRange = (dateFrom, dateTo) => {
    if (dateFrom) {
        const from = new Date(dateFrom);
        if (isNaN(from.getTime())) {
            throw new Error('Invalid dateFrom format. Use ISO format (YYYY-MM-DD)');
        }
    }
    if (dateTo) {
        const to = new Date(dateTo);
        if (isNaN(to.getTime())) {
            throw new Error('Invalid dateTo format. Use ISO format (YYYY-MM-DD)');
        }
    }
    if (dateFrom && dateTo && new Date(dateFrom) > new Date(dateTo)) {
        throw new Error('dateFrom cannot be after dateTo');
    }
};

// Parse notification record
const parseNotification = (record) => ({
    ...record,
    metadata: record.Metadata ? JSON.parse(record.Metadata) : {},
    isRead: !!record.IsRead,
    readAt: record.ReadAt || null,
    createdAt: record.CreatedAt?.toISOString()
});

// Standard response format
const successResponse = (data, meta = null, message = null) => ({
    success: true,
    data,
    meta,
    message,
    timestamp: new Date().toISOString()
});

const errorResponse = (error) => ({
    success: false,
    error,
    timestamp: new Date().toISOString()
});

// ========== MIDDLEWARE ==========

// Admin authorization
const isAdmin = (req, res, next) => {
    console.log('ğŸ” Checking admin authorization...');
    const userRole = req.headers['x-user-role'] || req.body.userRole;

    if (userRole === 'admin') {
        console.log('âœ… Admin access granted');
        next();
    } else {
        console.log(`âŒ Admin access denied. Role: "${userRole}"`);
        return res.status(403).json(errorResponse('Admin privileges required'));
    }
};

// Authentication check
const requireAuth = (req, res, next) => {
    const userId = req.headers['x-user-id'] || req.params.userId;
    const userRole = req.headers['x-user-role'];

    if (!userId || !userRole) {
        return res.status(401).json(errorResponse('Authentication required'));
    }

    req.authenticatedUser = {
        id: parseInt(userId),
        role: userRole
    };

    next();
};

// User authorization - check if user can access their own data
const authorizeUser = (req, res, next) => {
    const targetUserId = parseInt(req.params.userId);

    if (req.authenticatedUser.role !== 'admin' && req.authenticatedUser.id !== targetUserId) {
        return res.status(403).json(
            errorResponse('Access denied. You can only access your own notifications.')
        );
    }

    next();
};

// Rate limiting
const notificationLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100,
    message: 'Too many requests, please try again later',
    standardHeaders: true,
    legacyHeaders: false
});

router.use(notificationLimiter);

// ========== INTERNAL FUNCTIONS ==========

/**
 * Create notification (called when admin updates user)
 */
export const createNotification = async (pool, notificationData) => {
    try {
        const request = pool.request();

        const query = `
            INSERT INTO Notifications (
                UserID, Title, Message, Type, IsRead, 
                AdminAction, AdminID, Metadata, CreatedAt
            )
            VALUES (
                @UserID, @Title, @Message, @Type, 0,
                @AdminAction, @AdminID, @Metadata, GETDATE()
            );
            SELECT SCOPE_IDENTITY() as NotificationID;
        `;

        request.input('UserID', sql.Int, notificationData.userID);
        request.input('Title', sql.NVarChar(255), notificationData.title);
        request.input('Message', sql.NVarChar(500), notificationData.message);
        request.input('Type', sql.VarChar(50), notificationData.type || 'profile_update');
        request.input('AdminAction', sql.NVarChar(100), notificationData.adminAction);
        request.input('AdminID', sql.Int, notificationData.adminID);
        request.input('Metadata', sql.NVarChar(sql.MAX), JSON.stringify(notificationData.metadata || {}));

        const result = await request.query(query);
        const notificationId = result.recordset[0].NotificationID;

        console.log('âœ… Notification created:', { id: notificationId, userID: notificationData.userID });
        return { success: true, notificationId };
    } catch (err) {
        console.error('âŒ Error creating notification:', err);
        throw err;
    }
};

// ========== ROUTES ==========

/**
 * GET /notifications/user/:userId
 * Get all notifications for a user with pagination
 */
router.get('/user/:userId', requireAuth, authorizeUser, async (req, res) => {
    const userId = parseInt(req.params.userId);
    const { limit, offset, unreadOnly = false } = req.query;

    console.log(`ğŸ“± Fetching notifications for user ${userId}`);

    try {
        const { limit: validLimit, offset: validOffset } = validatePagination(limit, offset);
        const pool = getDbPool(req);

        let whereClause = 'WHERE n.UserID = @userId';
        if (unreadOnly === 'true') {
            whereClause += ' AND n.IsRead = 0';
        }

        // Combined query to get notifications and unread count in one go
        const query = `
            SELECT 
                n.NotificationID,
                n.UserID,
                n.Title,
                n.Message,
                n.Type,
                n.IsRead,
                n.AdminAction,
                n.AdminID,
                u.Username as AdminUsername,
                u.fullName as AdminName,
                n.Metadata,
                n.CreatedAt,
                n.ReadAt,
                (SELECT COUNT(*) FROM Notifications WHERE UserID = @userId AND IsRead = 0) as UnreadCount
            FROM Notifications n
            LEFT JOIN Users u ON n.AdminID = u.UserID
            ${whereClause}
            ORDER BY n.CreatedAt DESC
            OFFSET @offset ROWS
            FETCH NEXT @limit ROWS ONLY;
        `;

        const result = await pool.request()
            .input('userId', sql.Int, userId)
            .input('limit', sql.Int, validLimit)
            .input('offset', sql.Int, validOffset)
            .query(query);

        const notifications = result.recordset.map(parseNotification);
        const unreadCount = result.recordset.length > 0 ? result.recordset[0].UnreadCount : 0;

        res.json(successResponse(notifications, {
            total: notifications.length,
            unreadCount,
            limit: validLimit,
            offset: validOffset
        }, 'Notifications retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error fetching notifications:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * PATCH /notifications/:notificationId/read
 * Mark a single notification as read
 */
router.patch('/:notificationId/read', requireAuth, async (req, res) => {
    const notificationId = parseInt(req.params.notificationId);

    console.log(`âœ… Marking notification ${notificationId} as read`);

    try {
        const pool = getDbPool(req);

        // Check ownership and update in single query
        const query = `
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = GETDATE()
            OUTPUT inserted.UserID
            WHERE NotificationID = @notificationId 
            AND IsRead = 0
            AND UserID IN (
                SELECT @userId WHERE @userRole = 'admin'
                UNION ALL
                SELECT @userId WHERE @userRole != 'admin' AND UserID = @userId
            );
        `;

        const result = await pool.request()
            .input('notificationId', sql.Int, notificationId)
            .input('userId', sql.Int, req.authenticatedUser.id)
            .input('userRole', sql.VarChar(20), req.authenticatedUser.role)
            .query(query);

        if (result.recordset.length === 0) {
            return res.status(404).json(errorResponse('Notification not found or already read'));
        }

        res.json(successResponse(null, null, 'Notification marked as read'));

    } catch (err) {
        console.error('âŒ Error marking notification as read:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * PATCH /notifications/user/:userId/mark-all-read
 * Mark all notifications as read for a user
 */
router.patch('/user/:userId/mark-all-read', requireAuth, authorizeUser, async (req, res) => {
    const userId = parseInt(req.params.userId);

    console.log(`âœ… Marking all notifications as read for user ${userId}`);

    try {
        const pool = getDbPool(req);

        const query = `
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = GETDATE()
            WHERE UserID = @userId AND IsRead = 0;
        `;

        const result = await pool.request()
            .input('userId', sql.Int, userId)
            .query(query);

        res.json(successResponse(null, null, `${result.rowsAffected[0]} notifications marked as read`));

    } catch (err) {
        console.error('âŒ Error marking all notifications as read:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * DELETE /notifications/:notificationId
 * Delete a single notification
 */
router.delete('/:notificationId', requireAuth, async (req, res) => {
    const notificationId = parseInt(req.params.notificationId);

    console.log(`ğŸ—‘ï¸ Deleting notification ${notificationId}`);

    try {
        const pool = getDbPool(req);

        const query = `
            DELETE FROM Notifications 
            OUTPUT deleted.UserID
            WHERE NotificationID = @notificationId
            AND (
                @userRole = 'admin' 
                OR UserID = @userId
            );
        `;

        const result = await pool.request()
            .input('notificationId', sql.Int, notificationId)
            .input('userId', sql.Int, req.authenticatedUser.id)
            .input('userRole', sql.VarChar(20), req.authenticatedUser.role)
            .query(query);

        if (result.recordset.length === 0) {
            return res.status(404).json(errorResponse('Notification not found'));
        }

        res.json(successResponse(null, null, 'Notification deleted successfully'));

    } catch (err) {
        console.error('âŒ Error deleting notification:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * DELETE /notifications/user/:userId/delete-all
 * Delete all notifications for a user
 */
router.delete('/user/:userId/delete-all', requireAuth, authorizeUser, async (req, res) => {
    const userId = parseInt(req.params.userId);

    console.log(`ğŸ—‘ï¸ Deleting all notifications for user ${userId}`);

    try {
        const pool = getDbPool(req);

        const query = `
            DELETE FROM Notifications WHERE UserID = @userId;
        `;

        const result = await pool.request()
            .input('userId', sql.Int, userId)
            .query(query);

        res.json(successResponse(null, null, `${result.rowsAffected[0]} notifications deleted`));

    } catch (err) {
        console.error('âŒ Error deleting all notifications:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * GET /notifications/languages
 * Get all supported notification types
 */
router.get('/types', async (req, res) => {
    try {
        const notificationTypes = [
            { type: 'profile_update', description: 'Profile information updated' },
            { type: 'status_change', description: 'Account status changed' },
            { type: 'security_alert', description: 'Security-related alert' },
            { type: 'system_message', description: 'System notification' }
        ];

        res.json(successResponse(notificationTypes, null, 'Notification types retrieved'));

    } catch (err) {
        console.error('âŒ Error fetching notification types:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * GET /notifications/admin/sent/:adminId
 * Get notifications sent by a specific admin with filtering
 */
router.get('/admin/sent/:adminId', isAdmin, async (req, res) => {
    const adminId = parseInt(req.params.adminId);
    const { limit, offset, dateFrom, dateTo } = req.query;

    console.log(`ğŸ‘¨â€ğŸ’¼ Admin ${adminId} fetching sent notifications`);

    try {
        validateDateRange(dateFrom, dateTo);
        const { limit: validLimit, offset: validOffset } = validatePagination(limit, offset);
        const pool = getDbPool(req);

        let whereClause = 'WHERE n.AdminID = @adminId';
        const request = pool.request().input('adminId', sql.Int, adminId);

        if (dateFrom) {
            whereClause += ' AND n.CreatedAt >= @dateFrom';
            request.input('dateFrom', sql.DateTime, new Date(dateFrom));
        }

        if (dateTo) {
            whereClause += ' AND n.CreatedAt <= @dateTo';
            request.input('dateTo', sql.DateTime, new Date(dateTo));
        }

        const query = `
            SELECT 
                n.NotificationID,
                n.UserID,
                u.Username,
                u.fullName as UserName,
                u.Email as UserEmail,
                n.Title,
                n.Message,
                n.Type,
                n.IsRead,
                n.AdminAction,
                n.CreatedAt,
                n.ReadAt
            FROM Notifications n
            INNER JOIN Users u ON n.UserID = u.UserID
            ${whereClause}
            ORDER BY n.CreatedAt DESC
            OFFSET @offset ROWS
            FETCH NEXT @limit ROWS ONLY;

            SELECT 
                COUNT(*) as totalSent,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readCount,
                SUM(CASE WHEN IsRead = 0 THEN 1 ELSE 0 END) as unreadCount
            FROM Notifications 
            ${whereClause};
        `;

        request.input('limit', sql.Int, validLimit);
        request.input('offset', sql.Int, validOffset);

        const result = await request.query(query);
        const notifications = result.recordsets[0].map(parseNotification);
        const stats = result.recordsets[1][0];

        res.json(successResponse(notifications, { ...stats, limit: validLimit, offset: validOffset }, 
            'Admin sent notifications retrieved'));

    } catch (err) {
        console.error('âŒ Error fetching admin notifications:', err);
        res.status(err.message.includes('Invalid') ? 400 : 500)
            .json(errorResponse(err.message));
    }
});

/**
 * DELETE /notifications/cleanup
 * Delete old notifications (older than specified days)
 */
router.delete('/cleanup', isAdmin, async (req, res) => {
    const { days = 3 } = req.body;

    if (typeof days !== 'number' || days < 1) {
        return res.status(400).json(errorResponse('Days must be a positive number'));
    }

    console.log(`ğŸ§¹ Starting cleanup of notifications older than ${days} days`);

    try {
        const pool = getDbPool(req);

        const query = `
            DELETE FROM Notifications 
            WHERE CreatedAt < DATEADD(day, -@days, GETDATE());
        `;

        const result = await pool.request()
            .input('days', sql.Int, days)
            .query(query);

        console.log(`ğŸ§¹ Cleanup completed. Deleted ${result.rowsAffected[0]} old notifications`);

        res.json(successResponse(null, null, `${result.rowsAffected[0]} notifications deleted`));

    } catch (err) {
        console.error('âŒ Error during cleanup:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * GET /notifications/admin/stats
 * Get notification statistics for admin dashboard
 */
router.get('/admin/stats', isAdmin, async (req, res) => {
    console.log('ğŸ“Š Fetching notification statistics');

    try {
        const pool = getDbPool(req);

        const query = `
            SELECT 
                COUNT(*) as totalNotifications,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readNotifications,
                SUM(CASE WHEN IsRead = 0 THEN 1 ELSE 0 END) as unreadNotifications,
                COUNT(DISTINCT UserID) as usersWithNotifications,
                COUNT(DISTINCT AdminID) as adminsWhoSent
            FROM Notifications;

            SELECT 
                Type,
                COUNT(*) as count,
                SUM(CASE WHEN IsRead = 1 THEN 1 ELSE 0 END) as readCount
            FROM Notifications
            GROUP BY Type
            ORDER BY count DESC;

            SELECT TOP 10
                u.UserID,
                u.Username,
                u.fullName,
                COUNT(*) as notificationCount,
                SUM(CASE WHEN IsRead = 0 THEN 1 ELSE 0 END) as unreadCount
            FROM Notifications n
            INNER JOIN Users u ON n.UserID = u.UserID
            GROUP BY u.UserID, u.Username, u.fullName
            ORDER BY notificationCount DESC;
        `;

        const result = await pool.request().query(query);

        res.json(successResponse({
            overview: result.recordsets[0][0],
            byType: result.recordsets[1],
            topUsers: result.recordsets[2]
        }, null, 'Notification statistics retrieved'));

    } catch (err) {
        console.error('âŒ Error fetching notification stats:', err);
        res.status(500).json(errorResponse(err.message));
    }
});

/**
 * GET /notifications/health
 * Health check endpoint
 */
router.get('/health', async (req, res) => {
    console.log('[HEALTH CHECK] Notification service health check');

    try {
        const pool = getDbPool(req);
        const result = await pool.request()
            .query('SELECT COUNT(*) as totalNotifications FROM Notifications;');

        res.json(successResponse({
            status: 'healthy',
            totalNotifications: result.recordset[0].totalNotifications
        }, null, 'Health check passed'));

    } catch (err) {
        console.error('âŒ Health check failed:', err);
        res.status(503).json(errorResponse('Service unavailable'));
    }
});

export default router;
```

### backend\routes\statsRoutes.js
```js
import express from 'express';
import sql from 'mssql';
import rateLimit from 'express-rate-limit';
import dotenv from 'dotenv';

dotenv.config();

const router = express.Router();

// ========== CONSTANTS ==========

const LANGUAGE_NAMES = {
  'en-US': 'English (US)', 'en': 'English', 'en-GB': 'English (UK)',
  'fr': 'French', 'fr-FR': 'French (France)',
  'de': 'German', 'de-DE': 'German (Germany)', 'de-AT': 'German (Austria)', 'de-CH': 'German (Switzerland)',
  'ru': 'Russian', 'ru-RU': 'Russian', 'uk': 'Ukrainian', 'uk-UA': 'Ukrainian',
  'ja': 'Japanese', 'ja-JP': 'Japanese',
  'es': 'Spanish', 'es-ES': 'Spanish (Spain)',
  'pt': 'Portuguese', 'pt-PT': 'Portuguese (Portugal)', 'pt-BR': 'Portuguese (Brazil)',
  'gl-ES': 'Galician', 'it': 'Italian', 'it-IT': 'Italian',
  'nl': 'Dutch', 'nl-NL': 'Dutch', 'pl': 'Polish', 'pl-PL': 'Polish',
  'sv': 'Swedish', 'sv-SE': 'Swedish', 'da': 'Danish', 'da-DK': 'Danish',
  'ar': 'Arabic', 'zh': 'Chinese', 'zh-CN': 'Chinese (Simplified)', 'zh-TW': 'Chinese (Traditional)',
  'ko': 'Korean', 'ko-KR': 'Korean', 'vi': 'Vietnamese', 'th': 'Thai',
  'be': 'Belarusian', 'be-BY': 'Belarusian', 'bg': 'Bulgarian', 'bg-BG': 'Bulgarian',
  'sr': 'Serbian', 'sr-RS': 'Serbian', 'ca': 'Catalan', 'ca-ES': 'Catalan',
  'cs': 'Czech', 'cs-CZ': 'Czech', 'el': 'Greek', 'el-GR': 'Greek',
  'fa': 'Persian', 'fa-IR': 'Persian', 'fi': 'Finnish', 'fi-FI': 'Finnish',
  'he': 'Hebrew', 'he-IL': 'Hebrew', 'hi': 'Hindi', 'hi-IN': 'Hindi',
  'hu': 'Hungarian', 'hu-HU': 'Hungarian', 'id': 'Indonesian', 'id-ID': 'Indonesian',
  'lt': 'Lithuanian', 'lt-LT': 'Lithuanian', 'lv': 'Latvian', 'lv-LV': 'Latvian',
  'nb': 'Norwegian (BokmÃ¥l)', 'nb-NO': 'Norwegian (BokmÃ¥l)', 'ro': 'Romanian', 'ro-RO': 'Romanian',
  'sk': 'Slovak', 'sk-SK': 'Slovak', 'sl': 'Slovenian', 'sl-SI': 'Slovenian',
  'tr': 'Turkish', 'tr-TR': 'Turkish', 'unknown': 'Unknown'
};

const VALID_RANGES = ['hour', 'day', 'month', 'year'];
const VALID_ACTIONS = /^[a-zA-Z0-9_]+$/;

// ========== HELPER FUNCTIONS ==========

function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('âŒ Database pool not available');
        throw new Error('Database pool not available.');
    }
    return req.app.locals.db;
}

/**
 * Unified success response
 */
const successResponse = (data, meta = null, message = null) => ({
    success: true,
    data,
    meta,
    message,
    timestamp: new Date().toISOString()
});

/**
 * Unified error response
 */
const errorResponse = (error, statusCode = 500, details = null) => ({
    success: false,
    error,
    details: process.env.NODE_ENV !== 'production' ? details : undefined,
    statusCode,
    timestamp: new Date().toISOString()
});

/**
 * Validate pagination parameters
 */
const validatePagination = (limit, offset) => {
    const parsedLimit = Math.min(Math.max(parseInt(limit) || 50, 1), 1000);
    const parsedOffset = Math.max(parseInt(offset) || 0, 0);
    return { limit: parsedLimit, offset: parsedOffset };
};

/**
 * Validate and sanitize action parameter
 */
const validateAction = (action) => {
    if (!action) return null;
    
    if (typeof action !== 'string') {
        throw new Error('Action must be a string');
    }
    
    if (action.length > 50) {
        throw new Error('Action cannot exceed 50 characters');
    }
    
    if (!VALID_ACTIONS.test(action)) {
        throw new Error('Action contains invalid characters. Use only alphanumeric and underscore');
    }
    
    return action;
};

/**
 * Log admin actions
 */
const logAdminAction = (userId, endpoint, params) => {
    console.log(`[ADMIN ACTION] User ${userId} accessed ${endpoint}`, {
        params,
        timestamp: new Date().toISOString()
    });
};

// ========== MIDDLEWARE ==========

/**
 * Check admin authorization
 */
const isAdmin = (req, res, next) => {
    console.log('ğŸ” Checking admin authorization...');
    const userRole = req.headers['x-user-role'] || req.body.userRole;
    const userId = req.headers['x-user-id'] || req.body.userId;

    if (userRole === 'admin') {
        req.authenticatedUser = { id: userId, role: userRole };
        console.log('âœ… Admin access granted');
        next();
    } else {
        console.log(`âŒ Admin access denied. Role: "${userRole}"`);
        res.status(403).json(errorResponse('Admin privileges required', 403));
    }
};

/**
 * Rate limiting for stats endpoints
 */
const statsLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100,
    message: 'Too many requests, please try again later',
    standardHeaders: true,
    legacyHeaders: false
});

router.use(statsLimiter);

// ========== ROUTES ==========

/**
 * GET /stats/account-types
 * Account type statistics
 */
router.get('/account-types', isAdmin, async (req, res) => {
    console.log('[ACCOUNT TYPES] Fetching account type statistics');
    
    try {
        logAdminAction(req.authenticatedUser.id, '/account-types', {});

        const pool = getDbPool(req);
        const result = await pool.request().query(`
            SELECT 
                AccountType,
                COUNT(*) as count,
                CAST(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS DECIMAL(5,2)) as percentage
            FROM Users 
            WHERE UserStatus = 'active'
            GROUP BY AccountType
            ORDER BY count DESC
        `);

        const stats = {
            total: result.recordset.reduce((sum, item) => sum + item.count, 0),
            breakdown: result.recordset.map(item => ({
                type: item.AccountType,
                count: item.count,
                percentage: parseFloat(item.percentage)
            }))
        };

        res.json(successResponse(stats, null, 'Account types retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error fetching account types:', err.message);
        res.status(500).json(errorResponse('Failed to fetch account statistics', 500, err.message));
    }
});

/**
 * GET /stats/languages
 * Language usage statistics
 */
router.get('/languages', isAdmin, async (req, res) => {
    console.log('[LANGUAGES] Fetching language statistics');
    
    try {
        logAdminAction(req.authenticatedUser.id, '/languages', {});

        const pool = getDbPool(req);
        const result = await pool.request().query(`
            SELECT 
                ISNULL(Language, 'unknown') AS language,
                COUNT(*) AS usage_count
            FROM UsageLogs
            WHERE Action = 'grammar_check'
            GROUP BY ISNULL(Language, 'unknown')
            ORDER BY usage_count DESC;
        `);

        if (!result.recordset || result.recordset.length === 0) {
            const emptyStats = {
                total_usage: 0,
                most_used: null,
                least_used: null,
                languages: []
            };
            return res.json(successResponse(emptyStats, null, 'No language data available'));
        }

        const totalUsage = result.recordset.reduce((sum, item) => sum + item.usage_count, 0);
        const stats = {
            total_usage: totalUsage,
            most_used: {
                language: result.recordset[0].language,
                language_name: LANGUAGE_NAMES[result.recordset[0].language] || result.recordset[0].language,
                usage_count: result.recordset[0].usage_count
            },
            least_used: {
                language: result.recordset[result.recordset.length - 1].language,
                language_name: LANGUAGE_NAMES[result.recordset[result.recordset.length - 1].language] || result.recordset[result.recordset.length - 1].language,
                usage_count: result.recordset[result.recordset.length - 1].usage_count
            },
            languages: result.recordset.map(item => ({
                language: item.language,
                language_name: LANGUAGE_NAMES[item.language] || item.language,
                usage_count: item.usage_count,
                percentage: (item.usage_count / totalUsage * 100).toFixed(2)
            }))
        };

        res.json(successResponse(stats, null, 'Language statistics retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error fetching language stats:', err.message);
        res.status(500).json(errorResponse('Failed to fetch language statistics', 500, err.message));
    }
});

/**
 * GET /stats/timeframe
 * Statistics by timeframe with action filtering
 * Query params: range=(hour|day|month|year), action=(optional)
 */
router.get('/timeframe', isAdmin, async (req, res) => {
    console.log('[TIMEFRAME] Fetching timeframe statistics');
    
    try {
        const { range = 'day', action } = req.query;

        if (!VALID_RANGES.includes(range)) {
            return res.status(400).json(
                errorResponse('Invalid range. Use: hour, day, month, or year', 400)
            );
        }

        const validatedAction = validateAction(action);
        logAdminAction(req.authenticatedUser.id, '/timeframe', { range, action: validatedAction });

        const pool = getDbPool(req);
        let query = '';

        switch (range) {
            case 'hour': 
                query = `
                    SELECT 
                        DATEPART(HOUR, u.CreatedAt) AS period,
                        'Hour ' + CAST(DATEPART(HOUR, u.CreatedAt) AS VARCHAR(2)) AS period_label,
                        COUNT(u.LogID) AS activity_count
                    FROM UsageLogs u
                    WHERE u.CreatedAt >= DATEADD(day, -1, GETDATE())
                    ${validatedAction ? 'AND u.Action = @action' : ''}
                    GROUP BY DATEPART(HOUR, u.CreatedAt)
                    ORDER BY period;
                `;
                break;

            case 'day': 
                query = `
                    SELECT 
                        CAST(u.CreatedAt AS DATE) AS period,
                        FORMAT(CAST(u.CreatedAt AS DATE), 'MMM dd') AS period_label,
                        COUNT(u.LogID) AS activity_count
                    FROM UsageLogs u
                    WHERE u.CreatedAt >= DATEADD(day, -29, GETDATE())
                    ${validatedAction ? 'AND u.Action = @action' : ''}
                    GROUP BY CAST(u.CreatedAt AS DATE)
                    ORDER BY period;
                `;
                break;

            case 'month': 
                query = `
                    SELECT 
                        YEAR(u.CreatedAt) * 100 + MONTH(u.CreatedAt) AS period,
                        FORMAT(u.CreatedAt, 'MMM yyyy') AS period_label,
                        COUNT(u.LogID) AS activity_count
                    FROM UsageLogs u
                    WHERE u.CreatedAt >= DATEADD(month, -11, GETDATE())
                    ${validatedAction ? 'AND u.Action = @action' : ''}
                    GROUP BY YEAR(u.CreatedAt), MONTH(u.CreatedAt)
                    ORDER BY period;
                `;
                break;

            case 'year': 
                query = `
                    SELECT 
                        YEAR(u.CreatedAt) AS period,
                        CAST(YEAR(u.CreatedAt) AS VARCHAR(4)) AS period_label,
                        COUNT(u.LogID) AS activity_count
                    FROM UsageLogs u
                    WHERE u.CreatedAt >= DATEADD(year, -4, GETDATE())
                    ${validatedAction ? 'AND u.Action = @action' : ''}
                    GROUP BY YEAR(u.CreatedAt)
                    ORDER BY period;
                `;
                break;
        }

        const request = pool.request();
        if (validatedAction) {
            request.input('action', sql.VarChar(50), validatedAction);
        }

        const result = await request.query(query);

        const stats = {
            range,
            total_activity: result.recordset.reduce((sum, item) => sum + item.activity_count, 0),
            data: result.recordset.map(item => ({
                period: item.period_label,
                count: item.activity_count
            }))
        };

        res.json(successResponse(stats, null, 'Timeframe statistics retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error fetching timeframe stats:', err.message);
        const statusCode = err.message.includes('Invalid') ? 400 : 500;
        res.status(statusCode).json(errorResponse(err.message, statusCode, err.stack));
    }
});

/**
 * GET /stats/overview
 * Dashboard overview statistics
 */
router.get('/overview', isAdmin, async (req, res) => {
    console.log('[OVERVIEW] Fetching dashboard overview');
    
    try {
        logAdminAction(req.authenticatedUser.id, '/overview', {});

        const pool = getDbPool(req);
        const result = await pool.request().query(`
            SELECT 'total_users' as stat_type, COUNT(*) as value
            FROM Users
            
            UNION ALL
            
            SELECT 'active_users' as stat_type, COUNT(*) as value
            FROM Users WHERE UserStatus = 'active'
            
            UNION ALL
            
            SELECT 'total_notifications' as stat_type, COUNT(*) as value
            FROM Notifications
            
            UNION ALL
            
            SELECT 'unread_notifications' as stat_type, COUNT(*) as value
            FROM Notifications WHERE IsRead = 0
            
            UNION ALL
            
            SELECT 'new_users_today' as stat_type, COUNT(*) as value
            FROM Users WHERE CAST(CreatedAt AS DATE) = CAST(GETDATE() AS DATE)
            
            UNION ALL
            
            SELECT 'new_users_this_month' as stat_type, COUNT(*) as value
            FROM Users 
            WHERE YEAR(CreatedAt) = YEAR(GETDATE()) 
            AND MONTH(CreatedAt) = MONTH(GETDATE())
        `);

        const stats = {};
        result.recordset.forEach(row => {
            stats[row.stat_type] = row.value;
        });

        res.json(successResponse(stats, null, 'Overview statistics retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error fetching overview stats:', err.message);
        res.status(500).json(errorResponse('Failed to fetch overview statistics', 500, err.message));
    }
});

/**
 * GET /stats/export
 * Export user statistics with pagination
 */
router.get('/export', isAdmin, async (req, res) => {
    console.log('[EXPORT] Exporting statistics');
    
    try {
        const { limit, offset } = req.query;
        const { limit: validLimit, offset: validOffset } = validatePagination(limit, offset);

        logAdminAction(req.authenticatedUser.id, '/export', { limit: validLimit, offset: validOffset });

        const pool = getDbPool(req);
        const result = await pool.request()
            .input('limit', sql.Int, validLimit)
            .input('offset', sql.Int, validOffset)
            .query(`
                SELECT 
                    u.UserID,
                    u.Username,
                    u.Email,
                    u.UserRole,
                    u.AccountType,
                    u.UserStatus,
                    u.CreatedAt,
                    COUNT(n.NotificationID) as NotificationCount,
                    SUM(CASE WHEN n.IsRead = 0 THEN 1 ELSE 0 END) as UnreadNotifications
                FROM Users u
                LEFT JOIN Notifications n ON u.UserID = n.UserID
                GROUP BY u.UserID, u.Username, u.Email, u.UserRole, u.AccountType, u.UserStatus, u.CreatedAt
                ORDER BY u.CreatedAt DESC
                OFFSET @offset ROWS
                FETCH NEXT @limit ROWS ONLY
            `);

        const exportData = {
            export_date: new Date().toISOString(),
            total_records: result.recordset.length,
            pagination: {
                limit: validLimit,
                offset: validOffset
            },
            data: result.recordset.map(row => ({
                user_id: row.UserID,
                username: row.Username,
                email: row.Email,
                role: row.UserRole,
                account_type: row.AccountType,
                status: row.UserStatus,
                created_at: row.CreatedAt?.toISOString(),
                notification_count: row.NotificationCount || 0,
                unread_notifications: row.UnreadNotifications || 0
            }))
        };

        res.json(successResponse(exportData, null, 'Export data retrieved successfully'));

    } catch (err) {
        console.error('âŒ Error exporting stats:', err.message);
        res.status(500).json(errorResponse('Failed to export statistics', 500, err.message));
    }
});

/**
 * GET /stats/health
 * Health check endpoint
 */
router.get('/health', isAdmin, async (req, res) => {
    console.log('[HEALTH CHECK] Stats service health check');
    
    try {
        const pool = getDbPool(req);
        const result = await pool.request().query(`
            SELECT 
                COUNT(*) as total_records,
                COUNT(DISTINCT UserID) as unique_users
            FROM UsageLogs;
        `);

        res.json(successResponse({
            status: 'healthy',
            database: 'connected',
            total_logs: result.recordset[0].total_records,
            unique_users: result.recordset[0].unique_users
        }, null, 'Health check passed'));

    } catch (err) {
        console.error('âŒ Health check failed:', err.message);
        res.status(503).json(errorResponse('Service unavailable', 503, err.message));
    }
});

export default router;
```

### backend\routes\usageRoutes.js
```js
// backend/routes/usageRoutes.js
import express from 'express';
import sql from 'mssql';

const router = express.Router();

// POST /api/usage/log - Log user activity
router.post('/log', async (req, res) => {
  try {
    const pool = req.app.locals.db;
    if (!pool) {
      console.error('Usage log: DB pool not available', { headers: req.headers, body: req.body });
      return res.status(503).json({ success: false, error: 'Database not available' });
    }

    console.log('Usage log request body:', req.body);
    console.log('Usage log request headers:', {
      'x-user-id': req.headers['x-user-id'],
      'x-user-role': req.headers['x-user-role'],
      ua: req.headers['user-agent'],
    });

    const rawUserId = req.body?.user_id ?? req.body?.UserID ?? req.body?.user?.id ?? req.headers['x-user-id'] ?? null;
    const UserID = rawUserId ? parseInt(rawUserId, 10) : null;

    const action = (req.body?.action ?? '').toString().trim();
    if (!action) {
      return res.status(400).json({ success: false, error: 'Missing action in request body' });
    }

    const language = req.body?.language ?? req.body?.lang ?? null;
    const detailsObj = req.body?.metadata ?? req.body?.details ?? req.body?.message ?? {};
    const Details = (typeof detailsObj === 'string') ? detailsObj : JSON.stringify(detailsObj);
    const ipHeader = req.headers['x-forwarded-for'] || '';
    const ipFromHeader = ipHeader.split(',').map(s => s.trim()).find(Boolean) || null;
    const IPAddress = (ipFromHeader || req.ip || req.socket?.remoteAddress || '').toString();

    const UserAgent = (req.headers['user-agent'] || req.body?.user_agent || '').toString();

    await pool.request()
      .input('UserID', sql.Int, UserID)
      .input('Action', sql.VarChar(255), action)
      .input('Language', sql.VarChar(50), language)
      .input('Details', sql.NVarChar(sql.MAX), Details)
      .input('IPAddress', sql.VarChar(100), IPAddress)
      .input('UserAgent', sql.NVarChar(sql.MAX), UserAgent)
      .query(`
        INSERT INTO UsageLogs 
          (UserID, Action, Language, Details, IPAddress, UserAgent, CreatedAt)
        VALUES 
          (@UserID, @Action, @Language, @Details, @IPAddress, @UserAgent, GETDATE())
      `);

    return res.json({ success: true });
  } catch (error) {
    console.error('Error logging usage:', error.stack || error);
    return res.status(500).json({ success: false, error: 'Failed to log usage', detail: error?.message });
  }
});

// Trong usageRoutes.js - Ä‘áº£m báº£o endpoint cleanup dÃ¹ng stored procedure
router.post('/cleanup', async (req, res) => {
  try {
    const pool = req.app.locals.db;
    const daysToKeep = req.body.days !== undefined ? req.body.days : 30;
    
    const result = await pool.request()
      .input('DaysToKeep', sql.Int, daysToKeep)
      .execute('sp_CleanupUsageLogs');
    
    const cleanupResult = result.recordset[0];
    
    if (cleanupResult.Status === 'Success') {
      return res.json({ 
        success: true, 
        message: `Deleted ${cleanupResult.DeletedRows} logs older than ${daysToKeep} days`,
        deletedCount: cleanupResult.DeletedRows,
        cutoffDate: cleanupResult.CutoffDate,
        cleanupDate: cleanupResult.CleanupDate
      });
    } else {
      return res.status(500).json({ 
        success: false, 
        error: 'Cleanup failed', 
        detail: cleanupResult.ErrorMessage 
      });
    }
  } catch (error) {
    console.error('Error cleaning up logs:', error);
    return res.status(500).json({ success: false, error: 'Cleanup failed', detail: error?.message });
  }
});

export default router;
```

### backend\routes\userRoutes.js
```js
// backend/routes/userRoutes.js - FIXED VERSION WITH isAdmin MIDDLEWARE
import express from 'express';
import sql from 'mssql';
import bcrypt from 'bcrypt';
import { createNotification } from './notificationRoutes.js';

const router = express.Router();

function getDbPool(req) {
    if (!req.app.locals.db) {
        console.error('âŒ Database pool not available in req.app.locals.db');
        throw new Error('Database pool not available.');
    }
    console.log('âœ… Database pool retrieved successfully');
    return req.app.locals.db;
}

const isAdmin = (req, res, next) => {
    console.log('ğŸ” Admin middleware - checking authorization...');
    const userRole = req.headers['x-user-role'] || req.body.userRole;
    console.log(`ğŸ” Extracted user role: "${userRole}"`);

    if (userRole === 'admin') {
        console.log('âœ… Admin access granted');
        next();
    } else {
        console.log(`âŒ Admin access denied. Role: "${userRole}"`);
        res.status(403).json({ 
            success: false, 
            error: 'Access denied. Admin privileges required.',
            receivedRole: userRole,
            expectedRole: 'admin'
        });
    }
};

// --- Update user by ID (for admin.js fallback compatibility)
router.put('/:id', async (req, res) => {
    const userId = req.params.id;
    const { username, email, phone, fullName, role, accountType, status } = req.body;

    if (!username || !email || !fullName) {
        return res.status(400).json({
            success: false,
            error: 'Username, email, and full name are required.'
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        const query = `
            UPDATE Users
            SET 
                Username = @username,
                Email = @email,
                Phone = @phone,
                fullName = @fullName,
                UserRole = @role,
                AccountType = @accountType,
                UserStatus = @status
            WHERE UserID = @updateUserId;
        `;

        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('fullName', sql.NVarChar(100), fullName);
        request.input('role', sql.NVarChar(50), role || 'user');
        request.input('accountType', sql.NVarChar(50), accountType || 'free');
        request.input('status', sql.NVarChar(50), status || 'active');
        request.input('updateUserId', sql.Int, userId);

        const result = await request.query(query);

        if (result.rowsAffected[0] > 0) {
            res.json({ success: true, message: 'User updated successfully.' });
        } else {
            res.status(404).json({ success: false, error: 'User not found or no changes made.' });
        }
    } catch (err) {
        res.status(500).json({
            success: false,
            error: 'Internal server error updating user.',
            details: err.message
        });
    }
});

// --- Register (for regular users, no admin required)
router.post('/register', async (req, res) => {
    const { username, password, email, phone, fullName } = req.body;
    
    console.log('ğŸ“ User registration attempt - FULL REQUEST BODY:', req.body);
    console.log('ğŸ“ Extracted fields:', {
        username,
        password: password ? '***' : 'MISSING',
        email,
        phone: phone || 'Not provided',
        fullName: fullName || 'MISSING'
    });

    if (!username || !password || !email || !fullName) {
        console.log('âŒ Registration failed: Missing required fields');
        console.log('âŒ Missing fields check:', {
            username: !username ? 'MISSING' : 'OK',
            password: !password ? 'MISSING' : 'OK', 
            email: !email ? 'MISSING' : 'OK',
            fullName: !fullName ? 'MISSING' : 'OK'
        });
        return res.status(400).json({ 
            success: false, 
            error: 'Username, password, email, and full name are required.',
            received: Object.keys(req.body)
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);

        console.log('ğŸ” Checking for existing username/email...');
        const checkResult = await request.query`
            SELECT COUNT(*) AS count FROM Users WHERE Username = @username OR Email = @email;
        `;

        if (checkResult.recordset[0].count > 0) {
            console.log('âŒ Registration failed: Username or email already exists');
            return res.status(409).json({ 
                success: false, 
                error: 'Username or email already exists.' 
            });
        }

        console.log('ğŸ” Hashing password...');
        const hashedPassword = await bcrypt.hash(password, 10);

        const query = `
            INSERT INTO Users (Username, PasswordHash, Email, Phone, UserRole, fullName, CreatedAt, UserStatus, AccountType)
            VALUES (@username, @hashedPassword, @email, @phone, 'user', @fullName, GETDATE(), 'active', 'free');
        `;

        request.input('hashedPassword', sql.NVarChar(255), hashedPassword);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('fullName', sql.NVarChar(100), fullName);

        console.log('ğŸ’¾ Inserting new user into database...');
        await request.query(query);

        console.log('âœ… User registered successfully:', username);
        res.status(201).json({ 
            success: true, 
            message: 'User registered successfully.' 
        });

    } catch (err) {
        console.error('âŒ Error registering user:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error during registration.',
            details: err.message
        });
    }
});

// --- Login ---
router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    console.log('ğŸ”‘ Login attempt for username:', username);

    if (!username || !password) {
        return res.status(400).json({ 
            success: false, 
            error: 'Username and password are required.' 
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();
        request.input('username', sql.NVarChar(50), username);

        const result = await request.query`
            SELECT UserID, Username, PasswordHash, Email, Phone, UserRole, fullName
            FROM Users WHERE Username = @username;
        `;

        if (result.recordset.length === 0) {
            return res.status(401).json({ 
                success: false, 
                error: 'Invalid username or password.' 
            });
        }

        const user = result.recordset[0];
        const isPasswordValid = await bcrypt.compare(password, user.PasswordHash);

        if (isPasswordValid) {
            res.json({
                success: true,
                message: 'Login successful.',
                userId: user.UserID,      
                username: user.Username, 
                email: user.Email,        
                phone: user.Phone,        
                userRole: user.UserRole,
                fullName: user.fullName
            });
        } else {
            res.status(401).json({ 
                success: false, 
                error: 'Invalid username or password.' 
            });
        }

    } catch (err) {
        console.error('âŒ Error during login:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error during login.',
            details: err.message
        });
    }
});

// --- Admin: Update user ---
router.put('/admin/update/:id', isAdmin, async (req, res) => {
    const userId = req.params.id;
    const { username, email, phone, fullName, role, accountType, status } = req.body;

    console.log('ğŸ”„ Admin updating user:', { userId, username, accountType, status, role });

    if (!username || !email || !fullName) {
        return res.status(400).json({ 
            success: false, 
            error: 'Username, email, and full name are required.' 
        });
    }

    try {
        const pool = getDbPool(req);
        
        // FIRST: Get current user data for comparison
        const getCurrentUserRequest = pool.request();
        getCurrentUserRequest.input('userId', sql.Int, userId);
        
        const currentUserQuery = `
            SELECT Username, Email, Phone, fullName, UserRole, AccountType, UserStatus 
            FROM Users WHERE UserID = @userId;
        `;
        
        const currentUserResult = await getCurrentUserRequest.query(currentUserQuery);
        
        if (currentUserResult.recordset.length === 0) {
            return res.status(404).json({ success: false, error: 'User not found.' });
        }
        
        const currentUser = currentUserResult.recordset[0];
        console.log('ğŸ“‹ Current user data:', currentUser);

        // UPDATE user data
        const updateRequest = pool.request();
        const query = `
            UPDATE Users
            SET Username = @username, 
                Email = @email, 
                Phone = @phone, 
                fullName = @fullName,
                UserRole = @role,
                AccountType = @accountType,
                UserStatus = @status,
                UpdatedAt = GETDATE()
            WHERE UserID = @updateUserId;
        `;

        updateRequest.input('username', sql.NVarChar(50), username);
        updateRequest.input('email', sql.NVarChar(100), email);
        updateRequest.input('phone', sql.NVarChar(20), phone || null);
        updateRequest.input('fullName', sql.NVarChar(100), fullName);
        updateRequest.input('role', sql.NVarChar(50), role || 'user');
        updateRequest.input('accountType', sql.NVarChar(50), accountType || 'free');
        updateRequest.input('status', sql.NVarChar(50), status || 'active');
        updateRequest.input('updateUserId', sql.Int, userId);

        console.log('ğŸ’¾ Executing SQL update with params:', { 
            username, email, fullName, role, accountType, status 
        });

        const result = await updateRequest.query(query);

        if (result.rowsAffected[0] > 0) {
            const updatedUserQuery = pool.request();
            updatedUserQuery.input('userId', sql.Int, userId);
                         
            const updatedUserResult = await updatedUserQuery.query(`
                SELECT
                    UserID, Username, Email, Phone, UserRole,
                    FullName, AccountType, UserStatus,
                    FORMAT(CreatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as CreatedAt,
                    FORMAT(UpdatedAt, 'yyyy-MM-ddTHH:mm:ss.fffZ') as UpdatedAt
                FROM Users WHERE UserID = @userId
            `);

            console.log('âœ… User updated successfully in database:', userId);
            console.log('ğŸ“… Updated user data:', updatedUserResult.recordset[0]);

            // CREATE NOTIFICATION for the updated user
            try {
                const adminId = req.headers['x-admin-id'] || req.headers['x-user-id'];
                const changes = [];
                if (currentUser.Username !== username) changes.push(`Username: ${currentUser.Username} â†’ ${username}`);
                if (currentUser.Email !== email) changes.push(`Email: ${currentUser.Email} â†’ ${email}`);
                if (currentUser.fullName !== fullName) changes.push(`Name: ${currentUser.fullName} â†’ ${fullName}`);
                if (currentUser.UserRole !== (role || 'user')) changes.push(`Role: ${currentUser.UserRole} â†’ ${role || 'user'}`);
                if (currentUser.AccountType !== (accountType || 'free')) changes.push(`Account: ${currentUser.AccountType} â†’ ${accountType || 'free'}`);
                if (currentUser.UserStatus !== (status || 'active')) changes.push(`Status: ${currentUser.UserStatus} â†’ ${status || 'active'}`);

                if (changes.length > 0) {
                    const notificationData = {
                        userID: parseInt(userId),
                        title: 'Account Updated by Administrator',
                        message: `Your account information has been updated. Changes: ${changes.join(', ')}`,
                        type: 'profile_update',
                        adminAction: 'update_user_profile',
                        adminID: adminId ? parseInt(adminId) : null,
                        metadata: {
                            changes: changes,
                            updatedFields: Object.keys(req.body),
                            timestamp: new Date().toISOString(),
                            previousValues: {
                                username: currentUser.Username,
                                email: currentUser.Email,
                                fullName: currentUser.fullName,
                                role: currentUser.UserRole,
                                accountType: currentUser.AccountType,
                                status: currentUser.UserStatus
                            }
                        }
                    };

                    console.log('Creating notification for user:', userId);
                    await createNotification(pool, notificationData);
                    console.log('Notification created successfully');
                } else {
                    console.log('No changes detected, skipping notification');
                }
            } catch (notificationError) {
                console.error('Error creating notification:', notificationError);
            }

            res.json({
                success: true,
                message: 'User updated successfully.',
                user: updatedUserResult.recordset[0] 
            });
        } else {
            res.status(404).json({ success: false, error: 'User not found or no changes made.' });
        }
    } catch (err) {
        console.error('âŒ Error updating user:', err);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error updating user.',
            details: err.message
        });
    }
});

// --- âœ… FIXED: Admin: Create user (for admin panel) - NOW WITH isAdmin MIDDLEWARE
router.post('/', isAdmin, async (req, res) => {
    const { username, password, email, phone, fullName, role, accountType, status } = req.body;

    console.log('ğŸ‘¤ Admin creating new user:', {
        username,
        email,
        phone: phone || 'Not provided',
        role: role || 'user (default)',
        accountType: accountType || 'free (default)',
        status: status || 'active (default)',
        fullName
    });

    if (!username || !password || !email || !fullName) {
        console.log('âŒ Admin create user failed: Missing required fields');
        return res.status(400).json({
            success: false,
            error: 'Username, password, email, and full name are required.'
        });
    }

    try {
        const pool = getDbPool(req);
        const request = pool.request();

        // Check for existing username/email
        request.input('username', sql.NVarChar(50), username);
        request.input('email', sql.NVarChar(100), email);

        console.log('ğŸ” Checking for existing username/email...');
        const checkResult = await request.query`
            SELECT COUNT(*) AS count FROM Users WHERE Username = @username OR Email = @email;
        `;

        if (checkResult.recordset[0].count > 0) {
            console.log('âŒ Admin create user failed: Username or email already exists');
            return res.status(409).json({
                success: false,
                error: 'Username or email already exists.'
            });
        }

        console.log('ğŸ” Hashing password...');
        const hashedPassword = await bcrypt.hash(password, 10);

        // Insert new user and get the new ID
        const insertQuery = `
            INSERT INTO Users (Username, PasswordHash, Email, Phone, UserRole, fullName, CreatedAt, UserStatus, AccountType)
            VALUES (@username, @hashedPassword, @email, @phone, @role, @fullName, GETDATE(), @status, @accountType);
            SELECT SCOPE_IDENTITY() as NewUserID;
        `;

        request.input('hashedPassword', sql.NVarChar(255), hashedPassword);
        request.input('phone', sql.NVarChar(20), phone || null);
        request.input('role', sql.NVarChar(50), role || 'user');
        request.input('fullName', sql.NVarChar(100), fullName);
        request.input('status', sql.NVarChar(50), status || 'active');
        request.input('accountType', sql.NVarChar(50), accountType || 'free');

        console.log('ğŸ’¾ Inserting new user into database...');
        const insertResult = await request.query(insertQuery);
        const newUserId = insertResult.recordset[0].NewUserID;

        //CREATE WELCOME NOTIFICATION
        try {
            const adminId = req.headers['x-admin-id'] || req.headers['x-user-id'];
            
            const notificationData = {
                userID: newUserId,
                title: 'Welcome to Grammar Checker!',
                message: `Welcome ${fullName}! Your account has been created by an administrator with ${accountType} access. You can now start using our grammar checking service.`,
                type: 'welcome',
                adminAction: 'create_user_account',
                adminID: adminId ? parseInt(adminId) : null,
                metadata: {
                    accountType: accountType || 'free',
                    userRole: role || 'user',
                    createdBy: 'admin',
                    timestamp: new Date().toISOString()
                }
            };

            console.log('ğŸ”” Creating welcome notification for new user:', newUserId);
            await createNotification(pool, notificationData);
            console.log('âœ… Welcome notification created successfully');
        } catch (notificationError) {
            console.error('âŒ Error creating welcome notification:', notificationError);
        }

        console.log('âœ… Admin created user successfully:', username);
        res.status(201).json({
            success: true,
            message: 'User created successfully.',
            userId: newUserId
        });
    } catch (err) {
        console.error('âŒ Error creating user:', err);
        res.status(500).json({
            success: false,
            error: 'Internal server error creating user.',
            details: err.message
        });
    }
});

// --- Admin: Delete user ---
router.delete('/admin/delete/:id', isAdmin, async (req, res) => {
    const userId = req.params.id;

    try {
        const pool = getDbPool(req);
        const request = pool.request();
        request.input('userId', sql.Int, userId);

        const result = await request.query`
            DELETE FROM Users WHERE UserID = @userId;
        `;

        if (result.rowsAffected[0] > 0) {
            res.json({ success: true, message: 'User deleted successfully.' });
        } else {
            res.status(404).json({ success: false, error: 'User not found.' });
        }

    } catch (err) {
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error deleting user.',
            details: err.message
        });
    }
});

export default router;
```

### backend\services\cohereService.js
```js
/*import { CohereClient } from 'cohere-ai';

const apiKey = process.env.COHERE_API_KEY;
let cohere = null;

if (apiKey?.trim()) {
  cohere = new CohereClient({ token: apiKey });
  console.log('âœ… Cohere client initialized.');
} else {
  console.warn('âš ï¸ COHERE_API_KEY not found. Cohere will not be used.');
}

export async function fallbackCheckWithCohere(text) {
  if (!cohere) return [];

  try {
    console.log("ğŸ“ Checking with Cohere:", JSON.stringify(text));

    const prompt = `
You are an English grammar correction expert. Analyze the following text.

Instructions:
- Only identify grammar, spelling, punctuation, or capitalization mistakes.
- For each issue, output EXACTLY 1 line using this strict format:
  original | correction | explanation
- The "original" must be a word or phrase from the input.
- The "correction" must differ from the original.
- The "explanation" must be brief.
- Do NOT repeat same word (e.g., "had â had").
- Do NOT rewrite entire sentence.
- Do NOT return full sentence corrections.

Example:
Input: she have went to the store yesterday
Output:
have | had | Use "had" for past perfect tense.
went | gone | "Gone" is the correct past participle.
(no period) | . | Add a period at the end.

Now correct this:
"""${text}"""`;
console.log("ğŸ“¤ Prompt sent to Cohere:\n", prompt);

    const response = await cohere.generate({
      model: 'command',
      prompt,
      maxTokens: 500,
      temperature: 0.1,
    });

    const raw = response.generations?.[0]?.text || '';
    console.log('ğŸ“¤ Cohere raw response:\n', raw);

    const matches = [];
    const usedOffsets = new Set();
    const regex = /^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/gm;
    let match;

    while ((match = regex.exec(raw)) !== null) {
      const original = match[1].trim();
      const replacement = match[2].trim();
      const explanation = match[3].trim();

      if (!original || original === replacement) continue;

      let offset = -1;
      let searchStart = 0;
      while (true) {
        offset = text.indexOf(original, searchStart);
        if (offset === -1 || !usedOffsets.has(offset)) break;
        searchStart = offset + 1;
      }

      if (offset === -1) continue;
      usedOffsets.add(offset);

      matches.push({
        offset,
        length: original.length,
        message: explanation,
        replacements: [{ value: replacement }],
      });
    }

    console.log('âœ… Parsed matches:', matches);
    return matches;
  } catch (error) {
    console.error('âŒ Cohere fallbackCheck error:', error);
    return [];
  }
}

const validationCache = new Map();

export async function validateCorrectionsWithCohere(text, matches) {
  if (!cohere || !Array.isArray(matches) || matches.length === 0) return [];

  const cacheKey = `${text}_${JSON.stringify(matches)}`;
  if (validationCache.has(cacheKey)) return validationCache.get(cacheKey);

  try {
    const suggestionsList = matches.map((m, index) => {
      const original = text.slice(m.offset, m.offset + m.length);
      const replacement = m.replacements?.[0]?.value || '[No suggestion]';
      return `${index + 1}. ${original} â ${replacement}`;
    }).join('\n');

    const prompt = `You are a grammar expert. Validate if the following suggestions are correct.

Text:
${text}

Suggestions:
${suggestionsList}

Reply only with valid suggestions in format:
original â replacement`;

    const response = await cohere.generate({
      model: 'command',
      prompt,
      maxTokens: 500,
      temperature: 0.2,
    });

    const raw = response.generations?.[0]?.text || '';
    console.log('ğŸ“¤ Cohere validation raw response:\n', raw);

    const validated = raw.match(/(.+?)\s*â\s*(.+)/g) || [];
    const confirmed = validated.map(v => {
      const parts = v.match(/(.+?)\s*â\s*(.+)/);
      return {
        from: parts[1].trim(),
        to: parts[2].trim()
      };
    });

    const filteredMatches = matches.map(m => {
      const original = text.slice(m.offset, m.offset + m.length);
      const confirmedCorrection = confirmed.find(c => c.from === original && c.from !== c.to);
      if (confirmedCorrection) {
        return {
          ...m,
          replacements: [{ value: confirmedCorrection.to }]
        };
      } else {
        console.log(`ğŸ—‘ï¸ Removed invalid or duplicate suggestion: "${original}" â "${m.replacements?.[0]?.value}"`);
        return null;
      }
    }).filter(Boolean);

    validationCache.set(cacheKey, filteredMatches);
    return filteredMatches;
  } catch (error) {
    console.error('âŒ Cohere validation error:', error);
    return [];
  }
}*/

```

### backend\services\languageDetectionService.js
```js
// backend/services/languageDetectionService.js
import cldFactory from 'cld3-asm';

// ================== SINGLETON PATTERN ==================
let languageDetectionServiceInstance = null;

export class LanguageDetectionService {
  constructor(options = {}) {
    this.cldInstance = null;
    this.initPromise = null;
    this.isInitialized = false;
    
    // Configuration
    this.config = {
      minBytes: options.minBytes || 20,
      maxBytes: options.maxBytes || 2000,
      enableCache: options.enableCache !== false,
      cacheTimeout: options.cacheTimeout || 10 * 60 * 1000,
      fallbackLanguage: options.fallbackLanguage || 'en-US',
      logLevel: options.logLevel || 'info'
    };
    this.detectionCache = new Map();
    
    if (this.config.enableCache) {
      setInterval(() => this.clearExpiredCache(), this.config.cacheTimeout);
    }

    this.initialize().catch(err => {
      if (this.config.logLevel === 'info') {
        console.warn('LanguageDetectionService initialization started (async).');
      }
    });
  }

  async initialize() {
    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = (async () => {
      try {
        if (this.config.logLevel === 'info') {
          console.log('Initializing CLD3 Language Detection Service...');
        }
        
        const module = await cldFactory.loadModule();
        this.cldInstance = module.create(this.config.minBytes, this.config.maxBytes);
        
        this.isInitialized = true;
        
        if (this.config.logLevel === 'info') {
          console.log('CLD3 Language Detection Service ready');
        }
        
        return this.cldInstance;
      } catch (error) {
        console.error('Failed to initialize CLD3:', error);
        console.error('Available cldFactory methods:', Object.keys(cldFactory || {}));
        this.initPromise = null; 
        throw error;
      }
    })();

    return this.initPromise;
  }

  // ================== LANGUAGE MAPPING ==================
  getCLD3ToLanguageToolMapping() {
    return {
      'en': 'en-US', 'fr': 'fr', 'de': 'de-DE', 'es': 'es', 'it': 'it',
      'pt': 'pt', 'nl': 'nl', 'ru': 'ru-RU', 'pl': 'pl-PL', 'sv': 'sv-SE',
      'da': 'da-DK', 'no': 'no', 'fi': 'fi-FI', 'is': 'is-IS',
      'cs': 'cs-CZ', 'sk': 'sk-SK', 'hu': 'hu-HU', 'ro': 'ro-RO', 'bg': 'bg-BG',
      'hr': 'hr-HR', 'sr': 'sr', 'sl': 'sl-SI', 'lv': 'lv-LV', 'lt': 'lt-LT',
      'et': 'et-EE', 'mk': 'mk-MK', 'mt': 'mt-MT',
      'ca': 'ca-ES', 'eu': 'eu', 'gl': 'gl-ES', 'cy': 'cy', 'ga': 'ga-IE',
      'br': 'br-FR', 'ast': 'ast',
      'ar': 'ar', 'he': 'he', 'fa': 'fa', 'ur': 'ur', 'ps': 'ps',
      'zh': 'zh-CN', 'zh-cn': 'zh-CN', 'zh-tw': 'zh-TW',
      'ja': 'ja-JP', 'ko': 'ko-KR', 'vi': 'vi-VN', 'th': 'th', 'lo': 'lo-LA',
      'km': 'km-KH', 'my': 'my-MM', 'si': 'si-LK', 'ta': 'ta-IN', 'te': 'te-IN',
      'ml': 'ml-IN', 'kn': 'kn-IN', 'hi': 'hi-IN', 'bn': 'bn-BD', 'gu': 'gu-IN',
      'pa': 'pa-IN', 'mr': 'mr-IN', 'ne': 'ne-NP', 'or': 'or-IN', 'as': 'as-IN',
      'tr': 'tr', 'az': 'az', 'kk': 'kk', 'ky': 'ky', 'uz': 'uz',
      'tg': 'tg', 'mn': 'mn', 'ka': 'ka', 'hy': 'hy', 'be': 'be',
      'uk': 'uk-UA', 'tl': 'tl-PH', 'ceb': 'ceb', 'haw': 'haw',
      'mg': 'mg', 'sm': 'sm', 'to': 'to', 'fj': 'fj'
    };
  }

  // ================== ENHANCED PATTERN-BASED PRE-CHECK ==================
  preCheckPatterns(text) {
      console.log('[LDS] preCheckPatterns() called with text length:', text.length);
      console.log('[LDS] First 30 chars:', text.slice(0, 30));
      console.log('[LDS] Char codes (first 5):', [...text.slice(0, 5)].map(c => c.charCodeAt(0)));

    if (!text || typeof text !== 'string') return null;

    // ========== CJK LANGUAGES (PRIORITY: HIGHEST) ==========
    // Russian/Cyrillic - MUST CHECK BEFORE OTHERS
    if (/[\u0400-\u04FF]{3,}/.test(text)) {
      return {
        detected_language: 'ru',
        confidence: 0.98,
        languagetool_code: 'ru-RU',
        reliable: true,
        source: 'pattern-cyrillic',
        detection_time_ms: 0
      };
    }

    // Japanese - MUST CHECK BEFORE CHINESE (has hiragana/katakana)
    if (/[\u3040-\u309F\u30A0-\u30FF]{2,}/.test(text)) {
      return {
        detected_language: 'ja',
        confidence: 0.99,
        languagetool_code: 'ja-JP',
        reliable: true,
        source: 'pattern-japanese',
        detection_time_ms: 0
      };
    }

    // Chinese (Simplified) - check for Han characters WITHOUT Japanese scripts
    if (/[\u4E00-\u9FFF]{3,}/.test(text) && !/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) {
      return {
        detected_language: 'zh',
        confidence: 0.99,
        languagetool_code: 'zh-CN',
        reliable: true,
        source: 'pattern-chinese',
        detection_time_ms: 0
      };
    }

    // Korean
    if (/[\uAC00-\uD7AF\u1100-\u11FF]{2,}/.test(text)) {
      return {
        detected_language: 'ko',
        confidence: 0.99,
        languagetool_code: 'ko-KR',
        reliable: true,
        source: 'pattern-korean',
        detection_time_ms: 0
      };
    }

    // Thai
    if (/[\u0E00-\u0E7F]{2,}/.test(text)) {
      return {
        detected_language: 'th',
        confidence: 0.99,
        languagetool_code: 'th',
        reliable: true,
        source: 'pattern-thai',
        detection_time_ms: 0
      };
    }

    // Arabic
    if (/[\u0600-\u06FF\u0750-\u077F]{2,}/.test(text)) {
      return {
        detected_language: 'ar',
        confidence: 0.99,
        languagetool_code: 'ar',
        reliable: true,
        source: 'pattern-arabic',
        detection_time_ms: 0
      };
    }

    // ========== EUROPEAN LANGUAGES (PRIORITY: HIGH) ==========
    // Portuguese - improved patterns
    if (/\b(vocÃª|estÃ¡|nÃ£o|tambÃ©m|portuguÃªs|Ã©|de|que|para|com|uma|um|como|mais|por|foi|ser|ao|aos|dos|das|o|a|e|em)\b/i.test(text) &&
        /[\u00E3\u00E7\u00E9\u00EA\u00F5]/i.test(text)) {
      return {
        detected_language: 'pt',
        confidence: 0.92,
        languagetool_code: 'pt',
        reliable: true,
        source: 'pattern-portuguese',
        detection_time_ms: 0
      };
    }

    // Italian - improved patterns (avoid confusion with Portuguese)
    if (/\b(piÃ¹|meno|perÃ²|anche|giÃ |cosÃ¬|perchÃ©|quando|sono|fatto|molto|troppo|gli|il|lo|la|mi|ti|ci|vi|gliela|gliele)\b/i.test(text)) {
      return {
        detected_language: 'it',
        confidence: 0.93,
        languagetool_code: 'it',
        reliable: true,
        source: 'pattern-italian',
        detection_time_ms: 0
      };
    }

    // Spanish - Â¿Â¡ characters are very strong signals
    if (/[Â¿Â¡]/.test(text)) {
      return {
        detected_language: 'es',
        confidence: 0.95,
        languagetool_code: 'es',
        reliable: true,
        source: 'pattern-spanish',
        detection_time_ms: 0
      };
    }

    // Spanish - keyword patterns
    if (/\b(espaÃ±ol|Ã±|el|la|de|que|y|a|en|es|por|para|con|una|un|como|mÃ¡s)\b/i.test(text) &&
        /[\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1]/i.test(text)) {
      return {
        detected_language: 'es',
        confidence: 0.90,
        languagetool_code: 'es',
        reliable: true,
        source: 'pattern-spanish-accent',
        detection_time_ms: 0
      };
    }

    // German
    if (/\b(der|die|das|und|ist|nicht|du|was|sind|ein|eine|mit|auf|fÃ¼r|den|dem|zu|von|dass|haben|wir|sie|ich|werden|bin|bist|sein)\b/i.test(text)) {
      return {
        detected_language: 'de',
        confidence: 0.94,
        languagetool_code: 'de-DE',
        reliable: true,
        source: 'pattern-german',
        detection_time_ms: 0
      };
    }

    // French
    if (/\b(le|la|de|et|un|une|est|que|pas|pour|par|sur|avec|nous|vous|du|il|elle|ce|qui)\b/i.test(text)) {
      return {
        detected_language: 'fr',
        confidence: 0.92,
        languagetool_code: 'fr',
        reliable: true,
        source: 'pattern-french',
        detection_time_ms: 0
      };
    }

    // English - FALLBACK PATTERN (very generic, low confidence)
    const englishPattern = /\b(?:the|and|is|are|was|were|have|has|had|do|does|did|will|would|can|could|not|your|my|their|they|we|I)\b/i;
    const matches = text.toLowerCase().match(new RegExp(englishPattern, 'gi')) || [];
    if (matches.length >= 3) {
      return {
        detected_language: 'en',
        confidence: 0.88,
        languagetool_code: 'en-US',
        reliable: true,
        source: 'pattern-english',
        detection_time_ms: 0
      };
    }

    return null;
  }

  // ================== MAIN DETECTION METHOD ==================
  async detectLanguage(text, options = {}) {
    try {
      if (!text || typeof text !== 'string') {
        throw new Error('Invalid input: text must be a non-empty string');
      }
      text = String(text).normalize('NFKC').trim();

      if (this.config.logLevel === 'debug' || this.config.logLevel === 'info') {
        console.log('\n=== [LDS] LANGUAGE DETECTION DEBUG ===');
        console.log('[LDS] Input text (trimmed):', text);
        console.log('[LDS] Text length:', text.length);
      }

      // === CHECK CACHE FIRST ===
      if (this.config.enableCache && !options.skipCache) {
        const cached = this.getFromCache(text);
        if (cached) {
          if (this.config.logLevel === 'info' || this.config.logLevel === 'debug') {
            console.log('[LDS] âœ… CACHE HIT');
          }
          return cached;
        }
      }

      // === PATTERN-BASED CHECK (PRIORITY) ===
      const preCheck = this.preCheckPatterns(text);
      if (preCheck) {
        if (this.config.logLevel === 'info' || this.config.logLevel === 'debug') {
          console.log(`[LDS] âœ… Pattern matched! Source: ${preCheck.source}`);
        }
        this.setCache(text, preCheck);
        return preCheck;
      }

      // === CLD3 FALLBACK (for texts without clear patterns) ===
      if (!this.isInitialized) {
        if (this.config.logLevel === 'info') {
          console.log('[LDS] Initializing CLD3...');
        }
        await this.initialize();
      }

      if (!this.cldInstance) {
        throw new Error('CLD3 not initialized');
      }

      if (this.config.logLevel === 'debug' || this.config.logLevel === 'info') {
        console.log('[LDS] Using CLD3 for detection...');
      }

      const startTime = Date.now();
      const result = this.cldInstance.findLanguage(text);
      const detectionTime = Date.now() - startTime;

      // === If no language recognized, fallback ===
      if (!result || !result.language) {
        if (this.config.logLevel === 'warn' || this.config.logLevel === 'info') {
          console.warn('[LDS] âš ï¸ CLD3 returned no result - using fallback');
        }
        const fallbackResult = {
          detected_language: 'en',
          confidence: 0.5,
          languagetool_code: this.config.fallbackLanguage,
          reliable: false,
          source: 'fallback-no-detection',
          detection_time_ms: detectionTime
        };
        this.setCache(text, fallbackResult);
        return fallbackResult;
      }

      // === Map & normalize result ===
      const mapping = this.getCLD3ToLanguageToolMapping();
      const ltCode = mapping[result.language] || this.config.fallbackLanguage;
      const confidence = Number(result.probability ?? result.confidence ?? 0);

      const detectionResult = {
        detected_language: result.language,
        confidence,
        languagetool_code: ltCode,
        reliable: result.is_reliable !== undefined ? result.is_reliable : (confidence > 0.7),
        source: 'cld3',
        detection_time_ms: detectionTime
      };

      if (this.config.logLevel === 'info' || this.config.logLevel === 'debug') {
        console.log(`[LDS] CLD3 detected: ${result.language} (${(confidence * 100).toFixed(1)}%)`);
      }

      if (this.config.enableCache) {
        this.setCache(text, detectionResult);
      }

      return detectionResult;

    } catch (error) {
      console.error('[LDS] âŒ Detection error:', error.message);

      const errorResult = {
        detected_language: 'en',
        confidence: 0.5,
        languagetool_code: this.config.fallbackLanguage,
        reliable: false,
        source: 'error-fallback',
        error: error.message
      };

      return errorResult;
    }
  }

  // ================== MULTIPLE LANGUAGE DETECTION ==================
  async detectMultipleLanguages(text, maxResults = 3) {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      if (!this.cldInstance) {
        throw new Error('CLD3 not initialized');
      }

      const results = this.cldInstance.findMostFrequentLanguages(text, maxResults);
      const mapping = this.getCLD3ToLanguageToolMapping();

      return results.map(result => ({
        detected_language: result.language,
        confidence: Number(result.probability ?? result.confidence ?? 0),
        languagetool_code: mapping[result.language] || this.config.fallbackLanguage,
        reliable: result.is_reliable !== undefined ? result.is_reliable : true,
        source: 'cld3-multiple'
      }));

    } catch (error) {
      console.error('[LDS] Multiple language detection error:', error.message);
      return [{
        detected_language: 'en',
        confidence: 0.5,
        languagetool_code: this.config.fallbackLanguage,
        reliable: false,
        source: 'error-fallback',
        error: error.message
      }];
    }
  }

  // ================== CACHE METHODS ==================
  _getCacheKey(text) {
    const textForCache = text.length > 200 ? text.substring(0, 200) : text;
    return this._hashString(textForCache);
  }

  _hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString();
  }

  setCache(text, value) {
    if (!this.config.enableCache) return;
    const key = this._getCacheKey(text);
    this.detectionCache.set(key, { data: value, timestamp: Date.now() });
  }

  getFromCache(text) {
    if (!this.config.enableCache) return null;
    const key = this._getCacheKey(text);
    const cached = this.detectionCache.get(key);
    
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > this.config.cacheTimeout) {
      this.detectionCache.delete(key);
      return null;
    }
    
    return cached.data;
  }

  clearExpiredCache() {
    const now = Date.now();
    for (const [key, value] of this.detectionCache.entries()) {
      if (now - value.timestamp > this.config.cacheTimeout) {
        this.detectionCache.delete(key);
      }
    }
  }

  // ================== UTILITY METHODS ==================
  async healthCheck() {
    try {
      const isReady = this.isInitialized && this.cldInstance !== null;
      return {
        status: isReady ? 'healthy' : 'initializing',
        cld3_initialized: this.isInitialized,
        cache_size: this.detectionCache.size
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }

  getCacheStats() {
    return {
      size: this.detectionCache.size,
      enabled: this.config.enableCache,
      timeout_ms: this.config.cacheTimeout
    };
  }

  clearCache() {
    this.detectionCache.clear();
    console.log('[LDS] Cache cleared');
  }

  async cleanup() {
    this.detectionCache.clear();
    
    if (this.cldInstance && typeof this.cldInstance.dispose === 'function') {
      this.cldInstance.dispose();
    }
    
    this.cldInstance = null;
    this.isInitialized = false;
    this.initPromise = null;
    console.log('[LDS] Service cleaned up');
  }
}

// ================== SINGLETON FACTORY ==================
export async function getLanguageDetectionService(options = {}) {
  if (!languageDetectionServiceInstance) {
    languageDetectionServiceInstance = new LanguageDetectionService(options);
    await languageDetectionServiceInstance.initialize();
  }
  return languageDetectionServiceInstance;
}

// ================== CONVENIENCE FUNCTIONS ==================
export async function detectLanguage(text, options = {}) {
  const service = await getLanguageDetectionService();
  return service.detectLanguage(text, options);
}

export async function detectMultipleLanguages(text, maxResults = 3) {
  const service = await getLanguageDetectionService();
  return service.detectMultipleLanguages(text, maxResults);
}

export default LanguageDetectionService;
```

### backend\services\languageToolService.js
```js
import fetch from 'node-fetch';
import { getLanguageDetectionService } from './languageDetectionService.js';
import GrammarCheckerFactory from '../grammar_checkers/index.js';

class LanguageToolError extends Error {
  constructor(message, statusCode, details = null) {
    super(message);
    this.name = 'LanguageToolError';
    this.statusCode = statusCode;
    this.details = details;
  }
}

class LanguageToolService {
  constructor() {
    this.baseURL = process.env.LANGUAGETOOL_API_URL || 'http://localhost:8081/v2';
    this.timeout = parseInt(process.env.API_TIMEOUT) || 10000;
    this.grammarCache = new Map();
    this.grammarCacheTimeout = 15 * 60 * 1000;
    this.languageDetectionService = null;
    this.languageDetectionReady = false;
    this.customCheckerLanguages = ['ru-RU', 'ru', 'zh-CN', 'zh', 'ja-JP', 'ja', 'es', 'es-ES', 'it', 'it-IT'];
    this.initLanguageDetection();
    setInterval(() => this.clearExpiredGrammarCache(), this.grammarCacheTimeout);
  }

  async initLanguageDetection() {
    try {
      this.languageDetectionService = await getLanguageDetectionService({
        logLevel: 'info',
        cacheTimeout: 10 * 60 * 1000,
        fallbackLanguage: 'en-US'
      });
      this.languageDetectionReady = true;
      console.log('âœ… LanguageTool Service with CLD3 detection ready');
    } catch (error) {
      console.warn('âš ï¸ Failed to initialize CLD3 service:', error.message);
      this.languageDetectionReady = false;
    }
  }

  cleanText(text) {
    return text
      .replace(/\s+/g, ' ')
      .replace(/[""]/g, '"')
      .replace(/['']/g, "'")
      .replace(/(\.\s*\.)+/g, '.')
      .replace(/\s([?.!])/g, '$1')
      .trim();
  }

  normalizeLang(lang) {
    const LT_LANG_MAP = {
      fr: 'fr',
      'fr-FR': 'fr',
      de: 'de-DE',
      'de-DE': 'de-DE',
      es: 'es',
      it: 'it',
      pt: 'pt',
      en: 'en-US',
      'en-US': 'en-US',
      'en-GB': 'en-GB',
      ru: 'ru-RU',
      'ru-RU': 'ru-RU',
      zh: 'zh-CN',
      'zh-CN': 'zh-CN',
      ja: 'ja-JP',
      'ja-JP': 'ja-JP'
    };
    return LT_LANG_MAP[lang] || lang || 'auto';
  }

  async detectLanguage(text) {
    if (this.languageDetectionService && this.languageDetectionReady) {
      try {
        const result = await this.languageDetectionService.detectLanguage(text);
        return {
          language: result.languagetool_code,
          confidence: result.confidence,
          reliable: result.reliable,
          source: result.source,
          detection_time_ms: result.detection_time_ms
        };
      } catch {
        return this.detectLanguageWithLanguageTool(text);
      }
    }
    return this.detectLanguageWithLanguageTool(text);
  }

  async detectLanguageWithLanguageTool(text) {
    const params = new URLSearchParams({ text, language: 'auto' });
    const start = Date.now();

    const res = await fetch(`${this.baseURL}/check`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });

    const json = await res.json();
    return {
      language: json.language?.detectedLanguage?.code || 'en-US',
      confidence: json.language?.detectedLanguage?.confidence || 0.5,
      reliable: true,
      source: 'languagetool-fallback',
      detection_time_ms: Date.now() - start
    };
  }

  async checkGrammar(text, language = 'auto', options = {}) {
    const cleanedText = this.cleanText(text);
    const start = Date.now();

    const cacheKey = `${language}-${cleanedText}`;
    const cached = this.grammarCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.grammarCacheTimeout) {
      console.log('[CACHE HIT]', cacheKey.substring(0, 40) + '...');
      return cached.data;
    }

    let detectionInfo = null;
    let finalLang = language;

    if (language === 'auto') {
      try {
        detectionInfo = await this.detectLanguage(cleanedText);
        finalLang = detectionInfo.language;
        console.log(`ğŸ” Detected language: ${finalLang} (${(detectionInfo.confidence * 100).toFixed(1)}%)`);
      } catch (error) {
        console.warn('âš ï¸ Language detection failed, fallback to en-US');
        finalLang = 'en-US';
      }
    }

    if (!finalLang) finalLang = 'en-US';

    const ltLang = this.normalizeLang(finalLang);
    console.log('[GRAMMAR CHECK] Using language:', ltLang);

    if (this.customCheckerLanguages.includes(ltLang)) {
      console.log('[GRAMMAR CHECK] Using custom checker for:', ltLang);
      
      try {
        const customResult = GrammarCheckerFactory.check(cleanedText, ltLang);
        
        if (customResult.success) {
          const result = {
            success: true,
            text: cleanedText,
            language: { code: ltLang },
            matches: customResult.matches,
            performance: {
              total_time_ms: Date.now() - start,
              match_count: customResult.matches.length
            },
            language_detection: detectionInfo,
            source: customResult.source
          };

          this.grammarCache.set(cacheKey, { 
            data: result, 
            timestamp: Date.now() 
          });

          console.log(`âœ… Custom grammar check completed: ${result.matches.length} matches in ${result.performance.total_time_ms}ms`);
          return result;
        } else {
          console.warn('[GRAMMAR CHECK] Custom checker failed:', customResult.error);
        }
      } catch (error) {
        console.error('[GRAMMAR CHECK] Custom checker error:', error.message);
      }
    }

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), this.timeout);

    try {
      const params = new URLSearchParams({
        text: cleanedText,
        language: ltLang,
        enabledOnly: 'false',
        preferredInterfaceLanguage: 'en'
      });

      console.log('[GRAMMAR CHECK] Request params:', {
        text: cleanedText.substring(0, 50),
        language: ltLang,
        enabledOnly: 'false'
      });

      const res = await fetch(`${this.baseURL}/check`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params.toString(),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!res.ok) {
        const errorText = await res.text();
        console.error('[GRAMMAR CHECK] API Response:', res.status, errorText);
        throw new LanguageToolError(
          `LanguageTool API error: ${res.status}`,
          res.status
        );
      }

      const data = await res.json();
      const responseTime = Date.now() - start;

      const result = {
        success: true,
        text: cleanedText,
        language: { code: ltLang },
        matches: data?.matches || [],
        performance: {
          total_time_ms: responseTime,
          match_count: (data?.matches || []).length
        },
        language_detection: detectionInfo,
        source: 'languagetool-api'
      };

      this.grammarCache.set(cacheKey, { 
        data: result, 
        timestamp: Date.now() 
      });

      console.log(`âœ… Grammar check completed: ${result.matches.length} matches in ${responseTime}ms`);

      return result;

    } catch (error) {
      clearTimeout(timeout);

      if (error.name === 'AbortError') {
        throw new LanguageToolError(
          `Grammar check timeout (${this.timeout}ms)`,
          408
        );
      }

      console.error('[GRAMMAR CHECK] Error:', error.message);
      throw new LanguageToolError(
        error.message || 'Grammar check failed',
        500,
        error
      );
    }
  }

  clearExpiredGrammarCache() {
    const now = Date.now();
    let clearedCount = 0;

    for (const [key, value] of this.grammarCache.entries()) {
      if (now - value.timestamp > this.grammarCacheTimeout) {
        this.grammarCache.delete(key);
        clearedCount++;
      }
    }

    if (clearedCount > 0) {
      console.log(`ğŸ§¹ Cleared ${clearedCount} expired cache entries`);
    }
  }

  // ğŸ“Š Get cache stats
  getCacheStats() {
    return {
      cache_size: this.grammarCache.size,
      cache_timeout_ms: this.grammarCacheTimeout,
      custom_checker_languages: this.customCheckerLanguages
    };
  }
}

const languageToolService = new LanguageToolService();
export default languageToolService;
```

### backend\services\libreTranslateService.js
```js
// backend/services/libreTranslateService.js
/*import fetch from 'node-fetch';

class LibreTranslateService {
  constructor() {
    this.baseURL = process.env.LIBRETRANSLATE_URL || 'http://localhost:8080';
    this.apiKey = process.env.LIBRETRANSLATE_API_KEY || '';
    this.timeout = 10000;
    this.cache = new Map();
    this.cacheTimeout = 30 * 60 * 1000; 
    
    setInterval(() => this.clearExpiredCache(), this.cacheTimeout);
    this.checkConnection();
  }

  async checkConnection() {
    try {
      const res = await fetch(`${this.baseURL}/languages`, { timeout: 5000 });
      if (res.ok) {
        const langs = await res.json();
        console.log(`âœ… LibreTranslate connected at ${this.baseURL} (${langs.length} languages)`);
      }
    } catch (err) {
      console.warn('âš ï¸ LibreTranslate not available:', err.message);
    }
  }

  normalizeLanguageCode(langCode) {
    const mapping = {
      'en-US': 'en', 'en-GB': 'en', 'en': 'en',
      'fr-FR': 'fr', 'fr': 'fr',
      'de-DE': 'de', 'de': 'de',
      'es-ES': 'es', 'es': 'es',
      'it-IT': 'it', 'it': 'it',
      'pt-PT': 'pt', 'pt-BR': 'pt', 'pt': 'pt',
      'vi-VN': 'vi', 'vi': 'vi',
      'ru-RU': 'ru', 'ru': 'ru',
      'zh-CN': 'zh', 'zh-TW': 'zt', 'zh': 'zh',
      'ja-JP': 'ja', 'ja': 'ja',
      'ko-KR': 'ko', 'ko': 'ko',
      'nl-NL': 'nl', 'nl': 'nl',
      'pl-PL': 'pl', 'pl': 'pl',
      'ar': 'ar', 'hi-IN': 'hi', 'tr-TR': 'tr', 'uk-UA': 'uk'
    };
    return mapping[langCode] || langCode.split('-')[0];
  }

  async translateToEnglish(text, sourceLang) {
    if (!text || !sourceLang) return text;
    if (sourceLang.startsWith('en')) return text;
    
    const cacheKey = `${sourceLang}:${text}`;
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.text;
    }

    try {
      const source = this.normalizeLanguageCode(sourceLang);
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), this.timeout);

      const body = {
        q: text,
        source: source,
        target: 'en',
        format: 'text'
      };

      if (this.apiKey) {
        body.api_key = this.apiKey;
      }

      const res = await fetch(`${this.baseURL}/translate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!res.ok) {
        throw new Error(`LibreTranslate error: ${res.status}`);
      }

      const data = await res.json();
      const translated = data.translatedText || text;

      this.cache.set(cacheKey, { text: translated, timestamp: Date.now() });
      return translated;
    } catch (err) {
      console.warn(`âš ï¸ Translation failed (${sourceLang}): ${err.message}`);
      return text;
    }
  }

  async translateBatch(texts, sourceLang) {
    if (!Array.isArray(texts) || texts.length === 0) return [];
    return Promise.all(texts.map(text => this.translateToEnglish(text, sourceLang)));
  }

  clearExpiredCache() {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.cacheTimeout) {
        this.cache.delete(key);
      }
    }
  }

  clearCache() {
    this.cache.clear();
    console.log('LibreTranslate cache cleared');
  }

  getCacheStats() {
    return {
      size: this.cache.size,
      timeout_ms: this.cacheTimeout
    };
  }
}

const libreTranslateService = new LibreTranslateService();
export default libreTranslateService;*/
```

### backend\services\notificationCleanup.js
```js
// backend/services/notificationCleanup.js
import cron from 'node-cron';

export function startNotificationCleanup(dbPool) {
    if (!dbPool) {
        console.error('Database pool not provided for notification cleanup');
        return;
    }

    // Schedule cleanup to run daily at 2:00 AM
    const cleanupJob = cron.schedule('0 2 * * *', async () => {
        try {
            console.log('Starting automatic notification cleanup...');
            const startTime = new Date();

            const request = dbPool.request();
            const query = `
                DELETE FROM Notifications 
                WHERE CreatedAt < DATEADD(day, -3, GETDATE())
            `;

            const result = await request.query(query);
            const deletedCount = result.rowsAffected[0];
            const endTime = new Date();
            const duration = endTime - startTime;

            console.log(`Notification cleanup completed:`);
            console.log(`- Deleted: ${deletedCount} notifications older than 3 days`);
            console.log(`- Duration: ${duration}ms`);

        } catch (error) {
            console.error('Error during automatic notification cleanup:', error);
        }
    }, {
        scheduled: false, 
        timezone: "Asia/Ho_Chi_Minh" 
    });

    // Start the scheduled job
    cleanupJob.start();
    
    console.log('Notification cleanup scheduler started');
    console.log('- Schedule: Daily at 2:00 AM (Vietnam time)');

    setTimeout(async () => {
        try {
            console.log('Running initial notification cleanup...');
            const request = dbPool.request();
            const result = await request.query(`
                DELETE FROM Notifications 
                WHERE CreatedAt < DATEADD(day, -3, GETDATE())
            `);
            console.log(`Initial cleanup: deleted ${result.rowsAffected[0]} old notifications`);
        } catch (error) {
            console.error('Error during initial cleanup:', error);
        }
    }, 5000); 

    return cleanupJob;
}
```

### frontend\public\admin-dashboard.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dashboard - Grammar Checker Analytics</title>
  
  <link rel="stylesheet" href="css/admin/main.css">
  <link rel="stylesheet" href="css/admin/dashboard.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>  
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <div class="header-left">
        <h1>ğŸš€ Grammar Checker Admin Dashboard</h1>
        <p>Welcome, <span id="adminUsername">admin</span> 
           <span class="status-indicator status-loading" id="connectionStatus"></span>
           <span id="connectionText">Connecting to database...</span>
        </p>
      </div>
      <div class="header-right">
        <button class="btn btn-secondary" id="backToAdminBtn">
          <i class="fas fa-arrow-left"></i> Back to Admin Panel
        </button>
        <button class="btn btn-success" id="exportStatsBtn">
          <i class="fas fa-download"></i> Export Excel
        </button>
      </div>
    </div>
  </header>

  <!-- Main Container -->
  <div class="container">
    <div class="dashboard-header">
      <h2 class="dashboard-title">
        <i class="fas fa-chart-bar"></i>
        Dashboard Overview
      </h2>
      <div class="dashboard-actions">
        <button id="refreshDashboardBtn" class="btn btn-secondary">
          <i class="fas fa-sync-alt"></i>
          Refresh
        </button>
      </div>
    </div>

    <!-- Overview Cards -->
    <div class="overview-cards" id="overviewCards">
      <div class="overview-card card-users">
        <div class="card-header">
          <div class="card-title">Total Users</div>
          <div class="card-icon icon-users">
            <i class="fas fa-users"></i>
          </div>
        </div>
        <div class="card-value" id="totalUsersCount">-</div>
        <div class="card-subtitle">
          <span id="activeUsersCount">-</span> active users
        </div>
      </div>

      <div class="overview-card card-activity">
        <div class="card-header">
          <div class="card-title">Grammar Checks</div>
          <div class="card-icon icon-activity">
            <i class="fas fa-spell-check"></i>
          </div>
        </div>
        <div class="card-value" id="grammarChecksCount">-</div>
        <div class="card-subtitle">
          <span id="todayChecksCount">-</span> checks today
        </div>
      </div>

      <div class="overview-card card-languages">
        <div class="card-header">
          <div class="card-title">Languages Used</div>
          <div class="card-icon icon-languages">
            <i class="fas fa-language"></i>
          </div>
        </div>
        <div class="card-value" id="languagesCount">-</div>
        <div class="card-subtitle">
          Most used: <span id="mostUsedLanguage">-</span>
        </div>
      </div>

      <div class="overview-card card-notifications">
        <div class="card-header">
          <div class="card-title">Notifications</div>
          <div class="card-icon icon-notifications">
            <i class="fas fa-bell"></i>
          </div>
        </div>
        <div class="card-value" id="totalNotificationsCount">-</div>
        <div class="card-subtitle">
          <span id="unreadNotificationsCount">-</span> unread
        </div>
      </div>
    </div>

    <div class="charts-section">
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-pie"></i>
          Account Types Distribution
        </div>
        <div class="chart-content">
          <canvas id="accountTypesChart" class="chart-canvas"></canvas>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-bar"></i>
          Top Languages Usage
        </div>
        <div class="chart-content">
          <canvas id="languagesChart" class="chart-canvas"></canvas>
        </div>
      </div>

      <div class="chart-container full-width-chart">
        <div class="chart-title">
          <i class="fas fa-chart-line"></i>
          Activity Timeline
          <div class="chart-controls">
            <select id="timeframeSelect" class="form-select">
              <option value="hour">Last 24 Hours</option>
              <option value="day" selected>Last 30 Days</option>
              <option value="month">Last 12 Months</option>
              <option value="year">All Years</option>
            </select>
          </div>
        </div>
        <div class="chart-content">
          <canvas id="timelineChart" class="chart-canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Loading/Error States -->
    <div id="dashboardLoading" class="loading-spinner hidden">
      <i class="fas fa-spinner fa-spin fa-2x"></i>
      <span style="margin-left: 10px;">Loading dashboard data...</span>
    </div>

    <div id="dashboardError" class="error-message hidden">
      <i class="fas fa-exclamation-triangle"></i>
      <span style="margin-left: 10px;">Error loading dashboard data. Please refresh the page.</span>
    </div>
  </div>

  <div id="toastContainer" class="toast-container"></div>
  <script src="/js/authManager.js"></script>
  <script src="js/admin/admin-config.js"></script>
  <script src="js/admin/admin-utils.js"></script>
  <script src="js/admin/admin-api.js"></script>
  <script src="js/admin/admin-dashboard.js"></script>
</body>
</html>
```

### frontend\public\admin.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Admin - Grammar Checker Management</title>
  
  <link rel="stylesheet" href="css/admin/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

</head>
<body>  
  <header class="header">
    <div class="header-content">
      <div class="header-left">
        <h1>ğŸš€ Grammar Checker Admin Panel</h1>
        <p>Welcome, <span id="adminUsername">Admin</span> 
           <span class="status-indicator status-loading" id="connectionStatus"></span>
           <span id="connectionText">Connecting...</span>
        </p>
      </div>
      <div class="header-right">
        <button class="btn btn-danger logout-btn" id="logoutBtn">Logout</button>
      </div>
    </div>
  </header>

  <!-- Main Container -->
  <div class="container">
    <div id="debugInfo" class="debug-info" style="display: none;">
      <strong>ğŸ” Debug Information:</strong>
      <div id="debugContent"></div>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-number" id="totalUsers">-</div>
        <div class="stat-label">Total Users</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="activeUsers">-</div>
        <div class="stat-label">Active Users</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="plusUsers">-</div>
        <div class="stat-label">Plus Users</div>
      </div>
    </div>

    <div class="admin-panel">
      <div class="panel-header">
        <h2 class="panel-title">User Management</h2>
        <div class="panel-actions">
          <button class="btn btn-small" id="debugBtn">ğŸ” Debug</button>
          <button class="btn btn-small" id="refreshBtn">ğŸ”„ Refresh</button>
          <button class="btn" id="addUserBtn">â• Add User</button>
          <button id="dashboardBtn" class="btn btn-secondary">
          <i class="fas fa-chart-bar"></i>Dashboard</button>
        </div>
      </div>
      
      <div class="table-container">
        <div class="search-container">
          <input type="text" id="searchInput" placeholder="Search by username or email...">
        </div>
        
        <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Username</th>
            <th>Full Name</th>
            <th>Email</th>
            <th>Phone</th>
            <th>Role</th>
            <th>Account Type</th>
            <th>Status</th>
            <th>Created At</th>
            <th>Update At</th>
            <th>Actions</th>
          </tr>
        </thead>
          <tbody id="userTableBody">
            <tr>
              <td colspan="11" class="loading">
                <span class="status-indicator status-loading"></span>
                Initializing admin panel...
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="userModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="modalTitle">Add New User</h3>
      </div>
      
      <div class="modal-body">
        <form id="userForm" novalidate>
          <input type="hidden" id="editUserId">
          
          <div class="form-group">
            <label for="username">Username <span class="required">*</span></label>
              <input type="text" id="username" name="username" autocomplete="username" data-required="true">
            <div id="usernameError" class="error-text"></div>
          </div>
          
          <div class="form-group">
            <label for="email">Email <span class="required">*</span></label>
            <input type="email" id="email" name="email" autocomplete="email" data-required="true">
            <div id="emailError" class="error-text"></div>
          </div>
          
          <div class="form-group">
            <label for="phone">Phone</label>
            <input type="tel" id="phone" name="phone" autocomplete="tel">
          </div>

          <div class="form-group">
            <label for="fullName">Full Name <span class="required">*</span></label>
            <input type="text" id="fullName" name="name" autocomplete="name" data-required="true" />
            <div id="fullNameError" class="error-text"></div>
          </div>

          <div class="form-group">
            <label for="password">Password <span id="passwordRequired">*</span></label>
            <div class="password-wrapper">
              <input type="password" id="password" name="password" autocomplete="new-password" data-required="true">
              <button type="button" id="togglePassword" class="toggle-password">
                <i class="fa-solid fa-eye"></i>
              </button>
            </div>
            <div id="passwordError" class="error-text"></div>
            <small id="passwordHint" style="display:none; color: #666;">Leave blank to keep current password</small>
          </div>
          
          <div id="accountSettings" class="account-settings" style="display: none;">
            <h4 class="settings-title">Account Settings</h4>
            
            <div class="form-group">
              <div class="checkbox-group">
                <label class="checkbox-label">
                  <input type="checkbox" id="isActive" class="checkbox-input">
                  <span class="checkbox-custom"></span>
                  <span class="checkbox-text">
                    <strong>Active Account</strong>
                    <small>User can log in and use the service</small>
                  </span>
                </label>
              </div>
            </div>

            <div class="form-group">
              <div class="checkbox-group">
                <label class="checkbox-label">
                  <input type="checkbox" id="isPlusAccount" class="checkbox-input">
                  <span class="checkbox-custom plus-checkbox"></span>
                  <span class="checkbox-text">
                    <strong>Plus Account</strong>
                    <small>Premium features and advanced grammar checking</small>
                  </span>
                </label>
              </div>
            </div>

            <div class="form-group" id="roleSelection" style="display: none;">
              <div class="checkbox-group">
                <label class="checkbox-label">
                  <input type="checkbox" id="isAdmin" class="checkbox-input">
                  <span class="checkbox-custom admin-checkbox"></span>
                  <span class="checkbox-text">
                    <strong>Administrator</strong>
                    <small>Full access to admin panel and user management</small>
                  </span>
                </label>
              </div>
            </div>
          </div>
          
          <div id="formError" class="error-text"></div>
          
          <div class="form-actions">
            <button type="button" class="btn btn-secondary" id="cancelBtn">Cancel</button>
            <button type="submit" class="btn btn-success" id="saveBtn">
              <span id="saveBtnText">Save User</span>
              <span id="saveBtnLoader" class="btn-loader" style="display: none;"></span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <div id="quickToggleModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Quick Status Change</h3>
      </div>
      
      <div class="modal-body">
        <div class="quick-toggle-info">
          <p>Change status for: <strong id="quickToggleUsername">-</strong></p>
          <div id="quickToggleOptions" class="quick-toggle-options">
          </div>
        </div>
        
        <div class="form-actions">
          <button type="button" class="btn btn-secondary" id="quickToggleCancelBtn">Cancel</button>
          <button type="button" class="btn btn-primary" id="quickToggleConfirmBtn">
            <span id="quickToggleBtnText">Apply Changes</span>
            <span id="quickToggleBtnLoader" class="btn-loader" style="display: none;"></span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner">
      <div class="spinner"></div>
      <p>Processing...</p>
    </div>
  </div>

  <div id="toastContainer" class="toast-container"></div>
    <script src="js/authManager.js"></script>
    <script src="js/admin/admin-config.js"></script>
    <script src="js/admin/admin-storage.js"></script>
    <script src="js/admin/admin-utils.js"></script>
    <script src="js/admin/admin-debug.js"></script>
    <script src="js/admin/admin-auth.js"></script>
    <script src="js/admin/admin-state.js"></script>
    <script src="js/admin/admin-ui.js"></script>
    <script src="js/admin/admin-api.js"></script>
    <script src="js/admin/admin-forms.js"></script>
    <script src="js/admin/admin-modals.js"></script>
    <script src="js/admin/admin-events.js"></script>
    <script src="js/admin/admin-main.js"></script>
</body>
</html>
```

### frontend\public\GrammarChecker1.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Grammar Checker</title>

  <link rel="stylesheet" href="css/grammar-checker/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <div class="wrapper">
    <div class="demo-container">

      <header class="header">
        <div class="header-content">
          <div class="header-left">
            <img src="images/Logo.jpg" class="inner-logo" alt="Inner Logo" />
            <h1 class="header-title">Grammar Checker</h1>
          </div>
          <div class="header-right">
            <div class="notification-icon">
              <i class="fas fa-bell"></i>
            </div>
            <div class="notification-dropdown hidden" id="notificationDropdown">
              <div class="notification-header">
              <h4>Notifications</h4>
              <button id="seeAllBtn" class="btn btn-link">See All</button>
              </div>
              <ul id="notificationList" class="notification-list">
              </ul>
            </div>

            <div class="avatar-container">
              <div class="user-avatar" id="userAvatarToggle">
                <i class="fas fa-user-circle"></i>
                <span class="user-name" id="headerUsername">User</span>
                <i class="fas fa-chevron-down"></i>
              </div>
              <div class="user-dropdown hidden" id="userDropdown">
                <div class="dropdown-header">
                  <i class="fas fa-user-circle user-icon-large"></i>
                  <div class="user-details">
                    <strong id="dropdownUsername">Guest</strong>
                    <span id="dropdownEmail">guest@example.com</span>
                  </div>
                </div>
                <div class="dropdown-divider"></div>
                <div class="dropdown-items">
                  <a href="introduction.html" class="dropdown-item">
                    <i class="fas fa-home"></i>
                    <span>Back to Home</span>
                  </a>
                </div>
                <div class="dropdown-divider"></div>
                <button class="dropdown-item logout-btn" id="logoutBtn">
                  <i class="fas fa-sign-out-alt"></i>
                  <span>Logout</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </header>

      <main class="main-layout">
        <!-- Grammar Checker Section (Default Active) -->
        <div id="grammar-section" class="content-section active">
          <section class="input-section">
            <div class="controls">
              <select id="languageSelect" class="form-select"></select>
              
              <button id="checkGrammarBtn" class="btn btn-primary">
                <span class="btn-text">Check Grammar</span>
                <span class="btn-loader hidden"><i class="fas fa-spinner fa-spin"></i></span>
              </button>

              <button id="acceptAllBtn" class="btn btn-success hidden">
                <span class="btn-text">Accept All</span>
                <span class="btn-loader hidden"><i class="fas fa-spinner fa-spin"></i></span>
              </button>
            </div>

            <div id="detectedLanguageDisplay" class="detected-language-display hidden">
              <div id="detectedLanguageInfo"></div>
            </div>

            <div class="textarea-container">
              <textarea id="textInput" class="text-area" placeholder="Enter your text here to check for grammar errors...

This is where you can type or paste your text. The AI will analyze and provide suggestions for improvements."></textarea>
            </div>

            <div class="message-container">
              <div id="errorMessage" class="message error hidden"></div>
              <div id="successMessage" class="message success hidden"></div>
            </div>
          </section>

          <section class="results-section">
            <div class="stats-grid" id="statsContainer">
              <div class="stat-card">
                <div class="stat-number" id="wordCount">0</div>
                <div class="stat-label">Words</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="charCount">0</div>
                <div class="stat-label">Characters</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
              </div>
            </div>
     
            <div class="highlighted-text-panel">
              <div class="panel-header">
                <h3><i class="fas fa-file-text"></i> Corrected Text</h3>
              </div>
              <div class="highlighted-text-display" id="highlightedText">
                <div class="placeholder-text">
                  <i class="fas fa-magic"></i>
                  <p>Your corrected text will appear here.</p>
                  <small>Start by entering text and clicking "Check Grammar"</small>
                </div>
              </div>
            </div>

            <div class="suggestions-panel" id="suggestionsPanel">
              <div class="suggestions-header">
                <h3><i class="fas fa-lightbulb"></i> Grammar Suggestions</h3>
              </div>
              <div class="suggestions-content">
                <ul id="suggestionsList" class="suggestions-list"></ul>
                
                <div class="no-suggestions hidden">
                  <i class="fas fa-check-circle"></i>
                  <p>No errors found in your text.</p>
                  <small>Your text looks great!</small>
                </div>
              </div>
            </div>
          </section>
        </div>

        <!-- About Section -->
        <div id="about-section" class="content-section hidden">
          <div class="section-content">
            <h2>About Our AI Grammar Editor</h2>
            <p>Our AI Grammar Editor is designed to help you write with confidence. Powered by cutting-edge artificial intelligence, it identifies and corrects grammar, spelling, punctuation, and style errors in real-time.</p>
            <p>We believe that effective communication is key to success, and our mission is to provide an accessible and powerful tool to everyone.</p>
          </div>
        </div>

        <!-- Features Section -->
        <div id="features-section" class="content-section hidden">
          <div class="section-content">
            <h2>Key Features</h2>
            <div class="feature-grid">
              <div class="feature-item">
                <h3><i class="fas fa-check-circle"></i> Advanced Grammar Check</h3>
                <p>Detects complex grammatical errors, sentence structure issues, and common writing mistakes.</p>
              </div>
              <div class="feature-item">
                <h3><i class="fas fa-spell-check"></i> Real-time Spelling Correction</h3>
                <p>Corrects typos and spelling errors as you type, ensuring accuracy.</p>
              </div>
              <div class="feature-item">
                <h3><i class="fas fa-magic"></i> Style Enhancement</h3>
                <p>Suggests improvements for clarity, conciseness, and overall writing style.</p>
              </div>
              <div class="feature-item">
                <h3><i class="fas fa-language"></i> Multi-language Support</h3>
                <p>Supports various languages to help non-native speakers perfect their writing.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Testimonials Section -->
        <div id="testimonials-section" class="content-section hidden">
          <div class="section-content">
            <h2>What Our Users Say</h2>
            <div class="testimonial-grid">
              <div class="testimonial-item">
                <p>"This AI Grammar Editor has revolutionized my writing. It's incredibly accurate and easy to use!"</p>
                <span>- Jane Doe, Student</span>
              </div>
              <div class="testimonial-item">
                <p>"As a professional writer, I rely on this tool daily. It catches mistakes I often miss."</p>
                <span>- John Smith, Content Creator</span>
              </div>
              <div class="testimonial-item">
                <p>"The best grammar checker I've ever used. Highly recommended for anyone serious about writing."</p>
                <span>- Emily White, Business Owner</span>
              </div>
            </div>
          </div>
        </div>

        <!-- FAQ Section -->
        <div id="faq-section" class="content-section hidden">
          <div class="section-content">
            <h2>Frequently Asked Questions</h2>
            <div class="faq-list">
              <div class="faq-item">
                <h3>How accurate is the grammar checker?</h3>
                <p>Our AI grammar checker uses advanced algorithms and machine learning models to provide highly accurate suggestions for grammar, spelling, and style.</p>
              </div>
              <div class="faq-item">
                <h3>What languages does it support?</h3>
                <p>Currently, our editor supports English (US/GB), Vietnamese, French, German, Spanish, Italian, Portuguese, Russian, Chinese, Japanese, and Korean.</p>
              </div>
              <div class="faq-item">
                <h3>Is my data private and secure?</h3>
                <p>Yes. All text processed through our editor is encrypted and handled with strict confidentiality. We do not store your text after processing.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Contact Section -->
        <div id="contact-section" class="content-section hidden">
          <div class="section-content">
            <h2>Contact Us</h2>
            <div class="contact-info">
              <p>Phone: <a href="tel:01223456789">01223456789</a></p>
              <p>Email: <a href="mailto:tuan@gmail.com">tuan@gmail.com</a></p>
              <div class="social-links">
                <a href="https://www.facebook.com/" target="_blank">
                  <i class="fab fa-facebook"></i> Facebook
                </a>
                <a href="https://instagram.com/" target="_blank">
                  <i class="fab fa-instagram"></i> Instagram
                </a>
                <a href="https://tiktok.com/" target="_blank">
                  <i class="fab fa-tiktok"></i> TikTok
                </a>
              </div>
            </div>
          </div>
        </div>
      </main>

      <!-- Footer (Fixed position outside main content) -->
      <footer class="footer">
        <div class="footer-content">
          <p>&copy; 2024 Grammar Checker AI. All rights reserved.</p>
          <div class="footer-links">
            <a href="#">Privacy Policy</a>
            <a href="#">Terms of Service</a>
            <a href="#">Contact</a>
          </div>
        </div>
      </footer>

    </div>
  </div>

  <!-- Keep existing scripts -->
  <script src="js/authManager.js"></script>
  <script type="module" src="js/GrammarChecker1.js"></script>
  <script type="module" src="js/utils.js"></script>
  <script type="module" src="js/notifications.js"></script>

  <!-- Enhanced Modal -->
  <div id="loginModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <i class="fas fa-lock text-warning"></i>
        <h3>Free Trial Limit Reached</h3>
      </div>
      <div class="modal-body">
        <p>You've used all 3 free grammar checks.</p>
        <p>Please log in to continue using the grammar checker with unlimited access.</p>
      </div>
      <div class="modal-actions">
        <a href="login.html" class="btn btn-primary">
          <i class="fas fa-sign-in-alt"></i>
          Log In
        </a>
        <a href="index.html" class="btn btn-outline">
          <i class="fas fa-user-plus"></i>
          Register
        </a>
      </div>
    </div>
  </div>
</body>
</html>
```

### frontend\public\index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Register - AI Grammar Checker</title>
  <link rel="stylesheet" href="css/style/main.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <div class="auth-page-wrapper">
    <div class="auth-container">
      <div class="brand-section">
        <a href="introduction.html" class="back-arrow-btn" title="Back to Introduction">
          <i class="fas fa-arrow-left"></i>
        </a>
        
        <div class="brand-content">
          <div class="brand-icon">
            <i class="fas fa-spell-check"></i>
          </div>
          <h1 class="brand-title">
            <span class="brand-text-primary">AI Grammar</span>
            <span class="brand-text-secondary">Checker</span>
          </h1>
          <p class="brand-subtitle">Enhance your writing with AI-powered precision</p>
        </div>
        <!-- Enhanced decorative elements -->
        <div class="brand-decoration">
          <div class="floating-element floating-element-1"></div>
          <div class="floating-element floating-element-2"></div>
          <div class="floating-element floating-element-3"></div>
        </div>
      </div>

      <!-- Right Form Section (Enhanced tá»« register-form) -->
      <div class="form-section">
        <div class="form-header">
          <h2 class="form-title">Register</h2>
          <p class="form-subtitle">Create your account to get started</p>
        </div>

        <form id="registerForm" class="auth-form">
          <!-- âœ… ADDED: Full Name Field (Required by backend) -->
          <div class="input-group">
            <div class="input-wrapper">
              <input 
                id="fullName" 
                type="text" 
                placeholder="Full Name" 
                required 
                class="form-input"
                autocomplete="name"
              />
              <i class="fas fa-user-circle input-icon"></i>
            </div>
            <span id="FullNameError" class="error-message"></span>
          </div>

          <!-- Username Field (giá»¯ nguyÃªn ID cho JS) -->
          <div class="input-group">
            <div class="input-wrapper">
              <input 
                id="username" 
                type="text" 
                placeholder="Username" 
                required 
                class="form-input"
                autocomplete="username"
              />
              <i class="fas fa-user input-icon"></i>
            </div>
            <span id="usernameError" class="error-message"></span>
          </div>

          <!-- Email Field (Moved up for better UX flow) -->
          <div class="input-group">
            <div class="input-wrapper">
              <input 
                id="email" 
                type="email" 
                placeholder="Email" 
                required 
                class="form-input"
                autocomplete="email"
              />
              <i class="fas fa-envelope input-icon"></i>
            </div>
            <span id="emailError" class="error-message"></span>
          </div>

          <!-- Phone Field (giá»¯ nguyÃªn logic optional) -->
          <div class="input-group">
            <div class="input-wrapper">
              <input 
                id="phone" 
                type="tel" 
                placeholder="Phone Number (optional)" 
                class="form-input"
                autocomplete="tel"
              />
              <i class="fas fa-phone input-icon"></i>
            </div>
            <span id="phoneError" class="error-message"></span>
          </div>

          <!-- Password Field (Enhanced password-wrapper) -->
          <div class="input-group">
            <div class="input-wrapper password-wrapper">
              <input 
                id="password" 
                type="password" 
                placeholder="Password" 
                required 
                autocomplete="new-password"
                class="form-input"
              />
              <i class="fas fa-lock input-icon"></i>
              <button type="button" class="toggle-password" aria-label="Toggle password visibility">
                <i class="fas fa-eye"></i>
              </button>
            </div>
            <span id="passwordError" class="error-message"></span>
          </div>

          <!-- Confirm Password Field -->
          <div class="input-group">
            <div class="input-wrapper password-wrapper">
              <input 
                id="confirmPassword" 
                type="password" 
                placeholder="Confirm Password" 
                required 
                autocomplete="new-password"
                class="form-input"
              />
              <i class="fas fa-lock input-icon"></i>
              <button type="button" class="toggle-password" aria-label="Toggle confirm password visibility">
                <i class="fas fa-eye"></i>
              </button>
            </div>
            <span id="confirmPasswordError" class="error-message"></span>
          </div>

          <!-- Success/Error Messages (giá»¯ nguyÃªn IDs cho JS) -->
          <span id="registerSuccess" class="success-message"></span>
          <span id="registerGeneralError" class="error-message"></span>

          <!-- Remember Me Checkbox (Enhanced styling) -->
          <div class="checkbox-group">
            <label class="checkbox-label">
              <input type="checkbox" class="checkbox-input" />
              <span class="checkbox-custom"></span>
              <span class="checkbox-text">Remember me</span>
            </label>
          </div>

          <!-- Submit Button (Enhanced vá»›i loading state) -->
          <button type="submit" class="submit-btn">
            <span class="btn-text">Register</span>
            <div class="btn-loading hidden">
              <div class="spinner"></div>
              <span>Creating account...</span>
            </div>
          </button>

          <!-- Login Link (Enhanced styling) -->
          <div class="form-footer">
            <p class="switch-form-text">
              Already have an account? 
              <a href="login.html?animate=left" class="switch-form-link">Back to Login</a>
            </p>
          </div>
        </form>
      </div>
    </div>

    <!-- Enhanced Background Decoration -->
    <div class="bg-decoration">
      <div class="bg-shape bg-shape-1"></div>
      <div class="bg-shape bg-shape-2"></div>
      <div class="bg-shape bg-shape-3"></div>
    </div>
  </div>

  <!-- Scripts (giá»¯ nguyÃªn nhÆ° dá»± Ã¡n gá»‘c) -->
  <script type="module" src="js/index.js"></script>
  <script type="module" src="js/utils.js"></script>
</body>
</html>
```

### frontend\public\introduction.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Grammar Editor - Home</title>
    <link rel="stylesheet" href="css/introduction/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>
    </div>

    <aside class="sidebar hidden" id="sidebar">
        <div class="sidebar-header">
            <h3><i class="fas fa-bars"></i> Menu</h3>
        </div>
        <nav class="sidebar-nav">
            <a href="GrammarChecker1.html" class="sidebar-item">
                <i class="fas fa-spell-check"></i>
                <span>Check Grammar</span>
            </a>
        </nav>
    </aside>

    <div class="page-content-wrapper" id="pageContentWrapper">
        <header>
            <nav>
                <button class="sidebar-toggle" id="sidebarToggle">
                    <i class="fas fa-bars"></i>
                </button>
                
                <div class="logo">AI Grammar Editor</div>
                
                <ul id="desktopNav">
                    <li><a href="#home">Home</a></li>
                    <li><a href="#about">About</a></li>
                    <li><a href="#features">Features</a></li>
                    <li><a href="#testimonials">Testimonials</a></li>
                    <li><a href="#faq">FAQ</a></li>
                    <li><a href="#contact">Contact</a></li>
                </ul>
                
                <div class="auth-buttons" id="authButtons">
                    <a href="login.html" class="login">Log In</a>
                    <a href="index.html" class="signup">Sign Up</a>
                </div>
                
                <div class="user-dropdown-container hidden" id="userDropdownContainer">
                    <div class="user-avatar" id="userAvatarToggle">
                        <i class="fas fa-user-circle"></i>
                        <span class="user-name" id="headerUsername">User</span>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="user-dropdown hidden" id="userDropdown">
                        <div class="dropdown-header">
                            <i class="fas fa-user-circle user-icon-large"></i>
                            <div class="user-details">
                                <strong id="dropdownUsername">Guest</strong>
                                <span id="dropdownEmail">guest@example.com</span>
                            </div>
                        </div>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item logout-btn" id="logoutBtn">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Logout</span>
                        </button>
                    </div>
                </div>
            </nav>
        </header>

        <!-- Main wrapper -->
        <div class="main-wrapper" id="mainWrapper">
            <div id="usageLimitModal" class="modal" style="display: none;">
                <div class="modal-content">
                    <span class="close" data-modal="usageLimitModal">&times;</span>
                    <div class="container">
                        <div class="left-box">
                            <h1>AI Grammar<br>Editor</h1>
                        </div>
                        <div class="register-form">
                            <h2>Usage Limit Exceeded</h2>
                            <div class="modal-message">
                                <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 20px;"></i>
                                <p>You have used all your free grammar checks. Please register an account for unlimited access!</p>
                            </div>
                            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px;">
                                <button id="goToLoginBtn" class="btn btn-primary">
                                    <i class="fas fa-sign-in-alt"></i> Go to Login
                                </button>
                                <button id="goToRegisterBtn" class="btn btn-primary">
                                    <i class="fas fa-user-plus"></i> Go to Register
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <section id="home" class="hero">
                <div class="hero-content">
                    <h1>Intelligent Grammar Editing with AI</h1>
                    <p>Transform your text with cutting-edge AI technology. Check grammar, enhance writing style, and optimize content in seconds!</p>
                    <div class="hero-buttons">
                        <button id="tryItFreeBtn" class="btn btn-primary">
                            <i class="fas fa-magic"></i> Try it Free
                        </button>
                        <button id="learnMoreBtn" class="btn btn-secondary">
                            <i class="fas fa-info-circle"></i> Learn More
                        </button>
                    </div>
                </div>
            </section>
            
            <!-- Demo Grammar Checker Section -->
            <section id="demo" class="demo-section" style="display: none;">
                <div class="section-content">
                    <h2>Try Grammar Checker - Free Check</h2>
                    <p class="demo-subtitle">Test our AI-powered grammar checker. You have <strong id="remainingUses">3</strong> free checks remaining.</p>
                    
                    <div class="demo-container">
                        <div class="demo-input-area">
                            <label for="demoLanguage">Select Language:</label>
                            <select id="demoLanguage" class="demo-select"></select>
                            
                            <label for="demoText">Enter your text:</label>
                            <textarea 
                                id="demoText" 
                                class="demo-textarea" 
                                placeholder="Type or paste your text here to check for grammar errors..."
                                rows="8"
                            ></textarea>
                            
                            <div class="demo-stats">
                                <span><i class="fas fa-font"></i> Words: <strong id="demoWordCount">0</strong></span>
                                <span><i class="fas fa-keyboard"></i> Characters: <strong id="demoCharCount">0</strong></span>
                            </div>
                            
                            <!-- âœ… THÃŠM BUTTON GROUP -->
                            <div class="demo-button-group">
                                <button id="demoCheckBtn" class="btn btn-primary demo-check-btn">
                                    <i class="fas fa-check-circle"></i> Check Grammar
                                </button>
                                <button id="demoAcceptAllBtn" class="btn btn-success demo-accept-all-btn" style="display: none;">
                                    <i class="fas fa-check-double"></i> Accept All
                                </button>
                            </div>
                        </div>
                        
                        <div id="demoResults" class="demo-results" style="display: none;">
                            <h3>Results</h3>
                            <div class="demo-results-summary">
                                <span class="demo-issue-count">
                                    <i class="fas fa-exclamation-circle"></i> 
                                    Issues found: <strong id="demoIssueCount">0</strong>
                                </span>
                            </div>
                            <div id="demoErrorsList" class="demo-errors-list"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="about" class="about-section">
                <div class="section-content">
                    <h2>About AI Grammar Editor</h2>
                    <p>AI Grammar Editor is the ultimate solution for fast and accurate text editing. Powered by advanced AI, we not only check grammar but also suggest style improvements, ensuring your writing is always professional and clear.</p>
                    <p>Whether you're a student, writer, or professional, AI Grammar Editor helps you create high-quality content, supports over 20 languages, and integrates with multiple platforms.</p>
                </div>
            </section>

            <section id="features" class="features-section">
                <div class="section-content">
                    <h2>Key Features</h2>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-check-circle"></i>
                            </div>
                            <h3>Grammar Check</h3>
                            <p>Detect and correct grammar and spelling errors with precision and speed.</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-magic"></i>
                            </div>
                            <h3>Style Suggestions</h3>
                            <p>Enhance your writing style for clearer, more professional content.</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-language"></i>
                            </div>
                            <h3>Multilingual Support</h3>
                            <p>Edit text in multiple languages with high accuracy.</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-robot"></i>
                            </div>
                            <h3>Smart AI</h3>
                            <p>Learns and personalizes suggestions based on your writing style.</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-plug"></i>
                            </div>
                            <h3>Seamless Integration</h3>
                            <p>Works smoothly on browsers, mobile apps, and platforms like Word and Google Docs.</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-user-shield"></i>
                            </div>
                            <h3>Top Security</h3>
                            <p>Your data is encrypted and fully protected, ensuring privacy.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="testimonials" class="testimonials-section">
                <div class="section-content">
                    <h2>What Our Users Say</h2>
                    <div class="testimonial-grid">
                        <div class="testimonial-card">
                            <div class="stars">â˜…â˜…â˜…â˜…â˜…</div>
                            <p>"AI Grammar Editor has significantly improved my writing quality. The suggestions are smart and easy to apply!"</p>
                            <h4>John Doe - Writer</h4>
                        </div>
                        <div class="testimonial-card">
                            <div class="stars">â˜…â˜…â˜…â˜…â˜†</div>
                            <p>"I use this tool for academic papers, and it saves so much time. The support for multiple languages is great!"</p>
                            <h4>Jane Smith - Student</h4>
                        </div>
                        <div class="testimonial-card">
                            <div class="stars">â˜…â˜…â˜…â˜…â˜…</div>
                            <p>"User-friendly interface and highly accurate edits. I'm very satisfied!"</p>
                            <h4>Mike Johnson - Marketing Specialist</h4>
                        </div>
                    </div>
                </div>
            </section>

            <section id="faq" class="faq-section">
                <div class="section-content">
                    <h2>Frequently Asked Questions</h2>
                    <div class="faq-accordion">
                        <div class="faq-item">
                            <div class="accordion-header">
                                <h3>Does AI Grammar Editor support multiple languages?</h3>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            <div class="accordion-content">
                                <p>Yes, we support over 20 languages with high accuracy.</p>
                            </div>
                        </div>
                        <div class="faq-item">
                            <div class="accordion-header">
                                <h3>Can I use it for free?</h3>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            <div class="accordion-content">
                                <p>You can use the free version with basic features. Paid plans offer advanced functionalities.</p>
                            </div>
                        </div>
                        <div class="faq-item">
                            <div class="accordion-header">
                                <h3>Is my data secure?</h3>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            <div class="accordion-content">
                                <p>We use high-level encryption to protect your data. Privacy is our top priority.</p>
                            </div>
                        </div>
                        <div class="faq-item">
                            <div class="accordion-header">
                                <h3>Can the tool integrate with other software?</h3>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                            <div class="accordion-content">
                                <p>Yes, AI Grammar Editor seamlessly integrates with Microsoft Word, Google Docs, and more.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <footer class="footer" id="contact">
                <div class="footer-container">
                    <div class="footer-left">
                        <h3>Contact Us</h3>
                        <p><i class="fas fa-envelope"></i> Email: support@aigrammar.com</p>
                        <p><i class="fas fa-phone"></i> Phone: +84 387 970 581</p>
                        <p><i class="fas fa-map-marker-alt"></i> Address: 123 AI Street, Hanoi, Vietnam</p>
                    </div>
                    <div class="footer-right">
                        <h3>Follow Us</h3>
                        <div class="social-icons">
                            <a href="https://www.facebook.com/dat09.support" target="_blank" aria-label="Facebook">
                                <i class="fab fa-facebook-f"></i>
                            </a>
                            <a href="https://twitter.com" target="_blank" aria-label="Twitter">
                                <i class="fab fa-twitter"></i>
                            </a>
                            <a href="https://linkedin.com" target="_blank" aria-label="LinkedIn">
                                <i class="fab fa-linkedin-in"></i>
                            </a>
                            <a href="https://aigrammar.com" target="_blank" aria-label="Website">
                                <i class="fas fa-globe"></i>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="footer-bottom">
                    <p>Â© 2025 AI Grammar Editor. All rights reserved.</p>
                </div>
            </footer>

            <div id="toast" class="toast">
                <span id="toastMessage">Success!</span>
            </div>
        </div>
    </div>
    
    <script src="js/authManager.js"></script>
    <script type="module" src="js/introduction/intro-main.js"></script>
</body>
</html>
```

### frontend\public\login.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Login - AI Grammar Checker</title>
  <link rel="stylesheet" href="css/style/main.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <div class="auth-page-wrapper">
    <div class="auth-container">
      <!-- Left Brand Section (Enhanced tá»« left-box gradient-bg) -->
      <div class="brand-section">
        <!-- Back Arrow Button - Náº±m TRONG brand-section -->
        <a href="introduction.html" class="back-arrow-btn" title="Back to Introduction">
          <i class="fas fa-arrow-left"></i>
        </a>
        
        <div class="brand-content">
          <div class="brand-icon">
            <i class="fas fa-spell-check"></i>
          </div>
          <h1 class="brand-title">
            <span class="brand-text-primary">AI Grammar</span>
            <span class="brand-text-secondary">Checker</span>
          </h1>
          <p class="brand-subtitle">Welcome back! Continue enhancing your writing</p>
        </div>
        <!-- Enhanced decorative elements -->
        <div class="brand-decoration">
          <div class="floating-element floating-element-1"></div>
          <div class="floating-element floating-element-2"></div>
          <div class="floating-element floating-element-3"></div>
        </div>
      </div>

      <!-- Right Form Section (Enhanced tá»« register-form) -->
      <div class="form-section">
        <div class="form-header">
        <h2 class="form-title">Login</h2>
        <p class="form-subtitle">Sign in to access your account</p>
       </div>

        <!-- âœ… THÃŠM VÃ€O ÄÃ‚Y -->
      <div class="session-info-panel" id="sessionInfoPanel" style="display: none;">
        <div class="session-badge">
         <i class="fas fa-info-circle"></i>
          <span>Tab ID: <strong id="currentTabId"></strong></span>
        </div>
      <div class="active-sessions" id="activeSessions">
      <!-- Sáº½ Ä‘Æ°á»£c Ä‘iá»n báº±ng JS -->
      </div>
    </div>
        <form id="loginForm" class="auth-form">
          <!-- Username Field (giá»¯ nguyÃªn ID loginUsername cho JS) -->
          <div class="input-group">
            <div class="input-wrapper">
              <input 
                type="text" 
                id="loginUsername" 
                placeholder="Username" 
                required 
                autocomplete="username"
                class="form-input"
              />
              <i class="fas fa-user input-icon"></i>
            </div>
          </div>

          <!-- Password Field (Enhanced password-wrapper, giá»¯ ID loginPassword) -->
          <div class="input-group">
            <div class="input-wrapper password-wrapper">
              <input 
                type="password" 
                id="loginPassword" 
                placeholder="Password" 
                required 
                autocomplete="current-password"
                class="form-input"
              />
              <i class="fas fa-lock input-icon"></i>
              <button type="button" class="toggle-password" aria-label="Toggle password visibility">
                <i class="fas fa-eye"></i>
              </button>
            </div>
          </div>
          
          <!-- Error/Success Messages (giá»¯ nguyÃªn IDs cho JS) -->
          <div id="loginGeneralError" class="error-message"></div> 
          <div id="loginSuccess" class="success-message"></div>

          <!-- Form Options (Remember me + Forgot password) -->
          <div class="form-options">
            <div class="checkbox-group">
              <label class="checkbox-label">
                <input type="checkbox" id="rememberMe" name="rememberMe" class="checkbox-input" />
                <span class="checkbox-custom"></span>
                <span class="checkbox-text">Remember me</span>
              </label>
            </div>
            <a href="#" class="forgot-password-link">Forgot Password?</a>
          </div>
          
          <!-- Submit Button (Enhanced vá»›i loading state) -->
          <button type="submit" class="submit-btn">
            <span class="btn-text">Login</span>
            <div class="btn-loading hidden">
              <div class="spinner"></div>
              <span>Signing in...</span>
            </div>
          </button>

          <!-- Register Link (giá»¯ nguyÃªn logic animate=right) -->
          <div class="form-footer">
            <p class="switch-form-text">
              Don't have an account? 
              <a href="index.html?animate=right" class="switch-form-link">Register here</a>
            </p>
          </div>
        </form>

        <!-- Optional: Social Login (thÃªm má»›i cho enhanced UX) -->
        <div class="social-login">
          <div class="divider">
            <span class="divider-text">Or continue with</span>
          </div>
          <div class="social-buttons">
            <button type="button" class="social-btn social-btn-google" aria-label="Sign in with Google">
              <i class="fab fa-google"></i>
              <span>Google</span>
            </button>
            <button type="button" class="social-btn social-btn-facebook" aria-label="Sign in with Facebook">
              <i class="fab fa-facebook-f"></i>
              <span>Facebook</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="bg-decoration">
      <div class="bg-shape bg-shape-1"></div>
      <div class="bg-shape bg-shape-2"></div>
      <div class="bg-shape bg-shape-3"></div>
    </div>
  </div>

  <script src="js/authManager.js"></script>
  <script type="module" src="js/login.js"></script>
  <script type="module" src="js/utils.js"></script>
</body>
</html>
```

### frontend\public\js\api.js
```js
const API_BASE_URL = 'http://localhost:3000/api';

class FrontendCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
    this.ttl = 10 * 60 * 1000; 
    setInterval(() => this.cleanExpired(), 5 * 60 * 1000);
  }
  generateKey(text, type, language = '') {
    const textKey = (text || '').slice(0, 100) + `_len${(text || '').length}`;
    return `${type}_${language}_${this.hashString(textKey)}`;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return String(hash);
  }
  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, { data: value, expires: Date.now() + this.ttl });
  }
  get(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;
    if (Date.now() > cached.expires) { this.cache.delete(key); return null; }
    return cached.data;
  }
  cleanExpired() {
    const now = Date.now(); let cleaned = 0;
    for (const [k, v] of this.cache.entries()) {
      if (now > v.expires) { this.cache.delete(k); cleaned++; }
    }
    if (cleaned) console.log(`Cache cleaned: ${cleaned} items`);
  }
  clear() { this.cache.clear(); console.log('Cache cleared'); }
  getStats() { return { size: this.cache.size, maxSize: this.maxSize, ttlMinutes: this.ttl / 60000 }; }
}
const frontendCache = new FrontendCache();
if (typeof window !== 'undefined') window.grammarCache = frontendCache;

/* =========================
   Helpers
   ========================= */

export async function logUsageActivity(data) {
    try {
        const userData = (typeof AuthManager !== 'undefined') ? AuthManager.getCurrentUser() : null;
        const payload = {
          user_id: userData?.userId ?? userData?.id ?? null,
          username: userData?.username ?? userData?.name ?? null,
          action: data.action || null,
          language: data.language || null,
          metadata: data.details ?? data.metadata ?? {},
          user_agent: navigator.userAgent || '',
          session_id: sessionStorage.getItem('sessionId') || ''
        };

        await fetch('/api/usage/log', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-user-id': userData?.userId?.toString() || '',
                'x-user-role': userData?.userRole || 'guest'
            },
            body: JSON.stringify(payload)
        });
    } catch (error) {
        console.error('Error logging usage:', error);
    }
}

async function safeJson(response) {
  try {
    return await response.json();
  } catch (e) {
    console.warn('Response not JSON', e);
    return null;
  }
}

/* =========================
   Public API functions
   ========================= */

/** fetchLanguages - tolerant to multiple response shapes */
export const fetchLanguages = async () => {
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/languages`);
    const data = await safeJson(res) || {};
    if (data?.success && data?.data?.languages) return data.data.languages;
    if (data?.languages) return data.languages;
    if (data?.data?.languagesList) return data.data.languagesList;
    throw new Error('Unexpected languages response');
  } catch (err) {
    console.error('fetchLanguages error', err);
    throw err;
  }
};

/** 
 * detectLanguage - Enhanced with CLD3 backend
 * Now returns detailed detection info including confidence and source
 */
export const detectLanguage = async (text, options = {}) => {
  if (typeof text !== 'string' || text.trim() === '') {
    throw new Error('Text must be a non-empty string.');
  }
  
  const trimmed = text.trim();
  const skipCache = options.skipCache || false;
  
  // Check cache first
  if (!skipCache) {
    const cacheKey = frontendCache.generateKey(trimmed, 'detect');
    const cached = frontendCache.get(cacheKey);
    if (cached) {
      console.log('ğŸ¯ Language detection from cache');
      return cached;
    }
  }  
  try {
    const startTime = performance.now();
    const res = await fetch(`${API_BASE_URL}/grammar/detect`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: trimmed })
    });
    
    const data = await safeJson(res) || {};
    let result;
    if (data?.success && data?.data) {
      result = {
        language: data.data.language,  
        confidence: data.data.confidence,
        reliable: data.data.reliable,
        source: data.data.source,
        detection_time_ms: data.data.detection_time_ms
      };
    } else {
      result = {
        language: 'en-US',
        confidence: 0.5,
        reliable: false,
        source: 'fallback'
      };
    }
    
    // Cache
    frontendCache.set(frontendCache.generateKey(trimmed, 'detect'), result);
    
    console.log(`ğŸ” Language detected: ${result.language} (${(result.confidence * 100).toFixed(1)}%, ${result.source})`);
    return result;
    
  } catch (err) {
    console.error('detectLanguage error', err);
    return {
      language: 'en-US',
      confidence: 0.5,
      reliable: false,
      source: 'error-fallback',
      error: err.message
    };
  }
};

/**
 * NEW: detectMultipleLanguages
 * Detect multiple possible languages in text
 */
export const detectMultipleLanguages = async (text, maxResults = 3) => {
  if (typeof text !== 'string' || text.trim() === '') {
    throw new Error('Text must be a non-empty string.');
  }
  
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/detect-multiple`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: text.trim(), maxResults })
    });
    
    const data = await safeJson(res) || {};
    
    if (data?.success && data?.data?.languages) {
      return data.data.languages;
    }
    
    throw new Error('Invalid response from server');
  } catch (err) {
    console.error('detectMultipleLanguages error', err);
    throw err;
  }
};

/** 
 * checkGrammar - Enhanced with auto language detection support
 * Now includes language_detection info in response when language='auto'
 */
export const checkGrammar = async (text, language = 'auto', options = {}) => {
  if (typeof text !== 'string' || text.trim() === '') {
    throw new Error('Text must be a non-empty string.');
  }
  
  const trimmed = text.trim();
  const useFastCheck = options.fast || false;
  
  if (!options.skipCache) {
    const cacheKey = frontendCache.generateKey(trimmed, 'grammar', language);
    const cached = frontendCache.get(cacheKey);
    if (cached) {
      console.log('ğŸ¯ Grammar check from cache');
      return cached;
    }
  }
  
  try {
    const endpoint = useFastCheck ? '/grammar/check-fast' : '/grammar/check';
    const startTime = performance.now();
    
    const res = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: trimmed, language })
    });
    
    const data = await safeJson(res) || {};
    
    let result = null;
    if (data.success && data.data) {
      result = data.data;
    } else if (data.matches) {
      result = { matches: data.matches };
    } else if (data.data?.matches) {
      result = data.data;
    } else {
      result = data;
    }
    
    if (!result.performance) {
      result.performance = {
        frontend_time_ms: performance.now() - startTime
      };
    }
    
    frontendCache.set(frontendCache.generateKey(trimmed, 'grammar', language), result);
    
    if (result.language_detection) {
    }
    return result;
    
  } catch (err) {
    console.error('checkGrammar error', err);
    throw new Error('Could not connect to the server to check grammar.');
  }
};

/**
 * NEW: Health check endpoint
 */
export const healthCheck = async () => {
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/health`);
    const data = await safeJson(res) || {};
    
    if (data?.success && data?.data) {
      return data.data;
    }
    
    return data;
  } catch (err) {
    console.error('healthCheck error', err);
    return {
      status: 'unhealthy',
      error: err.message
    };
  }
};

/**
 * NEW: Get language detection stats
 */
export const getDetectionStats = async () => {
  try {
    const res = await fetch(`${API_BASE_URL}/grammar/detection-stats`);
    const data = await safeJson(res) || {};
    
    if (data?.success && data?.data) {
      return data.data;
    }
    
    return data;
  } catch (err) {
    console.error('getDetectionStats error', err);
    throw err;
  }
};

/** registerUser */
export async function registerUser(userData) {
  try {
    const res = await fetch(`${API_BASE_URL}/users/register`, {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify(userData)
    });
    const data = await safeJson(res);
    return { 
      success: res.ok && data?.success, 
      message: data?.message, 
      error: data?.error, 
      status: res.status, 
      data: data?.data || data 
    };
  } catch (err) {
    console.error('registerUser error', err);
    return { success: false, error: 'Network error', status: 500 };
  }
}

/** loginUser (tolerant) */
export async function loginUser(username, password) {
  try {
    const res = await fetch(`${API_BASE_URL}/users/login`, {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify({ username, password })
    });
    const data = await safeJson(res) || {};
    return {
      success: res.ok && data.success,
      message: data.message || '',
      error: data.error || null,
      token: data.token || `session-${data.userId || '0'}-${Date.now()}`,
      userId: data.userId || data.id || data.user?.id,
      username: data.username || data.user?.username,
      email: data.email || data.user?.email,
      phone: data.phone || data.user?.phone,
      userRole: data.userRole || data.user?.userRole || data.role,
      status: res.status
    };
  } catch (err) {
    console.error('loginUser error', err);
    return { success: false, error: 'Network error', status: 500 };
  }
}

/** fetchUsers (admin) */
export const fetchUsers = async () => {
  try {
    const userData = (typeof AuthManager !== 'undefined') ? AuthManager.getCurrentUser() : null;
    if (!AuthManager.isAdmin) throw new Error('Authentication required');
    const res = await fetch(`${API_BASE_URL}/users/admin/users`, {
      method: 'GET', 
      headers: { 
        'Content-Type': 'application/json', 
        'x-user-role': userData.userRole 
      }
    });
    const data = await safeJson(res) || {};
    if (!res.ok) {
      throw new Error(data?.error || `HTTP ${res.status}`);
    }
    return data.users || data.data?.users || data.data || [];
  } catch (err) {
    console.error('fetchUsers error', err);
    throw err;
  }
};

/** updateUser */
export const updateUser = async (userId, userData) => {
  try {
    const currentUser = AuthManager.getCurrentUser();
    if (!currentUser || currentUser.userRole !== 'admin') {
      return { success: false, error: 'Admin auth required' };
    }
    const res = await fetch(`${API_BASE_URL}/users/admin/update/${userId}`, {
      method: 'PUT', 
      headers: { 
        'Content-Type': 'application/json', 
        'x-user-role': currentUser.userRole 
      }, 
      body: JSON.stringify(userData)
    });
    const data = await safeJson(res) || {};
    return { 
      success: res.ok && data.success, 
      error: data.error, 
      message: data.message 
    };
  } catch (err) {
    console.error('updateUser error', err);
    return { success: false, error: 'Network error' };
  }
};

/** deleteUser */
export const deleteUser = async (userId) => {
  try {
    const currentUser = AuthManager.getCurrentUser();
    if (!currentUser || currentUser.userRole !== 'admin') {
      return { success: false, error: 'Admin auth required' };
    }
    const res = await fetch(`${API_BASE_URL}/users/admin/delete/${userId}`, {
      method: 'DELETE', 
      headers: { 
        'Content-Type': 'application/json', 
        'x-user-role': currentUser.userRole 
      }
    });
    const data = await safeJson(res) || {};
    return { 
      success: res.ok && data.success, 
      error: data.error, 
      message: data.message 
    };
  } catch (err) {
    console.error('deleteUser error', err);
    return { success: false, error: 'Network error' };
  }
};

/* =========================
   Cache controls
   ========================= */
export const clearGrammarCache = () => { frontendCache.clear(); };
export const getCacheStats = () => frontendCache.getStats();
export const cacheManager = frontendCache;
```

### frontend\public\js\authManager.js
```js
'use strict';

const AuthManager = {
    getTabId() {
        let tabId = sessionStorage.getItem('tabId');
        if (!tabId) {
            tabId = 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('tabId', tabId);
            console.log('ğŸ†” New Tab ID created:', tabId);
        }
        return tabId;
    },

    getAllSessions() {
        const sessions = localStorage.getItem('userSessions');
        return sessions ? JSON.parse(sessions) : {};
    },

    getCurrentUser() {
        const tabId = this.getTabId();
        const allSessions = this.getAllSessions();
        const userData = allSessions[tabId];
        return userData ? { ...userData, _tabId: tabId } : null;
    },

    isLoggedIn() {
        return this.getCurrentUser() !== null;
    },

    isAdmin() {
        const user = this.getCurrentUser();
        return user?.userRole === 'admin';
    },

    canAccessGrammarChecker() {
        return this.isLoggedIn();
    },

    canAccessAdminPanel() {
        return this.isAdmin();
    },

    login(userData) {
        if (!userData || !userData.userRole) {
            throw new Error('Invalid user data');
        }

        const tabId = this.getTabId();
        const allSessions = this.getAllSessions();
        allSessions[tabId] = {
            ...userData,
            loginTime: Date.now(),
            lastActive: Date.now()
        };

        localStorage.setItem('userSessions', JSON.stringify(allSessions));
        console.log(`âœ… ${userData.userRole} logged in on tab ${tabId}:`, userData.username);
        window.dispatchEvent(new CustomEvent('auth-login', {
            detail: { user: userData, tabId: tabId }
        }));

        return userData;
    },

    logout() {
        const user = this.getCurrentUser();

        if (!user) {
            console.warn('No user to logout');
            return false;
        }

        const tabId = this.getTabId();
        const allSessions = this.getAllSessions();
        delete allSessions[tabId];
        localStorage.setItem('userSessions', JSON.stringify(allSessions));
        sessionStorage.removeItem('wasLoggedIn');

        console.log(`âœ… ${user.userRole} logged out from tab ${tabId}:`, user.username);

        localStorage.setItem('logout_sync', JSON.stringify({
            userId: user.userId,
            sessionId: tabId,
            time: Date.now()
        }));

        window.dispatchEvent(new CustomEvent('auth-logout', {
            detail: { user, tabId }
        }));

        return true;
    },

    logoutAll() {
        localStorage.removeItem('userSessions');
        sessionStorage.removeItem('wasLoggedIn');
        this.broadcastLogoutAll();
        window.dispatchEvent(new CustomEvent('auth-logout-all'));
        return true;
    },

    broadcastLogoutAll() {
        localStorage.setItem('logout_sync_all', Date.now());
    },

    updateActivity() {
        const tabId = this.getTabId();
        const allSessions = this.getAllSessions();
        if (allSessions[tabId]) {
            allSessions[tabId].lastActive = Date.now();
            localStorage.setItem('userSessions', JSON.stringify(allSessions));
        }
    },

    cleanupOldSessions(maxAge = 24 * 60 * 60 * 1000) {
        const allSessions = this.getAllSessions();
        const now = Date.now();
        const currentTabId = this.getTabId();

        let cleaned = 0;
        Object.keys(allSessions).forEach(tabId => {
            const s = allSessions[tabId];
            const lastActive = s.lastActive || s.loginTime || 0;
            if (tabId !== currentTabId && now - lastActive > maxAge) {
                delete allSessions[tabId];
                cleaned++;
            }
        });
        if (cleaned > 0) {
            localStorage.setItem('userSessions', JSON.stringify(allSessions));
            console.log(`ğŸ§¹ Cleaned up ${cleaned} old sessions`);
        }
        return cleaned;
    },

    getSessionsInfo() {
        const allSessions = this.getAllSessions();
        const currentTabId = this.getTabId();
        return Object.keys(allSessions).map(tabId => ({
            tabId,
            isCurrent: tabId === currentTabId,
            username: allSessions[tabId].username,
            userRole: allSessions[tabId].userRole,
            loginTime: new Date(allSessions[tabId].loginTime).toLocaleString(),
            lastActive: new Date(allSessions[tabId].lastActive).toLocaleString()
        }));
    },

    validatePageAccess() {
        const path = window.location.pathname;
        if (path.includes('admin') && !this.canAccessAdminPanel()) {
            console.warn('âš ï¸ Access denied to admin panel');
            window.location.href = '/login.html?message=admin_required';
            return false;
        }
        if (path.includes('GrammarChecker1') && !this.canAccessGrammarChecker()) {
            console.warn('âš ï¸ Access denied to grammar checker');
            window.location.href = '/login.html?message=login_required';
            return false;
        }
        return true;
    },

    setupActivityTracking() {
        const events = ['mousedown', 'keydown', 'scroll', 'touchstart'];
        let lastUpdate = Date.now();
        const updateInterval = 60000;

        events.forEach(eName => {
            document.addEventListener(eName, () => {
                const now = Date.now();
                if (now - lastUpdate > updateInterval) {
                    this.updateActivity();
                    lastUpdate = now;
                }
            }, { passive: true });
        });

        setInterval(() => {
            if (!document.hidden && this.isLoggedIn()) {
                this.updateActivity();
            }
        }, updateInterval);
    },

    setupLogoutSync() {
        window.addEventListener('storage', (event) => {
            if (event.key !== 'logout_sync') return;

            try {
                const data = JSON.parse(event.newValue);
                if (!data?.userId) return;

                const currentUser = this.getCurrentUser();
                if (currentUser && currentUser.userId === data.userId) {
                    console.log('ğŸ“¢ Logout sync received:', data);
                    this.localLogout();
                }
            } catch (err) {
                console.warn('âš ï¸ Error handling logout_sync event:', err);
            }
        });
    },

    localLogout() {
        const currentUser = this.getCurrentUser();
        if (!currentUser) return;

        const tabId = this.getTabId();
        const allSessions = this.getAllSessions();
        delete allSessions[tabId];
        localStorage.setItem('userSessions', JSON.stringify(allSessions));

        console.log(`ğŸšª [SYNC] Tab ${tabId} auto-logged out for userId: ${currentUser.userId}`);
        window.dispatchEvent(new CustomEvent('auth-logout-sync', {
            detail: { userId: currentUser.userId, tabId }
        }));

        window.location.href = '/login.html?message=logout_sync';
    },
};

// Initialize
if (typeof window !== 'undefined') {
    window.AuthManager = AuthManager;

    window.addEventListener('load', () => {
        AuthManager.cleanupOldSessions();
        AuthManager.setupActivityTracking();
        AuthManager.setupLogoutSync();
        AuthManager.validatePageAccess();
    });
}

```

### frontend\public\js\bootstrap.bundle.min.js
```js
/*!
  * Bootstrap v5.3.0 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).bootstrap=e()}(this,(function(){"use strict";const t=new Map,e={set(e,i,n){t.has(e)||t.set(e,new Map);const s=t.get(e);s.has(i)||0===s.size?s.set(i,n):console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)},get:(e,i)=>t.has(e)&&t.get(e).get(i)||null,remove(e,i){if(!t.has(e))return;const n=t.get(e);n.delete(i),0===n.size&&t.delete(e)}},i="transitionend",n=t=>(t&&window.CSS&&window.CSS.escape&&(t=t.replace(/#([^\s"#']+)/g,((t,e)=>`#${CSS.escape(e)}`))),t),s=t=>{t.dispatchEvent(new Event(i))},o=t=>!(!t||"object"!=typeof t)&&(void 0!==t.jquery&&(t=t[0]),void 0!==t.nodeType),r=t=>o(t)?t.jquery?t[0]:t:"string"==typeof t&&t.length>0?document.querySelector(n(t)):null,a=t=>{if(!o(t)||0===t.getClientRects().length)return!1;const e="visible"===getComputedStyle(t).getPropertyValue("visibility"),i=t.closest("details:not([open])");if(!i)return e;if(i!==t){const e=t.closest("summary");if(e&&e.parentNode!==i)return!1;if(null===e)return!1}return e},l=t=>!t||t.nodeType!==Node.ELEMENT_NODE||!!t.classList.contains("disabled")||(void 0!==t.disabled?t.disabled:t.hasAttribute("disabled")&&"false"!==t.getAttribute("disabled")),c=t=>{if(!document.documentElement.attachShadow)return null;if("function"==typeof t.getRootNode){const e=t.getRootNode();return e instanceof ShadowRoot?e:null}return t instanceof ShadowRoot?t:t.parentNode?c(t.parentNode):null},h=()=>{},d=t=>{t.offsetHeight},u=()=>window.jQuery&&!document.body.hasAttribute("data-bs-no-jquery")?window.jQuery:null,f=[],p=()=>"rtl"===document.documentElement.dir,m=t=>{var e;e=()=>{const e=u();if(e){const i=t.NAME,n=e.fn[i];e.fn[i]=t.jQueryInterface,e.fn[i].Constructor=t,e.fn[i].noConflict=()=>(e.fn[i]=n,t.jQueryInterface)}},"loading"===document.readyState?(f.length||document.addEventListener("DOMContentLoaded",(()=>{for(const t of f)t()})),f.push(e)):e()},g=(t,e=[],i=t)=>"function"==typeof t?t(...e):i,_=(t,e,n=!0)=>{if(!n)return void g(t);const o=(t=>{if(!t)return 0;let{transitionDuration:e,transitionDelay:i}=window.getComputedStyle(t);const n=Number.parseFloat(e),s=Number.parseFloat(i);return n||s?(e=e.split(",")[0],i=i.split(",")[0],1e3*(Number.parseFloat(e)+Number.parseFloat(i))):0})(e)+5;let r=!1;const a=({target:n})=>{n===e&&(r=!0,e.removeEventListener(i,a),g(t))};e.addEventListener(i,a),setTimeout((()=>{r||s(e)}),o)},b=(t,e,i,n)=>{const s=t.length;let o=t.indexOf(e);return-1===o?!i&&n?t[s-1]:t[0]:(o+=i?1:-1,n&&(o=(o+s)%s),t[Math.max(0,Math.min(o,s-1))])},v=/[^.]*(?=\..*)\.|.*/,y=/\..*/,w=/::\d+$/,A={};let E=1;const T={mouseenter:"mouseover",mouseleave:"mouseout"},C=new Set(["click","dblclick","mouseup","mousedown","contextmenu","mousewheel","DOMMouseScroll","mouseover","mouseout","mousemove","selectstart","selectend","keydown","keypress","keyup","orientationchange","touchstart","touchmove","touchend","touchcancel","pointerdown","pointermove","pointerup","pointerleave","pointercancel","gesturestart","gesturechange","gestureend","focus","blur","change","reset","select","submit","focusin","focusout","load","unload","beforeunload","resize","move","DOMContentLoaded","readystatechange","error","abort","scroll"]);function O(t,e){return e&&`${e}::${E++}`||t.uidEvent||E++}function x(t){const e=O(t);return t.uidEvent=e,A[e]=A[e]||{},A[e]}function k(t,e,i=null){return Object.values(t).find((t=>t.callable===e&&t.delegationSelector===i))}function L(t,e,i){const n="string"==typeof e,s=n?i:e||i;let o=N(t);return C.has(o)||(o=t),[n,s,o]}function S(t,e,i,n,s){if("string"!=typeof e||!t)return;let[o,r,a]=L(e,i,n);if(e in T){const t=t=>function(e){if(!e.relatedTarget||e.relatedTarget!==e.delegateTarget&&!e.delegateTarget.contains(e.relatedTarget))return t.call(this,e)};r=t(r)}const l=x(t),c=l[a]||(l[a]={}),h=k(c,r,o?i:null);if(h)return void(h.oneOff=h.oneOff&&s);const d=O(r,e.replace(v,"")),u=o?function(t,e,i){return function n(s){const o=t.querySelectorAll(e);for(let{target:r}=s;r&&r!==this;r=r.parentNode)for(const a of o)if(a===r)return M(s,{delegateTarget:r}),n.oneOff&&P.off(t,s.type,e,i),i.apply(r,[s])}}(t,i,r):function(t,e){return function i(n){return M(n,{delegateTarget:t}),i.oneOff&&P.off(t,n.type,e),e.apply(t,[n])}}(t,r);u.delegationSelector=o?i:null,u.callable=r,u.oneOff=s,u.uidEvent=d,c[d]=u,t.addEventListener(a,u,o)}function D(t,e,i,n,s){const o=k(e[i],n,s);o&&(t.removeEventListener(i,o,Boolean(s)),delete e[i][o.uidEvent])}function I(t,e,i,n){const s=e[i]||{};for(const[o,r]of Object.entries(s))o.includes(n)&&D(t,e,i,r.callable,r.delegationSelector)}function N(t){return t=t.replace(y,""),T[t]||t}const P={on(t,e,i,n){S(t,e,i,n,!1)},one(t,e,i,n){S(t,e,i,n,!0)},off(t,e,i,n){if("string"!=typeof e||!t)return;const[s,o,r]=L(e,i,n),a=r!==e,l=x(t),c=l[r]||{},h=e.startsWith(".");if(void 0===o){if(h)for(const i of Object.keys(l))I(t,l,i,e.slice(1));for(const[i,n]of Object.entries(c)){const s=i.replace(w,"");a&&!e.includes(s)||D(t,l,r,n.callable,n.delegationSelector)}}else{if(!Object.keys(c).length)return;D(t,l,r,o,s?i:null)}},trigger(t,e,i){if("string"!=typeof e||!t)return null;const n=u();let s=null,o=!0,r=!0,a=!1;e!==N(e)&&n&&(s=n.Event(e,i),n(t).trigger(s),o=!s.isPropagationStopped(),r=!s.isImmediatePropagationStopped(),a=s.isDefaultPrevented());const l=M(new Event(e,{bubbles:o,cancelable:!0}),i);return a&&l.preventDefault(),r&&t.dispatchEvent(l),l.defaultPrevented&&s&&s.preventDefault(),l}};function M(t,e={}){for(const[i,n]of Object.entries(e))try{t[i]=n}catch(e){Object.defineProperty(t,i,{configurable:!0,get:()=>n})}return t}function j(t){if("true"===t)return!0;if("false"===t)return!1;if(t===Number(t).toString())return Number(t);if(""===t||"null"===t)return null;if("string"!=typeof t)return t;try{return JSON.parse(decodeURIComponent(t))}catch(e){return t}}function F(t){return t.replace(/[A-Z]/g,(t=>`-${t.toLowerCase()}`))}const H={setDataAttribute(t,e,i){t.setAttribute(`data-bs-${F(e)}`,i)},removeDataAttribute(t,e){t.removeAttribute(`data-bs-${F(e)}`)},getDataAttributes(t){if(!t)return{};const e={},i=Object.keys(t.dataset).filter((t=>t.startsWith("bs")&&!t.startsWith("bsConfig")));for(const n of i){let i=n.replace(/^bs/,"");i=i.charAt(0).toLowerCase()+i.slice(1,i.length),e[i]=j(t.dataset[n])}return e},getDataAttribute:(t,e)=>j(t.getAttribute(`data-bs-${F(e)}`))};class ${static get Default(){return{}}static get DefaultType(){return{}}static get NAME(){throw new Error('You have to implement the static method "NAME", for each component!')}_getConfig(t){return t=this._mergeConfigObj(t),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}_configAfterMerge(t){return t}_mergeConfigObj(t,e){const i=o(e)?H.getDataAttribute(e,"config"):{};return{...this.constructor.Default,..."object"==typeof i?i:{},...o(e)?H.getDataAttributes(e):{},..."object"==typeof t?t:{}}}_typeCheckConfig(t,e=this.constructor.DefaultType){for(const[n,s]of Object.entries(e)){const e=t[n],r=o(e)?"element":null==(i=e)?`${i}`:Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();if(!new RegExp(s).test(r))throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`)}var i}}class W extends ${constructor(t,i){super(),(t=r(t))&&(this._element=t,this._config=this._getConfig(i),e.set(this._element,this.constructor.DATA_KEY,this))}dispose(){e.remove(this._element,this.constructor.DATA_KEY),P.off(this._element,this.constructor.EVENT_KEY);for(const t of Object.getOwnPropertyNames(this))this[t]=null}_queueCallback(t,e,i=!0){_(t,e,i)}_getConfig(t){return t=this._mergeConfigObj(t,this._element),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}static getInstance(t){return e.get(r(t),this.DATA_KEY)}static getOrCreateInstance(t,e={}){return this.getInstance(t)||new this(t,"object"==typeof e?e:null)}static get VERSION(){return"5.3.0"}static get DATA_KEY(){return`bs.${this.NAME}`}static get EVENT_KEY(){return`.${this.DATA_KEY}`}static eventName(t){return`${t}${this.EVENT_KEY}`}}const B=t=>{let e=t.getAttribute("data-bs-target");if(!e||"#"===e){let i=t.getAttribute("href");if(!i||!i.includes("#")&&!i.startsWith("."))return null;i.includes("#")&&!i.startsWith("#")&&(i=`#${i.split("#")[1]}`),e=i&&"#"!==i?i.trim():null}return n(e)},z={find:(t,e=document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(e,t)),findOne:(t,e=document.documentElement)=>Element.prototype.querySelector.call(e,t),children:(t,e)=>[].concat(...t.children).filter((t=>t.matches(e))),parents(t,e){const i=[];let n=t.parentNode.closest(e);for(;n;)i.push(n),n=n.parentNode.closest(e);return i},prev(t,e){let i=t.previousElementSibling;for(;i;){if(i.matches(e))return[i];i=i.previousElementSibling}return[]},next(t,e){let i=t.nextElementSibling;for(;i;){if(i.matches(e))return[i];i=i.nextElementSibling}return[]},focusableChildren(t){const e=["a","button","input","textarea","select","details","[tabindex]",'[contenteditable="true"]'].map((t=>`${t}:not([tabindex^="-"])`)).join(",");return this.find(e,t).filter((t=>!l(t)&&a(t)))},getSelectorFromElement(t){const e=B(t);return e&&z.findOne(e)?e:null},getElementFromSelector(t){const e=B(t);return e?z.findOne(e):null},getMultipleElementsFromSelector(t){const e=B(t);return e?z.find(e):[]}},R=(t,e="hide")=>{const i=`click.dismiss${t.EVENT_KEY}`,n=t.NAME;P.on(document,i,`[data-bs-dismiss="${n}"]`,(function(i){if(["A","AREA"].includes(this.tagName)&&i.preventDefault(),l(this))return;const s=z.getElementFromSelector(this)||this.closest(`.${n}`);t.getOrCreateInstance(s)[e]()}))};class q extends W{static get NAME(){return"alert"}close(){if(P.trigger(this._element,"close.bs.alert").defaultPrevented)return;this._element.classList.remove("show");const t=this._element.classList.contains("fade");this._queueCallback((()=>this._destroyElement()),this._element,t)}_destroyElement(){this._element.remove(),P.trigger(this._element,"closed.bs.alert"),this.dispose()}static jQueryInterface(t){return this.each((function(){const e=q.getOrCreateInstance(this);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}R(q,"close"),m(q);const V='[data-bs-toggle="button"]';class K extends W{static get NAME(){return"button"}toggle(){this._element.setAttribute("aria-pressed",this._element.classList.toggle("active"))}static jQueryInterface(t){return this.each((function(){const e=K.getOrCreateInstance(this);"toggle"===t&&e[t]()}))}}P.on(document,"click.bs.button.data-api",V,(t=>{t.preventDefault();const e=t.target.closest(V);K.getOrCreateInstance(e).toggle()})),m(K);const Q={endCallback:null,leftCallback:null,rightCallback:null},X={endCallback:"(function|null)",leftCallback:"(function|null)",rightCallback:"(function|null)"};class Y extends ${constructor(t,e){super(),this._element=t,t&&Y.isSupported()&&(this._config=this._getConfig(e),this._deltaX=0,this._supportPointerEvents=Boolean(window.PointerEvent),this._initEvents())}static get Default(){return Q}static get DefaultType(){return X}static get NAME(){return"swipe"}dispose(){P.off(this._element,".bs.swipe")}_start(t){this._supportPointerEvents?this._eventIsPointerPenTouch(t)&&(this._deltaX=t.clientX):this._deltaX=t.touches[0].clientX}_end(t){this._eventIsPointerPenTouch(t)&&(this._deltaX=t.clientX-this._deltaX),this._handleSwipe(),g(this._config.endCallback)}_move(t){this._deltaX=t.touches&&t.touches.length>1?0:t.touches[0].clientX-this._deltaX}_handleSwipe(){const t=Math.abs(this._deltaX);if(t<=40)return;const e=t/this._deltaX;this._deltaX=0,e&&g(e>0?this._config.rightCallback:this._config.leftCallback)}_initEvents(){this._supportPointerEvents?(P.on(this._element,"pointerdown.bs.swipe",(t=>this._start(t))),P.on(this._element,"pointerup.bs.swipe",(t=>this._end(t))),this._element.classList.add("pointer-event")):(P.on(this._element,"touchstart.bs.swipe",(t=>this._start(t))),P.on(this._element,"touchmove.bs.swipe",(t=>this._move(t))),P.on(this._element,"touchend.bs.swipe",(t=>this._end(t))))}_eventIsPointerPenTouch(t){return this._supportPointerEvents&&("pen"===t.pointerType||"touch"===t.pointerType)}static isSupported(){return"ontouchstart"in document.documentElement||navigator.maxTouchPoints>0}}const U="next",G="prev",J="left",Z="right",tt="slid.bs.carousel",et="carousel",it="active",nt={ArrowLeft:Z,ArrowRight:J},st={interval:5e3,keyboard:!0,pause:"hover",ride:!1,touch:!0,wrap:!0},ot={interval:"(number|boolean)",keyboard:"boolean",pause:"(string|boolean)",ride:"(boolean|string)",touch:"boolean",wrap:"boolean"};class rt extends W{constructor(t,e){super(t,e),this._interval=null,this._activeElement=null,this._isSliding=!1,this.touchTimeout=null,this._swipeHelper=null,this._indicatorsElement=z.findOne(".carousel-indicators",this._element),this._addEventListeners(),this._config.ride===et&&this.cycle()}static get Default(){return st}static get DefaultType(){return ot}static get NAME(){return"carousel"}next(){this._slide(U)}nextWhenVisible(){!document.hidden&&a(this._element)&&this.next()}prev(){this._slide(G)}pause(){this._isSliding&&s(this._element),this._clearInterval()}cycle(){this._clearInterval(),this._updateInterval(),this._interval=setInterval((()=>this.nextWhenVisible()),this._config.interval)}_maybeEnableCycle(){this._config.ride&&(this._isSliding?P.one(this._element,tt,(()=>this.cycle())):this.cycle())}to(t){const e=this._getItems();if(t>e.length-1||t<0)return;if(this._isSliding)return void P.one(this._element,tt,(()=>this.to(t)));const i=this._getItemIndex(this._getActive());if(i===t)return;const n=t>i?U:G;this._slide(n,e[t])}dispose(){this._swipeHelper&&this._swipeHelper.dispose(),super.dispose()}_configAfterMerge(t){return t.defaultInterval=t.interval,t}_addEventListeners(){this._config.keyboard&&P.on(this._element,"keydown.bs.carousel",(t=>this._keydown(t))),"hover"===this._config.pause&&(P.on(this._element,"mouseenter.bs.carousel",(()=>this.pause())),P.on(this._element,"mouseleave.bs.carousel",(()=>this._maybeEnableCycle()))),this._config.touch&&Y.isSupported()&&this._addTouchEventListeners()}_addTouchEventListeners(){for(const t of z.find(".carousel-item img",this._element))P.on(t,"dragstart.bs.carousel",(t=>t.preventDefault()));const t={leftCallback:()=>this._slide(this._directionToOrder(J)),rightCallback:()=>this._slide(this._directionToOrder(Z)),endCallback:()=>{"hover"===this._config.pause&&(this.pause(),this.touchTimeout&&clearTimeout(this.touchTimeout),this.touchTimeout=setTimeout((()=>this._maybeEnableCycle()),500+this._config.interval))}};this._swipeHelper=new Y(this._element,t)}_keydown(t){if(/input|textarea/i.test(t.target.tagName))return;const e=nt[t.key];e&&(t.preventDefault(),this._slide(this._directionToOrder(e)))}_getItemIndex(t){return this._getItems().indexOf(t)}_setActiveIndicatorElement(t){if(!this._indicatorsElement)return;const e=z.findOne(".active",this._indicatorsElement);e.classList.remove(it),e.removeAttribute("aria-current");const i=z.findOne(`[data-bs-slide-to="${t}"]`,this._indicatorsElement);i&&(i.classList.add(it),i.setAttribute("aria-current","true"))}_updateInterval(){const t=this._activeElement||this._getActive();if(!t)return;const e=Number.parseInt(t.getAttribute("data-bs-interval"),10);this._config.interval=e||this._config.defaultInterval}_slide(t,e=null){if(this._isSliding)return;const i=this._getActive(),n=t===U,s=e||b(this._getItems(),i,n,this._config.wrap);if(s===i)return;const o=this._getItemIndex(s),r=e=>P.trigger(this._element,e,{relatedTarget:s,direction:this._orderToDirection(t),from:this._getItemIndex(i),to:o});if(r("slide.bs.carousel").defaultPrevented)return;if(!i||!s)return;const a=Boolean(this._interval);this.pause(),this._isSliding=!0,this._setActiveIndicatorElement(o),this._activeElement=s;const l=n?"carousel-item-start":"carousel-item-end",c=n?"carousel-item-next":"carousel-item-prev";s.classList.add(c),d(s),i.classList.add(l),s.classList.add(l),this._queueCallback((()=>{s.classList.remove(l,c),s.classList.add(it),i.classList.remove(it,c,l),this._isSliding=!1,r(tt)}),i,this._isAnimated()),a&&this.cycle()}_isAnimated(){return this._element.classList.contains("slide")}_getActive(){return z.findOne(".active.carousel-item",this._element)}_getItems(){return z.find(".carousel-item",this._element)}_clearInterval(){this._interval&&(clearInterval(this._interval),this._interval=null)}_directionToOrder(t){return p()?t===J?G:U:t===J?U:G}_orderToDirection(t){return p()?t===G?J:Z:t===G?Z:J}static jQueryInterface(t){return this.each((function(){const e=rt.getOrCreateInstance(this,t);if("number"!=typeof t){if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}else e.to(t)}))}}P.on(document,"click.bs.carousel.data-api","[data-bs-slide], [data-bs-slide-to]",(function(t){const e=z.getElementFromSelector(this);if(!e||!e.classList.contains(et))return;t.preventDefault();const i=rt.getOrCreateInstance(e),n=this.getAttribute("data-bs-slide-to");return n?(i.to(n),void i._maybeEnableCycle()):"next"===H.getDataAttribute(this,"slide")?(i.next(),void i._maybeEnableCycle()):(i.prev(),void i._maybeEnableCycle())})),P.on(window,"load.bs.carousel.data-api",(()=>{const t=z.find('[data-bs-ride="carousel"]');for(const e of t)rt.getOrCreateInstance(e)})),m(rt);const at="show",lt="collapse",ct="collapsing",ht='[data-bs-toggle="collapse"]',dt={parent:null,toggle:!0},ut={parent:"(null|element)",toggle:"boolean"};class ft extends W{constructor(t,e){super(t,e),this._isTransitioning=!1,this._triggerArray=[];const i=z.find(ht);for(const t of i){const e=z.getSelectorFromElement(t),i=z.find(e).filter((t=>t===this._element));null!==e&&i.length&&this._triggerArray.push(t)}this._initializeChildren(),this._config.parent||this._addAriaAndCollapsedClass(this._triggerArray,this._isShown()),this._config.toggle&&this.toggle()}static get Default(){return dt}static get DefaultType(){return ut}static get NAME(){return"collapse"}toggle(){this._isShown()?this.hide():this.show()}show(){if(this._isTransitioning||this._isShown())return;let t=[];if(this._config.parent&&(t=this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t=>t!==this._element)).map((t=>ft.getOrCreateInstance(t,{toggle:!1})))),t.length&&t[0]._isTransitioning)return;if(P.trigger(this._element,"show.bs.collapse").defaultPrevented)return;for(const e of t)e.hide();const e=this._getDimension();this._element.classList.remove(lt),this._element.classList.add(ct),this._element.style[e]=0,this._addAriaAndCollapsedClass(this._triggerArray,!0),this._isTransitioning=!0;const i=`scroll${e[0].toUpperCase()+e.slice(1)}`;this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ct),this._element.classList.add(lt,at),this._element.style[e]="",P.trigger(this._element,"shown.bs.collapse")}),this._element,!0),this._element.style[e]=`${this._element[i]}px`}hide(){if(this._isTransitioning||!this._isShown())return;if(P.trigger(this._element,"hide.bs.collapse").defaultPrevented)return;const t=this._getDimension();this._element.style[t]=`${this._element.getBoundingClientRect()[t]}px`,d(this._element),this._element.classList.add(ct),this._element.classList.remove(lt,at);for(const t of this._triggerArray){const e=z.getElementFromSelector(t);e&&!this._isShown(e)&&this._addAriaAndCollapsedClass([t],!1)}this._isTransitioning=!0,this._element.style[t]="",this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ct),this._element.classList.add(lt),P.trigger(this._element,"hidden.bs.collapse")}),this._element,!0)}_isShown(t=this._element){return t.classList.contains(at)}_configAfterMerge(t){return t.toggle=Boolean(t.toggle),t.parent=r(t.parent),t}_getDimension(){return this._element.classList.contains("collapse-horizontal")?"width":"height"}_initializeChildren(){if(!this._config.parent)return;const t=this._getFirstLevelChildren(ht);for(const e of t){const t=z.getElementFromSelector(e);t&&this._addAriaAndCollapsedClass([e],this._isShown(t))}}_getFirstLevelChildren(t){const e=z.find(":scope .collapse .collapse",this._config.parent);return z.find(t,this._config.parent).filter((t=>!e.includes(t)))}_addAriaAndCollapsedClass(t,e){if(t.length)for(const i of t)i.classList.toggle("collapsed",!e),i.setAttribute("aria-expanded",e)}static jQueryInterface(t){const e={};return"string"==typeof t&&/show|hide/.test(t)&&(e.toggle=!1),this.each((function(){const i=ft.getOrCreateInstance(this,e);if("string"==typeof t){if(void 0===i[t])throw new TypeError(`No method named "${t}"`);i[t]()}}))}}P.on(document,"click.bs.collapse.data-api",ht,(function(t){("A"===t.target.tagName||t.delegateTarget&&"A"===t.delegateTarget.tagName)&&t.preventDefault();for(const t of z.getMultipleElementsFromSelector(this))ft.getOrCreateInstance(t,{toggle:!1}).toggle()})),m(ft);var pt="top",mt="bottom",gt="right",_t="left",bt="auto",vt=[pt,mt,gt,_t],yt="start",wt="end",At="clippingParents",Et="viewport",Tt="popper",Ct="reference",Ot=vt.reduce((function(t,e){return t.concat([e+"-"+yt,e+"-"+wt])}),[]),xt=[].concat(vt,[bt]).reduce((function(t,e){return t.concat([e,e+"-"+yt,e+"-"+wt])}),[]),kt="beforeRead",Lt="read",St="afterRead",Dt="beforeMain",It="main",Nt="afterMain",Pt="beforeWrite",Mt="write",jt="afterWrite",Ft=[kt,Lt,St,Dt,It,Nt,Pt,Mt,jt];function Ht(t){return t?(t.nodeName||"").toLowerCase():null}function $t(t){if(null==t)return window;if("[object Window]"!==t.toString()){var e=t.ownerDocument;return e&&e.defaultView||window}return t}function Wt(t){return t instanceof $t(t).Element||t instanceof Element}function Bt(t){return t instanceof $t(t).HTMLElement||t instanceof HTMLElement}function zt(t){return"undefined"!=typeof ShadowRoot&&(t instanceof $t(t).ShadowRoot||t instanceof ShadowRoot)}const Rt={name:"applyStyles",enabled:!0,phase:"write",fn:function(t){var e=t.state;Object.keys(e.elements).forEach((function(t){var i=e.styles[t]||{},n=e.attributes[t]||{},s=e.elements[t];Bt(s)&&Ht(s)&&(Object.assign(s.style,i),Object.keys(n).forEach((function(t){var e=n[t];!1===e?s.removeAttribute(t):s.setAttribute(t,!0===e?"":e)})))}))},effect:function(t){var e=t.state,i={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(e.elements.popper.style,i.popper),e.styles=i,e.elements.arrow&&Object.assign(e.elements.arrow.style,i.arrow),function(){Object.keys(e.elements).forEach((function(t){var n=e.elements[t],s=e.attributes[t]||{},o=Object.keys(e.styles.hasOwnProperty(t)?e.styles[t]:i[t]).reduce((function(t,e){return t[e]="",t}),{});Bt(n)&&Ht(n)&&(Object.assign(n.style,o),Object.keys(s).forEach((function(t){n.removeAttribute(t)})))}))}},requires:["computeStyles"]};function qt(t){return t.split("-")[0]}var Vt=Math.max,Kt=Math.min,Qt=Math.round;function Xt(){var t=navigator.userAgentData;return null!=t&&t.brands&&Array.isArray(t.brands)?t.brands.map((function(t){return t.brand+"/"+t.version})).join(" "):navigator.userAgent}function Yt(){return!/^((?!chrome|android).)*safari/i.test(Xt())}function Ut(t,e,i){void 0===e&&(e=!1),void 0===i&&(i=!1);var n=t.getBoundingClientRect(),s=1,o=1;e&&Bt(t)&&(s=t.offsetWidth>0&&Qt(n.width)/t.offsetWidth||1,o=t.offsetHeight>0&&Qt(n.height)/t.offsetHeight||1);var r=(Wt(t)?$t(t):window).visualViewport,a=!Yt()&&i,l=(n.left+(a&&r?r.offsetLeft:0))/s,c=(n.top+(a&&r?r.offsetTop:0))/o,h=n.width/s,d=n.height/o;return{width:h,height:d,top:c,right:l+h,bottom:c+d,left:l,x:l,y:c}}function Gt(t){var e=Ut(t),i=t.offsetWidth,n=t.offsetHeight;return Math.abs(e.width-i)<=1&&(i=e.width),Math.abs(e.height-n)<=1&&(n=e.height),{x:t.offsetLeft,y:t.offsetTop,width:i,height:n}}function Jt(t,e){var i=e.getRootNode&&e.getRootNode();if(t.contains(e))return!0;if(i&&zt(i)){var n=e;do{if(n&&t.isSameNode(n))return!0;n=n.parentNode||n.host}while(n)}return!1}function Zt(t){return $t(t).getComputedStyle(t)}function te(t){return["table","td","th"].indexOf(Ht(t))>=0}function ee(t){return((Wt(t)?t.ownerDocument:t.document)||window.document).documentElement}function ie(t){return"html"===Ht(t)?t:t.assignedSlot||t.parentNode||(zt(t)?t.host:null)||ee(t)}function ne(t){return Bt(t)&&"fixed"!==Zt(t).position?t.offsetParent:null}function se(t){for(var e=$t(t),i=ne(t);i&&te(i)&&"static"===Zt(i).position;)i=ne(i);return i&&("html"===Ht(i)||"body"===Ht(i)&&"static"===Zt(i).position)?e:i||function(t){var e=/firefox/i.test(Xt());if(/Trident/i.test(Xt())&&Bt(t)&&"fixed"===Zt(t).position)return null;var i=ie(t);for(zt(i)&&(i=i.host);Bt(i)&&["html","body"].indexOf(Ht(i))<0;){var n=Zt(i);if("none"!==n.transform||"none"!==n.perspective||"paint"===n.contain||-1!==["transform","perspective"].indexOf(n.willChange)||e&&"filter"===n.willChange||e&&n.filter&&"none"!==n.filter)return i;i=i.parentNode}return null}(t)||e}function oe(t){return["top","bottom"].indexOf(t)>=0?"x":"y"}function re(t,e,i){return Vt(t,Kt(e,i))}function ae(t){return Object.assign({},{top:0,right:0,bottom:0,left:0},t)}function le(t,e){return e.reduce((function(e,i){return e[i]=t,e}),{})}const ce={name:"arrow",enabled:!0,phase:"main",fn:function(t){var e,i=t.state,n=t.name,s=t.options,o=i.elements.arrow,r=i.modifiersData.popperOffsets,a=qt(i.placement),l=oe(a),c=[_t,gt].indexOf(a)>=0?"height":"width";if(o&&r){var h=function(t,e){return ae("number"!=typeof(t="function"==typeof t?t(Object.assign({},e.rects,{placement:e.placement})):t)?t:le(t,vt))}(s.padding,i),d=Gt(o),u="y"===l?pt:_t,f="y"===l?mt:gt,p=i.rects.reference[c]+i.rects.reference[l]-r[l]-i.rects.popper[c],m=r[l]-i.rects.reference[l],g=se(o),_=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=p/2-m/2,v=h[u],y=_-d[c]-h[f],w=_/2-d[c]/2+b,A=re(v,w,y),E=l;i.modifiersData[n]=((e={})[E]=A,e.centerOffset=A-w,e)}},effect:function(t){var e=t.state,i=t.options.element,n=void 0===i?"[data-popper-arrow]":i;null!=n&&("string"!=typeof n||(n=e.elements.popper.querySelector(n)))&&Jt(e.elements.popper,n)&&(e.elements.arrow=n)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function he(t){return t.split("-")[1]}var de={top:"auto",right:"auto",bottom:"auto",left:"auto"};function ue(t){var e,i=t.popper,n=t.popperRect,s=t.placement,o=t.variation,r=t.offsets,a=t.position,l=t.gpuAcceleration,c=t.adaptive,h=t.roundOffsets,d=t.isFixed,u=r.x,f=void 0===u?0:u,p=r.y,m=void 0===p?0:p,g="function"==typeof h?h({x:f,y:m}):{x:f,y:m};f=g.x,m=g.y;var _=r.hasOwnProperty("x"),b=r.hasOwnProperty("y"),v=_t,y=pt,w=window;if(c){var A=se(i),E="clientHeight",T="clientWidth";A===$t(i)&&"static"!==Zt(A=ee(i)).position&&"absolute"===a&&(E="scrollHeight",T="scrollWidth"),(s===pt||(s===_t||s===gt)&&o===wt)&&(y=mt,m-=(d&&A===w&&w.visualViewport?w.visualViewport.height:A[E])-n.height,m*=l?1:-1),s!==_t&&(s!==pt&&s!==mt||o!==wt)||(v=gt,f-=(d&&A===w&&w.visualViewport?w.visualViewport.width:A[T])-n.width,f*=l?1:-1)}var C,O=Object.assign({position:a},c&&de),x=!0===h?function(t,e){var i=t.x,n=t.y,s=e.devicePixelRatio||1;return{x:Qt(i*s)/s||0,y:Qt(n*s)/s||0}}({x:f,y:m},$t(i)):{x:f,y:m};return f=x.x,m=x.y,l?Object.assign({},O,((C={})[y]=b?"0":"",C[v]=_?"0":"",C.transform=(w.devicePixelRatio||1)<=1?"translate("+f+"px, "+m+"px)":"translate3d("+f+"px, "+m+"px, 0)",C)):Object.assign({},O,((e={})[y]=b?m+"px":"",e[v]=_?f+"px":"",e.transform="",e))}const fe={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(t){var e=t.state,i=t.options,n=i.gpuAcceleration,s=void 0===n||n,o=i.adaptive,r=void 0===o||o,a=i.roundOffsets,l=void 0===a||a,c={placement:qt(e.placement),variation:he(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:s,isFixed:"fixed"===e.options.strategy};null!=e.modifiersData.popperOffsets&&(e.styles.popper=Object.assign({},e.styles.popper,ue(Object.assign({},c,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:r,roundOffsets:l})))),null!=e.modifiersData.arrow&&(e.styles.arrow=Object.assign({},e.styles.arrow,ue(Object.assign({},c,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})},data:{}};var pe={passive:!0};const me={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(t){var e=t.state,i=t.instance,n=t.options,s=n.scroll,o=void 0===s||s,r=n.resize,a=void 0===r||r,l=$t(e.elements.popper),c=[].concat(e.scrollParents.reference,e.scrollParents.popper);return o&&c.forEach((function(t){t.addEventListener("scroll",i.update,pe)})),a&&l.addEventListener("resize",i.update,pe),function(){o&&c.forEach((function(t){t.removeEventListener("scroll",i.update,pe)})),a&&l.removeEventListener("resize",i.update,pe)}},data:{}};var ge={left:"right",right:"left",bottom:"top",top:"bottom"};function _e(t){return t.replace(/left|right|bottom|top/g,(function(t){return ge[t]}))}var be={start:"end",end:"start"};function ve(t){return t.replace(/start|end/g,(function(t){return be[t]}))}function ye(t){var e=$t(t);return{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function we(t){return Ut(ee(t)).left+ye(t).scrollLeft}function Ae(t){var e=Zt(t),i=e.overflow,n=e.overflowX,s=e.overflowY;return/auto|scroll|overlay|hidden/.test(i+s+n)}function Ee(t){return["html","body","#document"].indexOf(Ht(t))>=0?t.ownerDocument.body:Bt(t)&&Ae(t)?t:Ee(ie(t))}function Te(t,e){var i;void 0===e&&(e=[]);var n=Ee(t),s=n===(null==(i=t.ownerDocument)?void 0:i.body),o=$t(n),r=s?[o].concat(o.visualViewport||[],Ae(n)?n:[]):n,a=e.concat(r);return s?a:a.concat(Te(ie(r)))}function Ce(t){return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}function Oe(t,e,i){return e===Et?Ce(function(t,e){var i=$t(t),n=ee(t),s=i.visualViewport,o=n.clientWidth,r=n.clientHeight,a=0,l=0;if(s){o=s.width,r=s.height;var c=Yt();(c||!c&&"fixed"===e)&&(a=s.offsetLeft,l=s.offsetTop)}return{width:o,height:r,x:a+we(t),y:l}}(t,i)):Wt(e)?function(t,e){var i=Ut(t,!1,"fixed"===e);return i.top=i.top+t.clientTop,i.left=i.left+t.clientLeft,i.bottom=i.top+t.clientHeight,i.right=i.left+t.clientWidth,i.width=t.clientWidth,i.height=t.clientHeight,i.x=i.left,i.y=i.top,i}(e,i):Ce(function(t){var e,i=ee(t),n=ye(t),s=null==(e=t.ownerDocument)?void 0:e.body,o=Vt(i.scrollWidth,i.clientWidth,s?s.scrollWidth:0,s?s.clientWidth:0),r=Vt(i.scrollHeight,i.clientHeight,s?s.scrollHeight:0,s?s.clientHeight:0),a=-n.scrollLeft+we(t),l=-n.scrollTop;return"rtl"===Zt(s||i).direction&&(a+=Vt(i.clientWidth,s?s.clientWidth:0)-o),{width:o,height:r,x:a,y:l}}(ee(t)))}function xe(t){var e,i=t.reference,n=t.element,s=t.placement,o=s?qt(s):null,r=s?he(s):null,a=i.x+i.width/2-n.width/2,l=i.y+i.height/2-n.height/2;switch(o){case pt:e={x:a,y:i.y-n.height};break;case mt:e={x:a,y:i.y+i.height};break;case gt:e={x:i.x+i.width,y:l};break;case _t:e={x:i.x-n.width,y:l};break;default:e={x:i.x,y:i.y}}var c=o?oe(o):null;if(null!=c){var h="y"===c?"height":"width";switch(r){case yt:e[c]=e[c]-(i[h]/2-n[h]/2);break;case wt:e[c]=e[c]+(i[h]/2-n[h]/2)}}return e}function ke(t,e){void 0===e&&(e={});var i=e,n=i.placement,s=void 0===n?t.placement:n,o=i.strategy,r=void 0===o?t.strategy:o,a=i.boundary,l=void 0===a?At:a,c=i.rootBoundary,h=void 0===c?Et:c,d=i.elementContext,u=void 0===d?Tt:d,f=i.altBoundary,p=void 0!==f&&f,m=i.padding,g=void 0===m?0:m,_=ae("number"!=typeof g?g:le(g,vt)),b=u===Tt?Ct:Tt,v=t.rects.popper,y=t.elements[p?b:u],w=function(t,e,i,n){var s="clippingParents"===e?function(t){var e=Te(ie(t)),i=["absolute","fixed"].indexOf(Zt(t).position)>=0&&Bt(t)?se(t):t;return Wt(i)?e.filter((function(t){return Wt(t)&&Jt(t,i)&&"body"!==Ht(t)})):[]}(t):[].concat(e),o=[].concat(s,[i]),r=o[0],a=o.reduce((function(e,i){var s=Oe(t,i,n);return e.top=Vt(s.top,e.top),e.right=Kt(s.right,e.right),e.bottom=Kt(s.bottom,e.bottom),e.left=Vt(s.left,e.left),e}),Oe(t,r,n));return a.width=a.right-a.left,a.height=a.bottom-a.top,a.x=a.left,a.y=a.top,a}(Wt(y)?y:y.contextElement||ee(t.elements.popper),l,h,r),A=Ut(t.elements.reference),E=xe({reference:A,element:v,strategy:"absolute",placement:s}),T=Ce(Object.assign({},v,E)),C=u===Tt?T:A,O={top:w.top-C.top+_.top,bottom:C.bottom-w.bottom+_.bottom,left:w.left-C.left+_.left,right:C.right-w.right+_.right},x=t.modifiersData.offset;if(u===Tt&&x){var k=x[s];Object.keys(O).forEach((function(t){var e=[gt,mt].indexOf(t)>=0?1:-1,i=[pt,mt].indexOf(t)>=0?"y":"x";O[t]+=k[i]*e}))}return O}function Le(t,e){void 0===e&&(e={});var i=e,n=i.placement,s=i.boundary,o=i.rootBoundary,r=i.padding,a=i.flipVariations,l=i.allowedAutoPlacements,c=void 0===l?xt:l,h=he(n),d=h?a?Ot:Ot.filter((function(t){return he(t)===h})):vt,u=d.filter((function(t){return c.indexOf(t)>=0}));0===u.length&&(u=d);var f=u.reduce((function(e,i){return e[i]=ke(t,{placement:i,boundary:s,rootBoundary:o,padding:r})[qt(i)],e}),{});return Object.keys(f).sort((function(t,e){return f[t]-f[e]}))}const Se={name:"flip",enabled:!0,phase:"main",fn:function(t){var e=t.state,i=t.options,n=t.name;if(!e.modifiersData[n]._skip){for(var s=i.mainAxis,o=void 0===s||s,r=i.altAxis,a=void 0===r||r,l=i.fallbackPlacements,c=i.padding,h=i.boundary,d=i.rootBoundary,u=i.altBoundary,f=i.flipVariations,p=void 0===f||f,m=i.allowedAutoPlacements,g=e.options.placement,_=qt(g),b=l||(_!==g&&p?function(t){if(qt(t)===bt)return[];var e=_e(t);return[ve(t),e,ve(e)]}(g):[_e(g)]),v=[g].concat(b).reduce((function(t,i){return t.concat(qt(i)===bt?Le(e,{placement:i,boundary:h,rootBoundary:d,padding:c,flipVariations:p,allowedAutoPlacements:m}):i)}),[]),y=e.rects.reference,w=e.rects.popper,A=new Map,E=!0,T=v[0],C=0;C<v.length;C++){var O=v[C],x=qt(O),k=he(O)===yt,L=[pt,mt].indexOf(x)>=0,S=L?"width":"height",D=ke(e,{placement:O,boundary:h,rootBoundary:d,altBoundary:u,padding:c}),I=L?k?gt:_t:k?mt:pt;y[S]>w[S]&&(I=_e(I));var N=_e(I),P=[];if(o&&P.push(D[x]<=0),a&&P.push(D[I]<=0,D[N]<=0),P.every((function(t){return t}))){T=O,E=!1;break}A.set(O,P)}if(E)for(var M=function(t){var e=v.find((function(e){var i=A.get(e);if(i)return i.slice(0,t).every((function(t){return t}))}));if(e)return T=e,"break"},j=p?3:1;j>0&&"break"!==M(j);j--);e.placement!==T&&(e.modifiersData[n]._skip=!0,e.placement=T,e.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function De(t,e,i){return void 0===i&&(i={x:0,y:0}),{top:t.top-e.height-i.y,right:t.right-e.width+i.x,bottom:t.bottom-e.height+i.y,left:t.left-e.width-i.x}}function Ie(t){return[pt,gt,mt,_t].some((function(e){return t[e]>=0}))}const Ne={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(t){var e=t.state,i=t.name,n=e.rects.reference,s=e.rects.popper,o=e.modifiersData.preventOverflow,r=ke(e,{elementContext:"reference"}),a=ke(e,{altBoundary:!0}),l=De(r,n),c=De(a,s,o),h=Ie(l),d=Ie(c);e.modifiersData[i]={referenceClippingOffsets:l,popperEscapeOffsets:c,isReferenceHidden:h,hasPopperEscaped:d},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":h,"data-popper-escaped":d})}},Pe={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(t){var e=t.state,i=t.options,n=t.name,s=i.offset,o=void 0===s?[0,0]:s,r=xt.reduce((function(t,i){return t[i]=function(t,e,i){var n=qt(t),s=[_t,pt].indexOf(n)>=0?-1:1,o="function"==typeof i?i(Object.assign({},e,{placement:t})):i,r=o[0],a=o[1];return r=r||0,a=(a||0)*s,[_t,gt].indexOf(n)>=0?{x:a,y:r}:{x:r,y:a}}(i,e.rects,o),t}),{}),a=r[e.placement],l=a.x,c=a.y;null!=e.modifiersData.popperOffsets&&(e.modifiersData.popperOffsets.x+=l,e.modifiersData.popperOffsets.y+=c),e.modifiersData[n]=r}},Me={name:"popperOffsets",enabled:!0,phase:"read",fn:function(t){var e=t.state,i=t.name;e.modifiersData[i]=xe({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})},data:{}},je={name:"preventOverflow",enabled:!0,phase:"main",fn:function(t){var e=t.state,i=t.options,n=t.name,s=i.mainAxis,o=void 0===s||s,r=i.altAxis,a=void 0!==r&&r,l=i.boundary,c=i.rootBoundary,h=i.altBoundary,d=i.padding,u=i.tether,f=void 0===u||u,p=i.tetherOffset,m=void 0===p?0:p,g=ke(e,{boundary:l,rootBoundary:c,padding:d,altBoundary:h}),_=qt(e.placement),b=he(e.placement),v=!b,y=oe(_),w="x"===y?"y":"x",A=e.modifiersData.popperOffsets,E=e.rects.reference,T=e.rects.popper,C="function"==typeof m?m(Object.assign({},e.rects,{placement:e.placement})):m,O="number"==typeof C?{mainAxis:C,altAxis:C}:Object.assign({mainAxis:0,altAxis:0},C),x=e.modifiersData.offset?e.modifiersData.offset[e.placement]:null,k={x:0,y:0};if(A){if(o){var L,S="y"===y?pt:_t,D="y"===y?mt:gt,I="y"===y?"height":"width",N=A[y],P=N+g[S],M=N-g[D],j=f?-T[I]/2:0,F=b===yt?E[I]:T[I],H=b===yt?-T[I]:-E[I],$=e.elements.arrow,W=f&&$?Gt($):{width:0,height:0},B=e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},z=B[S],R=B[D],q=re(0,E[I],W[I]),V=v?E[I]/2-j-q-z-O.mainAxis:F-q-z-O.mainAxis,K=v?-E[I]/2+j+q+R+O.mainAxis:H+q+R+O.mainAxis,Q=e.elements.arrow&&se(e.elements.arrow),X=Q?"y"===y?Q.clientTop||0:Q.clientLeft||0:0,Y=null!=(L=null==x?void 0:x[y])?L:0,U=N+K-Y,G=re(f?Kt(P,N+V-Y-X):P,N,f?Vt(M,U):M);A[y]=G,k[y]=G-N}if(a){var J,Z="x"===y?pt:_t,tt="x"===y?mt:gt,et=A[w],it="y"===w?"height":"width",nt=et+g[Z],st=et-g[tt],ot=-1!==[pt,_t].indexOf(_),rt=null!=(J=null==x?void 0:x[w])?J:0,at=ot?nt:et-E[it]-T[it]-rt+O.altAxis,lt=ot?et+E[it]+T[it]-rt-O.altAxis:st,ct=f&&ot?function(t,e,i){var n=re(t,e,i);return n>i?i:n}(at,et,lt):re(f?at:nt,et,f?lt:st);A[w]=ct,k[w]=ct-et}e.modifiersData[n]=k}},requiresIfExists:["offset"]};function Fe(t,e,i){void 0===i&&(i=!1);var n,s,o=Bt(e),r=Bt(e)&&function(t){var e=t.getBoundingClientRect(),i=Qt(e.width)/t.offsetWidth||1,n=Qt(e.height)/t.offsetHeight||1;return 1!==i||1!==n}(e),a=ee(e),l=Ut(t,r,i),c={scrollLeft:0,scrollTop:0},h={x:0,y:0};return(o||!o&&!i)&&(("body"!==Ht(e)||Ae(a))&&(c=(n=e)!==$t(n)&&Bt(n)?{scrollLeft:(s=n).scrollLeft,scrollTop:s.scrollTop}:ye(n)),Bt(e)?((h=Ut(e,!0)).x+=e.clientLeft,h.y+=e.clientTop):a&&(h.x=we(a))),{x:l.left+c.scrollLeft-h.x,y:l.top+c.scrollTop-h.y,width:l.width,height:l.height}}function He(t){var e=new Map,i=new Set,n=[];function s(t){i.add(t.name),[].concat(t.requires||[],t.requiresIfExists||[]).forEach((function(t){if(!i.has(t)){var n=e.get(t);n&&s(n)}})),n.push(t)}return t.forEach((function(t){e.set(t.name,t)})),t.forEach((function(t){i.has(t.name)||s(t)})),n}var $e={placement:"bottom",modifiers:[],strategy:"absolute"};function We(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return!e.some((function(t){return!(t&&"function"==typeof t.getBoundingClientRect)}))}function Be(t){void 0===t&&(t={});var e=t,i=e.defaultModifiers,n=void 0===i?[]:i,s=e.defaultOptions,o=void 0===s?$e:s;return function(t,e,i){void 0===i&&(i=o);var s,r,a={placement:"bottom",orderedModifiers:[],options:Object.assign({},$e,o),modifiersData:{},elements:{reference:t,popper:e},attributes:{},styles:{}},l=[],c=!1,h={state:a,setOptions:function(i){var s="function"==typeof i?i(a.options):i;d(),a.options=Object.assign({},o,a.options,s),a.scrollParents={reference:Wt(t)?Te(t):t.contextElement?Te(t.contextElement):[],popper:Te(e)};var r,c,u=function(t){var e=He(t);return Ft.reduce((function(t,i){return t.concat(e.filter((function(t){return t.phase===i})))}),[])}((r=[].concat(n,a.options.modifiers),c=r.reduce((function(t,e){var i=t[e.name];return t[e.name]=i?Object.assign({},i,e,{options:Object.assign({},i.options,e.options),data:Object.assign({},i.data,e.data)}):e,t}),{}),Object.keys(c).map((function(t){return c[t]}))));return a.orderedModifiers=u.filter((function(t){return t.enabled})),a.orderedModifiers.forEach((function(t){var e=t.name,i=t.options,n=void 0===i?{}:i,s=t.effect;if("function"==typeof s){var o=s({state:a,name:e,instance:h,options:n});l.push(o||function(){})}})),h.update()},forceUpdate:function(){if(!c){var t=a.elements,e=t.reference,i=t.popper;if(We(e,i)){a.rects={reference:Fe(e,se(i),"fixed"===a.options.strategy),popper:Gt(i)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(t){return a.modifiersData[t.name]=Object.assign({},t.data)}));for(var n=0;n<a.orderedModifiers.length;n++)if(!0!==a.reset){var s=a.orderedModifiers[n],o=s.fn,r=s.options,l=void 0===r?{}:r,d=s.name;"function"==typeof o&&(a=o({state:a,options:l,name:d,instance:h})||a)}else a.reset=!1,n=-1}}},update:(s=function(){return new Promise((function(t){h.forceUpdate(),t(a)}))},function(){return r||(r=new Promise((function(t){Promise.resolve().then((function(){r=void 0,t(s())}))}))),r}),destroy:function(){d(),c=!0}};if(!We(t,e))return h;function d(){l.forEach((function(t){return t()})),l=[]}return h.setOptions(i).then((function(t){!c&&i.onFirstUpdate&&i.onFirstUpdate(t)})),h}}var ze=Be(),Re=Be({defaultModifiers:[me,Me,fe,Rt]}),qe=Be({defaultModifiers:[me,Me,fe,Rt,Pe,Se,je,ce,Ne]});const Ve=Object.freeze(Object.defineProperty({__proto__:null,afterMain:Nt,afterRead:St,afterWrite:jt,applyStyles:Rt,arrow:ce,auto:bt,basePlacements:vt,beforeMain:Dt,beforeRead:kt,beforeWrite:Pt,bottom:mt,clippingParents:At,computeStyles:fe,createPopper:qe,createPopperBase:ze,createPopperLite:Re,detectOverflow:ke,end:wt,eventListeners:me,flip:Se,hide:Ne,left:_t,main:It,modifierPhases:Ft,offset:Pe,placements:xt,popper:Tt,popperGenerator:Be,popperOffsets:Me,preventOverflow:je,read:Lt,reference:Ct,right:gt,start:yt,top:pt,variationPlacements:Ot,viewport:Et,write:Mt},Symbol.toStringTag,{value:"Module"})),Ke="dropdown",Qe="ArrowUp",Xe="ArrowDown",Ye="click.bs.dropdown.data-api",Ue="keydown.bs.dropdown.data-api",Ge="show",Je='[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',Ze=`${Je}.show`,ti=".dropdown-menu",ei=p()?"top-end":"top-start",ii=p()?"top-start":"top-end",ni=p()?"bottom-end":"bottom-start",si=p()?"bottom-start":"bottom-end",oi=p()?"left-start":"right-start",ri=p()?"right-start":"left-start",ai={autoClose:!0,boundary:"clippingParents",display:"dynamic",offset:[0,2],popperConfig:null,reference:"toggle"},li={autoClose:"(boolean|string)",boundary:"(string|element)",display:"string",offset:"(array|string|function)",popperConfig:"(null|object|function)",reference:"(string|element|object)"};class ci extends W{constructor(t,e){super(t,e),this._popper=null,this._parent=this._element.parentNode,this._menu=z.next(this._element,ti)[0]||z.prev(this._element,ti)[0]||z.findOne(ti,this._parent),this._inNavbar=this._detectNavbar()}static get Default(){return ai}static get DefaultType(){return li}static get NAME(){return Ke}toggle(){return this._isShown()?this.hide():this.show()}show(){if(l(this._element)||this._isShown())return;const t={relatedTarget:this._element};if(!P.trigger(this._element,"show.bs.dropdown",t).defaultPrevented){if(this._createPopper(),"ontouchstart"in document.documentElement&&!this._parent.closest(".navbar-nav"))for(const t of[].concat(...document.body.children))P.on(t,"mouseover",h);this._element.focus(),this._element.setAttribute("aria-expanded",!0),this._menu.classList.add(Ge),this._element.classList.add(Ge),P.trigger(this._element,"shown.bs.dropdown",t)}}hide(){if(l(this._element)||!this._isShown())return;const t={relatedTarget:this._element};this._completeHide(t)}dispose(){this._popper&&this._popper.destroy(),super.dispose()}update(){this._inNavbar=this._detectNavbar(),this._popper&&this._popper.update()}_completeHide(t){if(!P.trigger(this._element,"hide.bs.dropdown",t).defaultPrevented){if("ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.off(t,"mouseover",h);this._popper&&this._popper.destroy(),this._menu.classList.remove(Ge),this._element.classList.remove(Ge),this._element.setAttribute("aria-expanded","false"),H.removeDataAttribute(this._menu,"popper"),P.trigger(this._element,"hidden.bs.dropdown",t)}}_getConfig(t){if("object"==typeof(t=super._getConfig(t)).reference&&!o(t.reference)&&"function"!=typeof t.reference.getBoundingClientRect)throw new TypeError(`${Ke.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);return t}_createPopper(){if(void 0===Ve)throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");let t=this._element;"parent"===this._config.reference?t=this._parent:o(this._config.reference)?t=r(this._config.reference):"object"==typeof this._config.reference&&(t=this._config.reference);const e=this._getPopperConfig();this._popper=qe(t,this._menu,e)}_isShown(){return this._menu.classList.contains(Ge)}_getPlacement(){const t=this._parent;if(t.classList.contains("dropend"))return oi;if(t.classList.contains("dropstart"))return ri;if(t.classList.contains("dropup-center"))return"top";if(t.classList.contains("dropdown-center"))return"bottom";const e="end"===getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();return t.classList.contains("dropup")?e?ii:ei:e?si:ni}_detectNavbar(){return null!==this._element.closest(".navbar")}_getOffset(){const{offset:t}=this._config;return"string"==typeof t?t.split(",").map((t=>Number.parseInt(t,10))):"function"==typeof t?e=>t(e,this._element):t}_getPopperConfig(){const t={placement:this._getPlacement(),modifiers:[{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"offset",options:{offset:this._getOffset()}}]};return(this._inNavbar||"static"===this._config.display)&&(H.setDataAttribute(this._menu,"popper","static"),t.modifiers=[{name:"applyStyles",enabled:!1}]),{...t,...g(this._config.popperConfig,[t])}}_selectMenuItem({key:t,target:e}){const i=z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",this._menu).filter((t=>a(t)));i.length&&b(i,e,t===Xe,!i.includes(e)).focus()}static jQueryInterface(t){return this.each((function(){const e=ci.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}static clearMenus(t){if(2===t.button||"keyup"===t.type&&"Tab"!==t.key)return;const e=z.find(Ze);for(const i of e){const e=ci.getInstance(i);if(!e||!1===e._config.autoClose)continue;const n=t.composedPath(),s=n.includes(e._menu);if(n.includes(e._element)||"inside"===e._config.autoClose&&!s||"outside"===e._config.autoClose&&s)continue;if(e._menu.contains(t.target)&&("keyup"===t.type&&"Tab"===t.key||/input|select|option|textarea|form/i.test(t.target.tagName)))continue;const o={relatedTarget:e._element};"click"===t.type&&(o.clickEvent=t),e._completeHide(o)}}static dataApiKeydownHandler(t){const e=/input|textarea/i.test(t.target.tagName),i="Escape"===t.key,n=[Qe,Xe].includes(t.key);if(!n&&!i)return;if(e&&!i)return;t.preventDefault();const s=this.matches(Je)?this:z.prev(this,Je)[0]||z.next(this,Je)[0]||z.findOne(Je,t.delegateTarget.parentNode),o=ci.getOrCreateInstance(s);if(n)return t.stopPropagation(),o.show(),void o._selectMenuItem(t);o._isShown()&&(t.stopPropagation(),o.hide(),s.focus())}}P.on(document,Ue,Je,ci.dataApiKeydownHandler),P.on(document,Ue,ti,ci.dataApiKeydownHandler),P.on(document,Ye,ci.clearMenus),P.on(document,"keyup.bs.dropdown.data-api",ci.clearMenus),P.on(document,Ye,Je,(function(t){t.preventDefault(),ci.getOrCreateInstance(this).toggle()})),m(ci);const hi="show",di="mousedown.bs.backdrop",ui={className:"modal-backdrop",clickCallback:null,isAnimated:!1,isVisible:!0,rootElement:"body"},fi={className:"string",clickCallback:"(function|null)",isAnimated:"boolean",isVisible:"boolean",rootElement:"(element|string)"};class pi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isAppended=!1,this._element=null}static get Default(){return ui}static get DefaultType(){return fi}static get NAME(){return"backdrop"}show(t){if(!this._config.isVisible)return void g(t);this._append();const e=this._getElement();this._config.isAnimated&&d(e),e.classList.add(hi),this._emulateAnimation((()=>{g(t)}))}hide(t){this._config.isVisible?(this._getElement().classList.remove(hi),this._emulateAnimation((()=>{this.dispose(),g(t)}))):g(t)}dispose(){this._isAppended&&(P.off(this._element,di),this._element.remove(),this._isAppended=!1)}_getElement(){if(!this._element){const t=document.createElement("div");t.className=this._config.className,this._config.isAnimated&&t.classList.add("fade"),this._element=t}return this._element}_configAfterMerge(t){return t.rootElement=r(t.rootElement),t}_append(){if(this._isAppended)return;const t=this._getElement();this._config.rootElement.append(t),P.on(t,di,(()=>{g(this._config.clickCallback)})),this._isAppended=!0}_emulateAnimation(t){_(t,this._getElement(),this._config.isAnimated)}}const mi=".bs.focustrap",gi="backward",_i={autofocus:!0,trapElement:null},bi={autofocus:"boolean",trapElement:"element"};class vi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isActive=!1,this._lastTabNavDirection=null}static get Default(){return _i}static get DefaultType(){return bi}static get NAME(){return"focustrap"}activate(){this._isActive||(this._config.autofocus&&this._config.trapElement.focus(),P.off(document,mi),P.on(document,"focusin.bs.focustrap",(t=>this._handleFocusin(t))),P.on(document,"keydown.tab.bs.focustrap",(t=>this._handleKeydown(t))),this._isActive=!0)}deactivate(){this._isActive&&(this._isActive=!1,P.off(document,mi))}_handleFocusin(t){const{trapElement:e}=this._config;if(t.target===document||t.target===e||e.contains(t.target))return;const i=z.focusableChildren(e);0===i.length?e.focus():this._lastTabNavDirection===gi?i[i.length-1].focus():i[0].focus()}_handleKeydown(t){"Tab"===t.key&&(this._lastTabNavDirection=t.shiftKey?gi:"forward")}}const yi=".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",wi=".sticky-top",Ai="padding-right",Ei="margin-right";class Ti{constructor(){this._element=document.body}getWidth(){const t=document.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}hide(){const t=this.getWidth();this._disableOverFlow(),this._setElementAttributes(this._element,Ai,(e=>e+t)),this._setElementAttributes(yi,Ai,(e=>e+t)),this._setElementAttributes(wi,Ei,(e=>e-t))}reset(){this._resetElementAttributes(this._element,"overflow"),this._resetElementAttributes(this._element,Ai),this._resetElementAttributes(yi,Ai),this._resetElementAttributes(wi,Ei)}isOverflowing(){return this.getWidth()>0}_disableOverFlow(){this._saveInitialAttribute(this._element,"overflow"),this._element.style.overflow="hidden"}_setElementAttributes(t,e,i){const n=this.getWidth();this._applyManipulationCallback(t,(t=>{if(t!==this._element&&window.innerWidth>t.clientWidth+n)return;this._saveInitialAttribute(t,e);const s=window.getComputedStyle(t).getPropertyValue(e);t.style.setProperty(e,`${i(Number.parseFloat(s))}px`)}))}_saveInitialAttribute(t,e){const i=t.style.getPropertyValue(e);i&&H.setDataAttribute(t,e,i)}_resetElementAttributes(t,e){this._applyManipulationCallback(t,(t=>{const i=H.getDataAttribute(t,e);null!==i?(H.removeDataAttribute(t,e),t.style.setProperty(e,i)):t.style.removeProperty(e)}))}_applyManipulationCallback(t,e){if(o(t))e(t);else for(const i of z.find(t,this._element))e(i)}}const Ci=".bs.modal",Oi="hidden.bs.modal",xi="show.bs.modal",ki="modal-open",Li="show",Si="modal-static",Di={backdrop:!0,focus:!0,keyboard:!0},Ii={backdrop:"(boolean|string)",focus:"boolean",keyboard:"boolean"};class Ni extends W{constructor(t,e){super(t,e),this._dialog=z.findOne(".modal-dialog",this._element),this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._isShown=!1,this._isTransitioning=!1,this._scrollBar=new Ti,this._addEventListeners()}static get Default(){return Di}static get DefaultType(){return Ii}static get NAME(){return"modal"}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){this._isShown||this._isTransitioning||P.trigger(this._element,xi,{relatedTarget:t}).defaultPrevented||(this._isShown=!0,this._isTransitioning=!0,this._scrollBar.hide(),document.body.classList.add(ki),this._adjustDialog(),this._backdrop.show((()=>this._showElement(t))))}hide(){this._isShown&&!this._isTransitioning&&(P.trigger(this._element,"hide.bs.modal").defaultPrevented||(this._isShown=!1,this._isTransitioning=!0,this._focustrap.deactivate(),this._element.classList.remove(Li),this._queueCallback((()=>this._hideModal()),this._element,this._isAnimated())))}dispose(){P.off(window,Ci),P.off(this._dialog,Ci),this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}handleUpdate(){this._adjustDialog()}_initializeBackDrop(){return new pi({isVisible:Boolean(this._config.backdrop),isAnimated:this._isAnimated()})}_initializeFocusTrap(){return new vi({trapElement:this._element})}_showElement(t){document.body.contains(this._element)||document.body.append(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.scrollTop=0;const e=z.findOne(".modal-body",this._dialog);e&&(e.scrollTop=0),d(this._element),this._element.classList.add(Li),this._queueCallback((()=>{this._config.focus&&this._focustrap.activate(),this._isTransitioning=!1,P.trigger(this._element,"shown.bs.modal",{relatedTarget:t})}),this._dialog,this._isAnimated())}_addEventListeners(){P.on(this._element,"keydown.dismiss.bs.modal",(t=>{"Escape"===t.key&&(this._config.keyboard?this.hide():this._triggerBackdropTransition())})),P.on(window,"resize.bs.modal",(()=>{this._isShown&&!this._isTransitioning&&this._adjustDialog()})),P.on(this._element,"mousedown.dismiss.bs.modal",(t=>{P.one(this._element,"click.dismiss.bs.modal",(e=>{this._element===t.target&&this._element===e.target&&("static"!==this._config.backdrop?this._config.backdrop&&this.hide():this._triggerBackdropTransition())}))}))}_hideModal(){this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._isTransitioning=!1,this._backdrop.hide((()=>{document.body.classList.remove(ki),this._resetAdjustments(),this._scrollBar.reset(),P.trigger(this._element,Oi)}))}_isAnimated(){return this._element.classList.contains("fade")}_triggerBackdropTransition(){if(P.trigger(this._element,"hidePrevented.bs.modal").defaultPrevented)return;const t=this._element.scrollHeight>document.documentElement.clientHeight,e=this._element.style.overflowY;"hidden"===e||this._element.classList.contains(Si)||(t||(this._element.style.overflowY="hidden"),this._element.classList.add(Si),this._queueCallback((()=>{this._element.classList.remove(Si),this._queueCallback((()=>{this._element.style.overflowY=e}),this._dialog)}),this._dialog),this._element.focus())}_adjustDialog(){const t=this._element.scrollHeight>document.documentElement.clientHeight,e=this._scrollBar.getWidth(),i=e>0;if(i&&!t){const t=p()?"paddingLeft":"paddingRight";this._element.style[t]=`${e}px`}if(!i&&t){const t=p()?"paddingRight":"paddingLeft";this._element.style[t]=`${e}px`}}_resetAdjustments(){this._element.style.paddingLeft="",this._element.style.paddingRight=""}static jQueryInterface(t,e){return this.each((function(){const i=Ni.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===i[t])throw new TypeError(`No method named "${t}"`);i[t](e)}}))}}P.on(document,"click.bs.modal.data-api",'[data-bs-toggle="modal"]',(function(t){const e=z.getElementFromSelector(this);["A","AREA"].includes(this.tagName)&&t.preventDefault(),P.one(e,xi,(t=>{t.defaultPrevented||P.one(e,Oi,(()=>{a(this)&&this.focus()}))}));const i=z.findOne(".modal.show");i&&Ni.getInstance(i).hide(),Ni.getOrCreateInstance(e).toggle(this)})),R(Ni),m(Ni);const Pi="show",Mi="showing",ji="hiding",Fi=".offcanvas.show",Hi="hidePrevented.bs.offcanvas",$i="hidden.bs.offcanvas",Wi={backdrop:!0,keyboard:!0,scroll:!1},Bi={backdrop:"(boolean|string)",keyboard:"boolean",scroll:"boolean"};class zi extends W{constructor(t,e){super(t,e),this._isShown=!1,this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._addEventListeners()}static get Default(){return Wi}static get DefaultType(){return Bi}static get NAME(){return"offcanvas"}toggle(t){return this._isShown?this.hide():this.show(t)}show(t){this._isShown||P.trigger(this._element,"show.bs.offcanvas",{relatedTarget:t}).defaultPrevented||(this._isShown=!0,this._backdrop.show(),this._config.scroll||(new Ti).hide(),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.classList.add(Mi),this._queueCallback((()=>{this._config.scroll&&!this._config.backdrop||this._focustrap.activate(),this._element.classList.add(Pi),this._element.classList.remove(Mi),P.trigger(this._element,"shown.bs.offcanvas",{relatedTarget:t})}),this._element,!0))}hide(){this._isShown&&(P.trigger(this._element,"hide.bs.offcanvas").defaultPrevented||(this._focustrap.deactivate(),this._element.blur(),this._isShown=!1,this._element.classList.add(ji),this._backdrop.hide(),this._queueCallback((()=>{this._element.classList.remove(Pi,ji),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._config.scroll||(new Ti).reset(),P.trigger(this._element,$i)}),this._element,!0)))}dispose(){this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}_initializeBackDrop(){const t=Boolean(this._config.backdrop);return new pi({className:"offcanvas-backdrop",isVisible:t,isAnimated:!0,rootElement:this._element.parentNode,clickCallback:t?()=>{"static"!==this._config.backdrop?this.hide():P.trigger(this._element,Hi)}:null})}_initializeFocusTrap(){return new vi({trapElement:this._element})}_addEventListeners(){P.on(this._element,"keydown.dismiss.bs.offcanvas",(t=>{"Escape"===t.key&&(this._config.keyboard?this.hide():P.trigger(this._element,Hi))}))}static jQueryInterface(t){return this.each((function(){const e=zi.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}P.on(document,"click.bs.offcanvas.data-api",'[data-bs-toggle="offcanvas"]',(function(t){const e=z.getElementFromSelector(this);if(["A","AREA"].includes(this.tagName)&&t.preventDefault(),l(this))return;P.one(e,$i,(()=>{a(this)&&this.focus()}));const i=z.findOne(Fi);i&&i!==e&&zi.getInstance(i).hide(),zi.getOrCreateInstance(e).toggle(this)})),P.on(window,"load.bs.offcanvas.data-api",(()=>{for(const t of z.find(Fi))zi.getOrCreateInstance(t).show()})),P.on(window,"resize.bs.offcanvas",(()=>{for(const t of z.find("[aria-modal][class*=show][class*=offcanvas-]"))"fixed"!==getComputedStyle(t).position&&zi.getOrCreateInstance(t).hide()})),R(zi),m(zi);const Ri={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","srcset","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},qi=new Set(["background","cite","href","itemtype","longdesc","poster","src","xlink:href"]),Vi=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,Ki=(t,e)=>{const i=t.nodeName.toLowerCase();return e.includes(i)?!qi.has(i)||Boolean(Vi.test(t.nodeValue)):e.filter((t=>t instanceof RegExp)).some((t=>t.test(i)))},Qi={allowList:Ri,content:{},extraClass:"",html:!1,sanitize:!0,sanitizeFn:null,template:"<div></div>"},Xi={allowList:"object",content:"object",extraClass:"(string|function)",html:"boolean",sanitize:"boolean",sanitizeFn:"(null|function)",template:"string"},Yi={entry:"(string|element|function|null)",selector:"(string|element)"};class Ui extends ${constructor(t){super(),this._config=this._getConfig(t)}static get Default(){return Qi}static get DefaultType(){return Xi}static get NAME(){return"TemplateFactory"}getContent(){return Object.values(this._config.content).map((t=>this._resolvePossibleFunction(t))).filter(Boolean)}hasContent(){return this.getContent().length>0}changeContent(t){return this._checkContent(t),this._config.content={...this._config.content,...t},this}toHtml(){const t=document.createElement("div");t.innerHTML=this._maybeSanitize(this._config.template);for(const[e,i]of Object.entries(this._config.content))this._setContent(t,i,e);const e=t.children[0],i=this._resolvePossibleFunction(this._config.extraClass);return i&&e.classList.add(...i.split(" ")),e}_typeCheckConfig(t){super._typeCheckConfig(t),this._checkContent(t.content)}_checkContent(t){for(const[e,i]of Object.entries(t))super._typeCheckConfig({selector:e,entry:i},Yi)}_setContent(t,e,i){const n=z.findOne(i,t);n&&((e=this._resolvePossibleFunction(e))?o(e)?this._putElementInTemplate(r(e),n):this._config.html?n.innerHTML=this._maybeSanitize(e):n.textContent=e:n.remove())}_maybeSanitize(t){return this._config.sanitize?function(t,e,i){if(!t.length)return t;if(i&&"function"==typeof i)return i(t);const n=(new window.DOMParser).parseFromString(t,"text/html"),s=[].concat(...n.body.querySelectorAll("*"));for(const t of s){const i=t.nodeName.toLowerCase();if(!Object.keys(e).includes(i)){t.remove();continue}const n=[].concat(...t.attributes),s=[].concat(e["*"]||[],e[i]||[]);for(const e of n)Ki(e,s)||t.removeAttribute(e.nodeName)}return n.body.innerHTML}(t,this._config.allowList,this._config.sanitizeFn):t}_resolvePossibleFunction(t){return g(t,[this])}_putElementInTemplate(t,e){if(this._config.html)return e.innerHTML="",void e.append(t);e.textContent=t.textContent}}const Gi=new Set(["sanitize","allowList","sanitizeFn"]),Ji="fade",Zi="show",tn=".modal",en="hide.bs.modal",nn="hover",sn="focus",on={AUTO:"auto",TOP:"top",RIGHT:p()?"left":"right",BOTTOM:"bottom",LEFT:p()?"right":"left"},rn={allowList:Ri,animation:!0,boundary:"clippingParents",container:!1,customClass:"",delay:0,fallbackPlacements:["top","right","bottom","left"],html:!1,offset:[0,6],placement:"top",popperConfig:null,sanitize:!0,sanitizeFn:null,selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',title:"",trigger:"hover focus"},an={allowList:"object",animation:"boolean",boundary:"(string|element)",container:"(string|element|boolean)",customClass:"(string|function)",delay:"(number|object)",fallbackPlacements:"array",html:"boolean",offset:"(array|string|function)",placement:"(string|function)",popperConfig:"(null|object|function)",sanitize:"boolean",sanitizeFn:"(null|function)",selector:"(string|boolean)",template:"string",title:"(string|element|function)",trigger:"string"};class ln extends W{constructor(t,e){if(void 0===Ve)throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");super(t,e),this._isEnabled=!0,this._timeout=0,this._isHovered=null,this._activeTrigger={},this._popper=null,this._templateFactory=null,this._newContent=null,this.tip=null,this._setListeners(),this._config.selector||this._fixTitle()}static get Default(){return rn}static get DefaultType(){return an}static get NAME(){return"tooltip"}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}toggleEnabled(){this._isEnabled=!this._isEnabled}toggle(){this._isEnabled&&(this._activeTrigger.click=!this._activeTrigger.click,this._isShown()?this._leave():this._enter())}dispose(){clearTimeout(this._timeout),P.off(this._element.closest(tn),en,this._hideModalHandler),this._element.getAttribute("data-bs-original-title")&&this._element.setAttribute("title",this._element.getAttribute("data-bs-original-title")),this._disposePopper(),super.dispose()}show(){if("none"===this._element.style.display)throw new Error("Please use show on visible elements");if(!this._isWithContent()||!this._isEnabled)return;const t=P.trigger(this._element,this.constructor.eventName("show")),e=(c(this._element)||this._element.ownerDocument.documentElement).contains(this._element);if(t.defaultPrevented||!e)return;this._disposePopper();const i=this._getTipElement();this._element.setAttribute("aria-describedby",i.getAttribute("id"));const{container:n}=this._config;if(this._element.ownerDocument.documentElement.contains(this.tip)||(n.append(i),P.trigger(this._element,this.constructor.eventName("inserted"))),this._popper=this._createPopper(i),i.classList.add(Zi),"ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.on(t,"mouseover",h);this._queueCallback((()=>{P.trigger(this._element,this.constructor.eventName("shown")),!1===this._isHovered&&this._leave(),this._isHovered=!1}),this.tip,this._isAnimated())}hide(){if(this._isShown()&&!P.trigger(this._element,this.constructor.eventName("hide")).defaultPrevented){if(this._getTipElement().classList.remove(Zi),"ontouchstart"in document.documentElement)for(const t of[].concat(...document.body.children))P.off(t,"mouseover",h);this._activeTrigger.click=!1,this._activeTrigger.focus=!1,this._activeTrigger.hover=!1,this._isHovered=null,this._queueCallback((()=>{this._isWithActiveTrigger()||(this._isHovered||this._disposePopper(),this._element.removeAttribute("aria-describedby"),P.trigger(this._element,this.constructor.eventName("hidden")))}),this.tip,this._isAnimated())}}update(){this._popper&&this._popper.update()}_isWithContent(){return Boolean(this._getTitle())}_getTipElement(){return this.tip||(this.tip=this._createTipElement(this._newContent||this._getContentForTemplate())),this.tip}_createTipElement(t){const e=this._getTemplateFactory(t).toHtml();if(!e)return null;e.classList.remove(Ji,Zi),e.classList.add(`bs-${this.constructor.NAME}-auto`);const i=(t=>{do{t+=Math.floor(1e6*Math.random())}while(document.getElementById(t));return t})(this.constructor.NAME).toString();return e.setAttribute("id",i),this._isAnimated()&&e.classList.add(Ji),e}setContent(t){this._newContent=t,this._isShown()&&(this._disposePopper(),this.show())}_getTemplateFactory(t){return this._templateFactory?this._templateFactory.changeContent(t):this._templateFactory=new Ui({...this._config,content:t,extraClass:this._resolvePossibleFunction(this._config.customClass)}),this._templateFactory}_getContentForTemplate(){return{".tooltip-inner":this._getTitle()}}_getTitle(){return this._resolvePossibleFunction(this._config.title)||this._element.getAttribute("data-bs-original-title")}_initializeOnDelegatedTarget(t){return this.constructor.getOrCreateInstance(t.delegateTarget,this._getDelegateConfig())}_isAnimated(){return this._config.animation||this.tip&&this.tip.classList.contains(Ji)}_isShown(){return this.tip&&this.tip.classList.contains(Zi)}_createPopper(t){const e=g(this._config.placement,[this,t,this._element]),i=on[e.toUpperCase()];return qe(this._element,t,this._getPopperConfig(i))}_getOffset(){const{offset:t}=this._config;return"string"==typeof t?t.split(",").map((t=>Number.parseInt(t,10))):"function"==typeof t?e=>t(e,this._element):t}_resolvePossibleFunction(t){return g(t,[this._element])}_getPopperConfig(t){const e={placement:t,modifiers:[{name:"flip",options:{fallbackPlacements:this._config.fallbackPlacements}},{name:"offset",options:{offset:this._getOffset()}},{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"arrow",options:{element:`.${this.constructor.NAME}-arrow`}},{name:"preSetPlacement",enabled:!0,phase:"beforeMain",fn:t=>{this._getTipElement().setAttribute("data-popper-placement",t.state.placement)}}]};return{...e,...g(this._config.popperConfig,[e])}}_setListeners(){const t=this._config.trigger.split(" ");for(const e of t)if("click"===e)P.on(this._element,this.constructor.eventName("click"),this._config.selector,(t=>{this._initializeOnDelegatedTarget(t).toggle()}));else if("manual"!==e){const t=e===nn?this.constructor.eventName("mouseenter"):this.constructor.eventName("focusin"),i=e===nn?this.constructor.eventName("mouseleave"):this.constructor.eventName("focusout");P.on(this._element,t,this._config.selector,(t=>{const e=this._initializeOnDelegatedTarget(t);e._activeTrigger["focusin"===t.type?sn:nn]=!0,e._enter()})),P.on(this._element,i,this._config.selector,(t=>{const e=this._initializeOnDelegatedTarget(t);e._activeTrigger["focusout"===t.type?sn:nn]=e._element.contains(t.relatedTarget),e._leave()}))}this._hideModalHandler=()=>{this._element&&this.hide()},P.on(this._element.closest(tn),en,this._hideModalHandler)}_fixTitle(){const t=this._element.getAttribute("title");t&&(this._element.getAttribute("aria-label")||this._element.textContent.trim()||this._element.setAttribute("aria-label",t),this._element.setAttribute("data-bs-original-title",t),this._element.removeAttribute("title"))}_enter(){this._isShown()||this._isHovered?this._isHovered=!0:(this._isHovered=!0,this._setTimeout((()=>{this._isHovered&&this.show()}),this._config.delay.show))}_leave(){this._isWithActiveTrigger()||(this._isHovered=!1,this._setTimeout((()=>{this._isHovered||this.hide()}),this._config.delay.hide))}_setTimeout(t,e){clearTimeout(this._timeout),this._timeout=setTimeout(t,e)}_isWithActiveTrigger(){return Object.values(this._activeTrigger).includes(!0)}_getConfig(t){const e=H.getDataAttributes(this._element);for(const t of Object.keys(e))Gi.has(t)&&delete e[t];return t={...e,..."object"==typeof t&&t?t:{}},t=this._mergeConfigObj(t),t=this._configAfterMerge(t),this._typeCheckConfig(t),t}_configAfterMerge(t){return t.container=!1===t.container?document.body:r(t.container),"number"==typeof t.delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),t}_getDelegateConfig(){const t={};for(const[e,i]of Object.entries(this._config))this.constructor.Default[e]!==i&&(t[e]=i);return t.selector=!1,t.trigger="manual",t}_disposePopper(){this._popper&&(this._popper.destroy(),this._popper=null),this.tip&&(this.tip.remove(),this.tip=null)}static jQueryInterface(t){return this.each((function(){const e=ln.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}}m(ln);const cn={...ln.Default,content:"",offset:[0,8],placement:"right",template:'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',trigger:"click"},hn={...ln.DefaultType,content:"(null|string|element|function)"};class dn extends ln{static get Default(){return cn}static get DefaultType(){return hn}static get NAME(){return"popover"}_isWithContent(){return this._getTitle()||this._getContent()}_getContentForTemplate(){return{".popover-header":this._getTitle(),".popover-body":this._getContent()}}_getContent(){return this._resolvePossibleFunction(this._config.content)}static jQueryInterface(t){return this.each((function(){const e=dn.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t]()}}))}}m(dn);const un="click.bs.scrollspy",fn="active",pn="[href]",mn={offset:null,rootMargin:"0px 0px -25%",smoothScroll:!1,target:null,threshold:[.1,.5,1]},gn={offset:"(number|null)",rootMargin:"string",smoothScroll:"boolean",target:"element",threshold:"array"};class _n extends W{constructor(t,e){super(t,e),this._targetLinks=new Map,this._observableSections=new Map,this._rootElement="visible"===getComputedStyle(this._element).overflowY?null:this._element,this._activeTarget=null,this._observer=null,this._previousScrollData={visibleEntryTop:0,parentScrollTop:0},this.refresh()}static get Default(){return mn}static get DefaultType(){return gn}static get NAME(){return"scrollspy"}refresh(){this._initializeTargetsAndObservables(),this._maybeEnableSmoothScroll(),this._observer?this._observer.disconnect():this._observer=this._getNewObserver();for(const t of this._observableSections.values())this._observer.observe(t)}dispose(){this._observer.disconnect(),super.dispose()}_configAfterMerge(t){return t.target=r(t.target)||document.body,t.rootMargin=t.offset?`${t.offset}px 0px -30%`:t.rootMargin,"string"==typeof t.threshold&&(t.threshold=t.threshold.split(",").map((t=>Number.parseFloat(t)))),t}_maybeEnableSmoothScroll(){this._config.smoothScroll&&(P.off(this._config.target,un),P.on(this._config.target,un,pn,(t=>{const e=this._observableSections.get(t.target.hash);if(e){t.preventDefault();const i=this._rootElement||window,n=e.offsetTop-this._element.offsetTop;if(i.scrollTo)return void i.scrollTo({top:n,behavior:"smooth"});i.scrollTop=n}})))}_getNewObserver(){const t={root:this._rootElement,threshold:this._config.threshold,rootMargin:this._config.rootMargin};return new IntersectionObserver((t=>this._observerCallback(t)),t)}_observerCallback(t){const e=t=>this._targetLinks.get(`#${t.target.id}`),i=t=>{this._previousScrollData.visibleEntryTop=t.target.offsetTop,this._process(e(t))},n=(this._rootElement||document.documentElement).scrollTop,s=n>=this._previousScrollData.parentScrollTop;this._previousScrollData.parentScrollTop=n;for(const o of t){if(!o.isIntersecting){this._activeTarget=null,this._clearActiveClass(e(o));continue}const t=o.target.offsetTop>=this._previousScrollData.visibleEntryTop;if(s&&t){if(i(o),!n)return}else s||t||i(o)}}_initializeTargetsAndObservables(){this._targetLinks=new Map,this._observableSections=new Map;const t=z.find(pn,this._config.target);for(const e of t){if(!e.hash||l(e))continue;const t=z.findOne(decodeURI(e.hash),this._element);a(t)&&(this._targetLinks.set(decodeURI(e.hash),e),this._observableSections.set(e.hash,t))}}_process(t){this._activeTarget!==t&&(this._clearActiveClass(this._config.target),this._activeTarget=t,t.classList.add(fn),this._activateParents(t),P.trigger(this._element,"activate.bs.scrollspy",{relatedTarget:t}))}_activateParents(t){if(t.classList.contains("dropdown-item"))z.findOne(".dropdown-toggle",t.closest(".dropdown")).classList.add(fn);else for(const e of z.parents(t,".nav, .list-group"))for(const t of z.prev(e,".nav-link, .nav-item > .nav-link, .list-group-item"))t.classList.add(fn)}_clearActiveClass(t){t.classList.remove(fn);const e=z.find("[href].active",t);for(const t of e)t.classList.remove(fn)}static jQueryInterface(t){return this.each((function(){const e=_n.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}))}}P.on(window,"load.bs.scrollspy.data-api",(()=>{for(const t of z.find('[data-bs-spy="scroll"]'))_n.getOrCreateInstance(t)})),m(_n);const bn="ArrowLeft",vn="ArrowRight",yn="ArrowUp",wn="ArrowDown",An="active",En="fade",Tn="show",Cn='[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',On=`.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Cn}`;class xn extends W{constructor(t){super(t),this._parent=this._element.closest('.list-group, .nav, [role="tablist"]'),this._parent&&(this._setInitialAttributes(this._parent,this._getChildren()),P.on(this._element,"keydown.bs.tab",(t=>this._keydown(t))))}static get NAME(){return"tab"}show(){const t=this._element;if(this._elemIsActive(t))return;const e=this._getActiveElem(),i=e?P.trigger(e,"hide.bs.tab",{relatedTarget:t}):null;P.trigger(t,"show.bs.tab",{relatedTarget:e}).defaultPrevented||i&&i.defaultPrevented||(this._deactivate(e,t),this._activate(t,e))}_activate(t,e){t&&(t.classList.add(An),this._activate(z.getElementFromSelector(t)),this._queueCallback((()=>{"tab"===t.getAttribute("role")?(t.removeAttribute("tabindex"),t.setAttribute("aria-selected",!0),this._toggleDropDown(t,!0),P.trigger(t,"shown.bs.tab",{relatedTarget:e})):t.classList.add(Tn)}),t,t.classList.contains(En)))}_deactivate(t,e){t&&(t.classList.remove(An),t.blur(),this._deactivate(z.getElementFromSelector(t)),this._queueCallback((()=>{"tab"===t.getAttribute("role")?(t.setAttribute("aria-selected",!1),t.setAttribute("tabindex","-1"),this._toggleDropDown(t,!1),P.trigger(t,"hidden.bs.tab",{relatedTarget:e})):t.classList.remove(Tn)}),t,t.classList.contains(En)))}_keydown(t){if(![bn,vn,yn,wn].includes(t.key))return;t.stopPropagation(),t.preventDefault();const e=[vn,wn].includes(t.key),i=b(this._getChildren().filter((t=>!l(t))),t.target,e,!0);i&&(i.focus({preventScroll:!0}),xn.getOrCreateInstance(i).show())}_getChildren(){return z.find(On,this._parent)}_getActiveElem(){return this._getChildren().find((t=>this._elemIsActive(t)))||null}_setInitialAttributes(t,e){this._setAttributeIfNotExists(t,"role","tablist");for(const t of e)this._setInitialAttributesOnChild(t)}_setInitialAttributesOnChild(t){t=this._getInnerElement(t);const e=this._elemIsActive(t),i=this._getOuterElement(t);t.setAttribute("aria-selected",e),i!==t&&this._setAttributeIfNotExists(i,"role","presentation"),e||t.setAttribute("tabindex","-1"),this._setAttributeIfNotExists(t,"role","tab"),this._setInitialAttributesOnTargetPanel(t)}_setInitialAttributesOnTargetPanel(t){const e=z.getElementFromSelector(t);e&&(this._setAttributeIfNotExists(e,"role","tabpanel"),t.id&&this._setAttributeIfNotExists(e,"aria-labelledby",`${t.id}`))}_toggleDropDown(t,e){const i=this._getOuterElement(t);if(!i.classList.contains("dropdown"))return;const n=(t,n)=>{const s=z.findOne(t,i);s&&s.classList.toggle(n,e)};n(".dropdown-toggle",An),n(".dropdown-menu",Tn),i.setAttribute("aria-expanded",e)}_setAttributeIfNotExists(t,e,i){t.hasAttribute(e)||t.setAttribute(e,i)}_elemIsActive(t){return t.classList.contains(An)}_getInnerElement(t){return t.matches(On)?t:z.findOne(On,t)}_getOuterElement(t){return t.closest(".nav-item, .list-group-item")||t}static jQueryInterface(t){return this.each((function(){const e=xn.getOrCreateInstance(this);if("string"==typeof t){if(void 0===e[t]||t.startsWith("_")||"constructor"===t)throw new TypeError(`No method named "${t}"`);e[t]()}}))}}P.on(document,"click.bs.tab",Cn,(function(t){["A","AREA"].includes(this.tagName)&&t.preventDefault(),l(this)||xn.getOrCreateInstance(this).show()})),P.on(window,"load.bs.tab",(()=>{for(const t of z.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'))xn.getOrCreateInstance(t)})),m(xn);const kn="hide",Ln="show",Sn="showing",Dn={animation:"boolean",autohide:"boolean",delay:"number"},In={animation:!0,autohide:!0,delay:5e3};class Nn extends W{constructor(t,e){super(t,e),this._timeout=null,this._hasMouseInteraction=!1,this._hasKeyboardInteraction=!1,this._setListeners()}static get Default(){return In}static get DefaultType(){return Dn}static get NAME(){return"toast"}show(){P.trigger(this._element,"show.bs.toast").defaultPrevented||(this._clearTimeout(),this._config.animation&&this._element.classList.add("fade"),this._element.classList.remove(kn),d(this._element),this._element.classList.add(Ln,Sn),this._queueCallback((()=>{this._element.classList.remove(Sn),P.trigger(this._element,"shown.bs.toast"),this._maybeScheduleHide()}),this._element,this._config.animation))}hide(){this.isShown()&&(P.trigger(this._element,"hide.bs.toast").defaultPrevented||(this._element.classList.add(Sn),this._queueCallback((()=>{this._element.classList.add(kn),this._element.classList.remove(Sn,Ln),P.trigger(this._element,"hidden.bs.toast")}),this._element,this._config.animation)))}dispose(){this._clearTimeout(),this.isShown()&&this._element.classList.remove(Ln),super.dispose()}isShown(){return this._element.classList.contains(Ln)}_maybeScheduleHide(){this._config.autohide&&(this._hasMouseInteraction||this._hasKeyboardInteraction||(this._timeout=setTimeout((()=>{this.hide()}),this._config.delay)))}_onInteraction(t,e){switch(t.type){case"mouseover":case"mouseout":this._hasMouseInteraction=e;break;case"focusin":case"focusout":this._hasKeyboardInteraction=e}if(e)return void this._clearTimeout();const i=t.relatedTarget;this._element===i||this._element.contains(i)||this._maybeScheduleHide()}_setListeners(){P.on(this._element,"mouseover.bs.toast",(t=>this._onInteraction(t,!0))),P.on(this._element,"mouseout.bs.toast",(t=>this._onInteraction(t,!1))),P.on(this._element,"focusin.bs.toast",(t=>this._onInteraction(t,!0))),P.on(this._element,"focusout.bs.toast",(t=>this._onInteraction(t,!1)))}_clearTimeout(){clearTimeout(this._timeout),this._timeout=null}static jQueryInterface(t){return this.each((function(){const e=Nn.getOrCreateInstance(this,t);if("string"==typeof t){if(void 0===e[t])throw new TypeError(`No method named "${t}"`);e[t](this)}}))}}return R(Nn),m(Nn),{Alert:q,Button:K,Carousel:rt,Collapse:ft,Dropdown:ci,Modal:Ni,Offcanvas:zi,Popover:dn,ScrollSpy:_n,Tab:xn,Toast:Nn,Tooltip:ln}}));

```

### frontend\public\js\GrammarChecker1.js
```js
// GrammarChecker1.js - Updated with new user dropdown
import { checkGrammar, detectLanguage, logUsageActivity } from './api.js'; 
import { showCustomAlert } from './utils.js';
import { NotificationManager } from './notifications.js';

const LANGUAGE_NAMES = {
  'en-US': 'English (US)', 'en': 'English', 'fr': 'French', 'de': 'German', 
  'ru': 'Russian', 'ru-RU': 'Russian', 'uk': 'Ukrainian', 'uk-UA': 'Ukrainian',
  'ja': 'Japanese', 'ja-JP': 'Japanese', 
  'es': 'Spanish', 'pt': 'Portuguese', 'gl-ES': 'Galician', 'de-DE': 'German (Germany)',
  'it': 'Italian', 'nl': 'Dutch', 'pl-PL': 'Polish', 'sv': 'Swedish',
  'da-DK': 'Danish', 'ar': 'Arabic', 'zh-CN': 'Chinese', 'ko': 'Korean',
  'vi': 'Vietnamese', 'th': 'Thai', 'be': 'Belarusian', 'bg': 'Bulgarian', 'sr': 'Serbian'
};

const LANGUAGE_CODE_MAP = {
  'en-US': 'en', 'en': 'en', 'ja-JP': 'ja', 'ja': 'ja', 'zh-CN': 'zh', 'zh': 'zh',
  'ru-RU': 'ru', 'ru': 'ru', 'uk-UA': 'uk', 'uk': 'uk', 'de-DE': 'de', 'de': 'de',
  'fr': 'fr', 'es': 'es', 'it': 'it', 'pt': 'pt', 'vi': 'vi', 'ko': 'ko',
  'ar': 'ar', 'nl': 'nl', 'pl-PL': 'pl', 'pl': 'pl', 'sv': 'sv',
  'da-DK': 'da', 'da': 'da', 'th': 'th', 'be': 'be', 'bg': 'bg', 'sr': 'sr'
};

function getLanguageName(code) {
  return LANGUAGE_NAMES[code] || code;
}

function normalizeLanguageCode(code) {
  return LANGUAGE_CODE_MAP[code] || code;
}

// ==================== USER DROPDOWN SETUP ====================

function setupUserDropdown() {
  const userAvatarToggle = document.getElementById('userAvatarToggle');
  const userDropdown = document.getElementById('userDropdown');
  
  if (!userAvatarToggle || !userDropdown) {
    console.warn('User dropdown elements not found');
    return;
  }
  
  userAvatarToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    userDropdown.classList.toggle('hidden');
    userAvatarToggle.classList.toggle('active');
  });
  
  document.addEventListener('click', (e) => {
    if (!userAvatarToggle.contains(e.target) && !userDropdown.contains(e.target)) {
      userDropdown.classList.add('hidden');
      userAvatarToggle.classList.remove('active');
    }
  });
}

function populateUserInfo(userData) {
  if (!userData) return;
  
  const headerUsername = document.getElementById('headerUsername');
  const dropdownUsername = document.getElementById('dropdownUsername');
  const dropdownEmail = document.getElementById('dropdownEmail');
  const username = userData.username || userData.name || 'User';
  const email = userData.email || 'user@example.com';
  
  if (headerUsername) headerUsername.textContent = username;
  if (dropdownUsername) dropdownUsername.textContent = username;
  if (dropdownEmail) dropdownEmail.textContent = email;
  
  console.log('User info populated:', username);
}

function setupLogout() {
    const logoutBtn = document.getElementById('logoutBtn');
    
    if (!logoutBtn) {
        console.warn('Logout button not found');
        return;
    }
    
    logoutBtn.addEventListener('click', (e) => {
        e.preventDefault();
        
        if (AuthManager.logout()) {
            showCustomAlert('Logged out successfully', 'success', 1500);
            
            setTimeout(() => {
                window.location.href = '/introduction.html';
            }, 1000);
        }
    });
}

// ==================== NOTIFICATIONS ====================

async function initializeNotifications(user) {
  if (!user || !user.userId) {
    console.warn('Cannot initialize notifications: No user data');
    return;
  }
  
  try {
    await logUsageActivity({
      action: 'page_access',
      language: null,
      details: { page: 'grammar_checker' }
    });

    console.log('Initializing notifications for user:', user.username);
    
    if (!window.notificationManager) {
      window.notificationManager = new NotificationManager();
      console.log('Created new NotificationManager instance');
    } else {
      console.log('Using existing NotificationManager instance');
    }
    
    await window.notificationManager.init(user.userId, user.userRole || 'user');
    console.log('Notifications initialized successfully');
    
  } catch (error) {
    console.error('Error initializing notifications:', error);
  }
}

// ==================== GRAMMAR CHECKER LOGIC ====================

document.addEventListener("DOMContentLoaded", async () => {
    if (!AuthManager.validatePageAccess()) {
        return;
    }
    
    const currentUser = AuthManager.getCurrentUser();
    
    if (!currentUser) {
        console.error('Failed to get user data');
        window.location.href = '/login.html?redirect=/GrammarChecker1.html';
        return;
    }

  populateUserInfo(currentUser);
  setupUserDropdown();
  setupLogout();

  // DOM Elements
  const textInput = document.getElementById('textInput');
  const languageSelect = document.getElementById('languageSelect');
  const checkGrammarBtn = document.getElementById('checkGrammarBtn');
  const highlightedTextDiv = document.getElementById('highlightedText');
  const suggestionsList = document.getElementById('suggestionsList');
  const wordCountSpan = document.getElementById('wordCount');
  const charCountSpan = document.getElementById('charCount');
  const errorCountSpan = document.getElementById('errorCount');
  const successMessageDiv = document.getElementById('successMessage');
  const errorMessageDiv = document.getElementById('errorMessage');
  const acceptAllBtn = document.getElementById('acceptAllBtn');
  const noSuggestionsDiv = document.querySelector('.no-suggestions');

  // ==================== UTILITY FUNCTIONS ====================

  function getFreeUsageCount() {
    return parseInt(localStorage.getItem("freeUsageCount") || "0");
  }

  function incrementFreeUsageCount() {
    localStorage.setItem("freeUsageCount", getFreeUsageCount() + 1);
  }

  function showLoginModal() {
    document.getElementById('loginModal')?.classList.remove('hidden');
  }

  function escapeHtml(text) {
    return text.replace(/[&<>"']/g, (match) => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[match]));
  }
  
  function showMessage(el, msg, type) {
    el.textContent = msg;
    el.className = `message ${type}`;
    el.classList.remove('hidden');
    setTimeout(() => {
      el.classList.add('hidden');
    }, 5000);
  }

  function setLoading(btn, isLoading) {
    const loader = btn.querySelector('.btn-loader');
    const btnText = btn.querySelector('.btn-text');
    
    if (isLoading) {
      btn.disabled = true;
      loader?.classList.remove('hidden');
      loader?.classList.add('show');
      btnText?.classList.add('hidden');
    } else {
      btn.disabled = false;
      loader?.classList.add('hidden');
      loader?.classList.remove('show');
      btnText?.classList.remove('hidden');
    }
  }

  function setAcceptAllLoading(isLoading) {
    setLoading(acceptAllBtn, isLoading);
  }

  function showNoSuggestions() {
    suggestionsList.classList.add('hidden');
    noSuggestionsDiv.classList.remove('hidden');
  }

  function hidePlaceholder() {
    const placeholder = highlightedTextDiv.querySelector('.placeholder-text');
    if (placeholder) {
      placeholder.style.display = 'none';
    }
  }

  function showPlaceholder() {
    const placeholder = highlightedTextDiv.querySelector('.placeholder-text');
    if (placeholder) {
      placeholder.style.display = 'flex';
    }
  }

  function getErrorTypeClass(match) {
    const category = match.rule?.category?.id || '';
    if (category.includes('TYPOS') || match.rule?.issueType === 'misspelling') {
      return 'Spelling Error';
    } else if (category.includes('GRAMMAR')) {
      return 'Grammar Error';
    } else if (category.includes('STYLE')) {
      return 'Style Suggestion';
    }
    return 'Grammar Error';
  }

  function createSuggestionItem(match, index) {
    const errorText = match.context?.text?.slice(match.context.offset, match.context.offset + match.context.length) || 'Unknown';
    const firstReplacement = match.replacements?.[0]?.value || '';
    const errorType = getErrorTypeClass(match);
    
    const li = document.createElement('li');
    li.className = 'suggestion-item';
    li.innerHTML = `
      <div class="suggestion-header">
        <div class="suggestion-error">${errorType}</div>
      </div>
      <div class="suggestion-message">${escapeHtml(match.message_en || match.message)}</div>
      <div class="suggestion-actions">
        ${firstReplacement ? `<span class="suggestion-fix">${escapeHtml(errorText)} â†’ ${escapeHtml(firstReplacement)}</span>` : '<em>No suggestions available</em>'}
        ${firstReplacement ? `<button class="suggestion-apply-btn" data-error-index="${index}" data-replacement="${escapeHtml(firstReplacement)}">Apply</button>` : ''}
      </div>
    `;
    
    return li;
  }

  function displayResults(text, matches) {
    hidePlaceholder();
    
    let html = '', lastIndex = 0;
    suggestionsList.innerHTML = '';
    suggestionsList.classList.remove('hidden');
    noSuggestionsDiv.classList.add('hidden');
    
    matches.sort((a, b) => a.offset - b.offset);

    matches.forEach((match, index) => {
      html += escapeHtml(text.slice(lastIndex, match.offset));
      const errorText = text.slice(match.offset, match.offset + match.length);
      html += `<span class="grammar-error" data-error-index="${index}" title="${escapeHtml(match.message_en || match.message)}">${escapeHtml(errorText)}</span>`;
      lastIndex = match.offset + match.length;

      const suggestionItem = createSuggestionItem(match, index);
      suggestionsList.appendChild(suggestionItem);
    });

    html += escapeHtml(text.slice(lastIndex));
    highlightedTextDiv.innerHTML = html;

    document.querySelectorAll('.suggestion-apply-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.dataset.errorIndex);
        const replacement = e.target.dataset.replacement;
        applySuggestion(index, replacement);
      });
    });

    document.querySelectorAll('.grammar-error').forEach(el => {
      el.addEventListener('click', () => {
        const index = parseInt(el.dataset.errorIndex);
        const suggestionItem = document.querySelector(`[data-error-index="${index}"]`).closest('.suggestion-item');
        if (suggestionItem) {
          suggestionItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          suggestionItem.style.backgroundColor = 'var(--primary-50)';
          setTimeout(() => {
            suggestionItem.style.backgroundColor = '';
          }, 2000);
        }
      });
    });

    acceptAllBtn?.classList.remove('hidden');
  }

  acceptAllBtn?.addEventListener('click', () => {
    const matches = JSON.parse(localStorage.getItem('lastGrammarMatches') || '[]');
    if (!matches.length) return;

    let updatedText = textInput.value;
    let offsetShift = 0;
    setAcceptAllLoading(true);

    matches.forEach(match => {
      const replacement = match.replacements?.[0]?.value;
      if (replacement) {
        const start = match.offset + offsetShift;
        const end = start + match.length;
        updatedText = updatedText.slice(0, start) + replacement + updatedText.slice(end);
        offsetShift += replacement.length - match.length;
      }
    });

    setTimeout(() => {
      textInput.value = updatedText;
      highlightedTextDiv.textContent = updatedText;
      showNoSuggestions();
      errorCountSpan.textContent = '0';
      acceptAllBtn.classList.add('hidden');
      setAcceptAllLoading(false);
      showCustomAlert('All suggestions applied!', 'success');
      hidePlaceholder();
    }, 300);
  });

  function applySuggestion(index, replacement) {
    const text = textInput.value;
    const matches = JSON.parse(localStorage.getItem('lastGrammarMatches') || '[]');
    const match = matches[index];
    
    if (!match) return;
    
    const newText = text.slice(0, match.offset) + replacement + text.slice(match.offset + match.length);
    textInput.value = newText;
    highlightedTextDiv.textContent = newText;
    
    const suggestionItem = document.querySelector(`[data-error-index="${index}"]`).closest('.suggestion-item');
    if (suggestionItem) {
      suggestionItem.style.transform = 'translateX(100%)';
      suggestionItem.style.opacity = '0';
      setTimeout(() => {
        suggestionItem.remove();
        
        const remainingSuggestions = suggestionsList.querySelectorAll('.suggestion-item');
        if (remainingSuggestions.length === 0) {
          showNoSuggestions();
          acceptAllBtn?.classList.add('hidden');
        }
        
        errorCountSpan.textContent = remainingSuggestions.length;
      }, 300);
    }
    
    hidePlaceholder();
    showCustomAlert("Suggestion applied!", 'success');
  }

  function showLoading(isLoading) {
    setLoading(checkGrammarBtn, isLoading);
  }

  function hideMessages() {
    successMessageDiv.classList.add('hidden');
    errorMessageDiv.classList.add('hidden');
  }

  function updateStats() {
    const text = textInput.value;
    charCountSpan.textContent = text.length;
    wordCountSpan.textContent = (text.match(/\b\w+\b/g) || []).length;
  }

  function populateLanguages() {
    languageSelect.innerHTML = '';
    [
      { code: 'en-US', name: 'English (US)' },
      { code: 'fr', name: 'French' },
      { code: 'de', name: 'German' },
      { code: 'es', name: 'Spanish' },
      { code: 'it', name: 'Italian' },
      { code: 'pt', name: 'Portuguese' },
      { code: 'ru', name: 'Russian' },
      { code: 'ja-JP', name: 'Japanese' },
      { code: 'zh-CN', name: 'Chinese' }
    ].forEach(({ code, name }) => {
      const opt = document.createElement('option');
      opt.value = code;
      opt.textContent = name;
      languageSelect.appendChild(opt);
    });
    languageSelect.value = 'en-US'; 
  }

  checkGrammarBtn?.addEventListener('click', async () => {
    hideMessages();
    const text = textInput.value.trim();
    const selectedLang = languageSelect.value;

    if (!text) {
      showMessage(errorMessageDiv, 'Please enter some text to check.', 'error');
      return;
    }
    
    if (!currentUser?.userId && getFreeUsageCount() >= 3) {
      showMessage(errorMessageDiv, 'You have used all 3 free grammar checks. Please log in to continue.', 'error');
      return showLoginModal();
    }

    showLoading(true);
    
    try {
      const hiraganaPattern = /[\u3040-\u309F]/;
      const katakanaPattern = /[\u30A0-\u30FF]/;
      const koreanPattern = /[\uAC00-\uD7AF\u1100-\u11FF]/; 
      const arabicPattern = /[\u0600-\u06FF\u0750-\u077F]/; 
      const cyrillicPattern = /[\u0400-\u04FF]/; 
      const thaiPattern = /[\u0E00-\u0E7F]/; 
  
  let preDetectedLang = null;
  
    // âœ… Japanese: CHá»ˆ khi cÃ³ Hiragana HOáº¶C Katakana
    if (hiraganaPattern.test(text) || katakanaPattern.test(text)) {
      preDetectedLang = 'ja-JP';
      console.log('Pre-detected Japanese by Hiragana/Katakana');
    } else if (koreanPattern.test(text)) {
      preDetectedLang = 'ko';
      console.log('Pre-detected Korean by Hangul');
    } else if (thaiPattern.test(text)) {
      preDetectedLang = 'th';
      console.log('Pre-detected Thai by Unicode range');
    } else if (arabicPattern.test(text)) {
      preDetectedLang = 'ar';
      console.log('Pre-detected Arabic by Unicode range');
    } else if (cyrillicPattern.test(text)) {
      preDetectedLang = 'ru-RU';
      console.log('Pre-detected Cyrillic (Russian) by Unicode range');
    }
      
      let detectionInfo;
      if (preDetectedLang) {
        detectionInfo = {
          language: preDetectedLang,
          confidence: 0.95, 
          reliable: true,
          source: 'unicode-pattern'
        };
      } else {
        console.log('Detecting language with CLD3...');
        detectionInfo = await detectLanguage(text);
      }
      const detectedLang = normalizeLanguageCode(detectionInfo.language);
      const selectedLangNormalized = normalizeLanguageCode(selectedLang);
      
      console.log(`Selected: ${selectedLang} (${selectedLangNormalized})`);
      console.log(`Detected: ${detectionInfo.language} (${detectedLang})`);
      console.log(`Confidence: ${(detectionInfo.confidence * 100).toFixed(1)}%`);
      
      const shouldValidate = detectionInfo.confidence > 0.3;
      const cyrillicLanguages = ['ru', 'uk', 'be', 'bg', 'sr'];
      const isCyrillicDetected = cyrillicLanguages.includes(detectedLang);
      const isCyrillicSelected = cyrillicLanguages.includes(selectedLangNormalized);
      
      const areBothCyrillic = isCyrillicDetected && isCyrillicSelected;
      const shouldShowWarning = shouldValidate && detectedLang !== selectedLangNormalized && !areBothCyrillic;
      
      console.log('Validation check:', {
        shouldValidate,
        languageMatch: detectedLang === selectedLangNormalized,
        areBothCyrillic,
        shouldShowWarning
      });
      
      if (shouldShowWarning) {
        showLoading(false);
        
        const detectedLangName = getLanguageName(detectionInfo.language);
        const selectedLangName = getLanguageName(selectedLang);
        
        showMessage(
          errorMessageDiv, 
          `Language mismatch! Text language is "${detectedLangName}" but you selected "${selectedLangName}". Please select the correct language.`,
          'error'
        );
        
        languageSelect.style.border = '2px solid #dc3545';
        setTimeout(() => {
          languageSelect.style.border = '';
        }, 3000);
        
        showCustomAlert(
          `Detected language: ${detectedLangName}\nYou selected: ${selectedLangName}\n\nPlease change your language selection.`,
          'error'
        );
        
        return;
      }
      
      if (!currentUser?.userId) incrementFreeUsageCount();

      console.log(`Language validation passed. Checking grammar...`);
      const result = await checkGrammar(text, selectedLang);
      const matches = result.matches || [];
      
      localStorage.setItem('lastGrammarMatches', JSON.stringify(matches));

      if (currentUser?.userId) {
        await logUsageActivity({
          action: 'grammar_check',
          language: selectedLang,
          details: {
            text_length: text.length,
            errors_found: matches.length,
            detected_language: detectionInfo.language,
            detection_confidence: detectionInfo.confidence,
            language_match: detectedLang === selectedLangNormalized,
            timestamp: new Date().toISOString()
          }
        });
      }

      if (!matches.length) {
        highlightedTextDiv.textContent = text;
        showNoSuggestions();
        acceptAllBtn?.classList.add('hidden');
        hidePlaceholder();
        showMessage(successMessageDiv, 'No grammar errors found! Your text looks great.', 'success');
      } else {
        displayResults(text, matches);
        showMessage(successMessageDiv, `Found ${matches.length} grammar issue${matches.length === 1 ? '' : 's'} to review.`, 'success');
      }

      errorCountSpan.textContent = matches.length;
      
    } catch (err) {
      console.error('Error checking grammar:', err);
      showMessage(errorMessageDiv, 'Grammar check failed. Please try again.', 'error');
    } finally {
      showLoading(false);
      updateStats();
    }
  });

  textInput.addEventListener('input', () => {
    const text = textInput.value.trim();
    updateStats();
    hideMessages();
    
    if (text) {
      highlightedTextDiv.textContent = text;
      hidePlaceholder();
    } else {
      highlightedTextDiv.innerHTML = `
        <div class="placeholder-text">
          <i class="fas fa-magic"></i>
          <p>Your corrected text will appear here.</p>
          <small>Start by entering text and clicking "Check Grammar"</small>
        </div>
      `;
    }
    
    errorCountSpan.textContent = '0';
    suggestionsList.innerHTML = '';
    suggestionsList.classList.add('hidden');
    noSuggestionsDiv.classList.add('hidden');
    acceptAllBtn?.classList.add('hidden');
  });

  populateLanguages();
  updateStats();
  
  if (!textInput.value.trim()) {
    highlightedTextDiv.innerHTML = `
      <div class="placeholder-text">
        <i class="fas fa-magic"></i>
        <p>Your corrected text will appear here.</p>
        <small>Start by entering text and clicking "Check Grammar"</small>
      </div>
    `;
  }
  
  console.log('Grammar Checker fully initialized');
});
```

### frontend\public\js\index.js
```js
// frontend/public/js/index.js

import { registerUser } from './api.js'; 
import { showCustomAlert, togglePassword } from './utils.js';

document.addEventListener("DOMContentLoaded", () => {
    const registerForm = document.getElementById("registerForm");
    const usernameInput = document.getElementById("username");
    const passwordInput = document.getElementById("password");
    const confirmPasswordInput = document.getElementById("confirmPassword");
    const phoneInput = document.getElementById("phone");
    const emailInput = document.getElementById("email");
    const fullNameInput = document.getElementById("fullName");

    const usernameError = document.getElementById("usernameError");
    const passwordError = document.getElementById("passwordError");
    const confirmPasswordError = document.getElementById("confirmPasswordError");
    const phoneError = document.getElementById("phoneError");
    const emailError = document.getElementById("emailError");
    const fullNameError = document.getElementById("fullNameError");
    const registerSuccess = document.getElementById("registerSuccess");
    const registerGeneralError = document.getElementById("registerGeneralError");

    // Show/Hide loading state on submit button
    function toggleSubmitButton(isLoading = false) {
        const submitBtn = document.querySelector('.submit-btn');
        const btnText = submitBtn?.querySelector('.btn-text');
        const btnLoading = submitBtn?.querySelector('.btn-loading');
        
        if (submitBtn && btnText && btnLoading) {
            if (isLoading) {
                btnText.classList.add('hidden');
                btnLoading.classList.remove('hidden');
                submitBtn.disabled = true;
            } else {
                btnText.classList.remove('hidden');
                btnLoading.classList.add('hidden');
                submitBtn.disabled = false;
            }
        }
    }

    // Enhanced error display with styling
    function displayError(element, message) {
        if (element) {
            element.textContent = message;
            element.style.color = '#ef4444';
            element.style.display = 'block';
        }
    }

    function clearError(element) {
        if (element) {
            element.textContent = "";
            element.style.display = 'none';
        }
    }

    function displaySuccess(element, message) {
        if (element) {
            element.textContent = message;
            element.style.color = '#10b981';
            element.style.display = 'block';
        }
    }

    function clearMessages() {
        clearError(usernameError);
        clearError(passwordError);
        clearError(confirmPasswordError);
        clearError(phoneError);
        clearError(emailError);
        clearError(fullNameError);
        clearError(registerSuccess);
        clearError(registerGeneralError);
    }

    function validateForm() {
        let isValid = true;
        let firstErrorField = null;
        
        clearMessages();

        // âœ… ADDED: Full Name validation
        if (fullNameInput.value.trim().length < 2) {
            displayError(fullNameError, "Full name must be at least 2 characters.");
            if (!firstErrorField) firstErrorField = fullNameInput;
            isValid = false;
        }

        // Username validation
        if (usernameInput.value.trim().length < 3) {
            displayError(usernameError, "Username must be at least 3 characters.");
            if (!firstErrorField) firstErrorField = usernameInput;
            isValid = false;
        }

        // Password validation
        if (passwordInput.value.length < 6) {
            displayError(passwordError, "Password must be at least 6 characters.");
            if (!firstErrorField) firstErrorField = passwordInput;
            isValid = false;
        }

        // Confirm password validation
        if (passwordInput.value !== confirmPasswordInput.value) {
            displayError(confirmPasswordError, "Passwords do not match.");
            if (!firstErrorField) firstErrorField = confirmPasswordInput;
            isValid = false;
        }

        // Email validation (enhanced)
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(emailInput.value.trim())) {
            displayError(emailError, "Please enter a valid email address.");
            if (!firstErrorField) firstErrorField = emailInput;
            isValid = false;
        }

        // Phone validation (optional but if provided must be valid)
        if (phoneInput.value.trim() !== "") {
            const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
            if (!phoneRegex.test(phoneInput.value.trim())) {
                displayError(phoneError, "Please enter a valid phone number.");
                if (!firstErrorField) firstErrorField = phoneInput;
                isValid = false;
            }
        }

        if (firstErrorField) {
            firstErrorField.focus();
        }

        return isValid;
    }

    // Enhanced real-time validation
    fullNameInput?.addEventListener('input', () => {
        if (fullNameInput.value.trim().length >= 2) {
            clearError(fullNameError);
        }
    });

    usernameInput?.addEventListener('input', () => {
        if (usernameInput.value.trim().length >= 3) {
            clearError(usernameError);
        }
    });

    passwordInput?.addEventListener('input', () => {
        if (passwordInput.value.length >= 6) {
            clearError(passwordError);
        }
        if (confirmPasswordInput.value && passwordInput.value === confirmPasswordInput.value) {
            clearError(confirmPasswordError);
        }
    });

    confirmPasswordInput?.addEventListener('input', () => {
        if (passwordInput.value === confirmPasswordInput.value) {
            clearError(confirmPasswordError);
        }
    });

    emailInput?.addEventListener('input', () => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (emailRegex.test(emailInput.value.trim())) {
            clearError(emailError);
        }
    });

    phoneInput?.addEventListener('input', () => {
        const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
        if (phoneInput.value.trim() === "" || phoneRegex.test(phoneInput.value.trim())) {
            clearError(phoneError);
        }
    });

    document.querySelectorAll('.toggle-password').forEach(btn => {
        btn.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            togglePassword(this.querySelector('i')); 
        });
    });

    registerForm?.addEventListener("submit", async function(e) {
        e.preventDefault();
        clearMessages();

        if (validateForm()) {
            const fullName = fullNameInput.value.trim();
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            const email = emailInput.value.trim();
            const phone = phoneInput.value.trim();

            try {
                toggleSubmitButton(true);

                const data = await registerUser({ fullName, username, password, email, phone });

                if (data.success) {
                    showCustomAlert("Registration successful! Redirecting to login...", 'success');
                    displaySuccess(registerSuccess, "Registration successful! Redirecting to login...");

                    const params = new URLSearchParams(window.location.search);
                    const redirectTo = params.get('redirect');

                    setTimeout(() => {
                        const authContainer = document.querySelector('.auth-container');
                        if (authContainer) {
                            authContainer.style.transform = 'translateY(-20px)';
                            authContainer.style.opacity = '0';
                            authContainer.style.transition = 'all 0.3s ease-out';
                        }
                    }, 1000);

                    setTimeout(() => {
                        if (redirectTo) {
                            window.location.href = redirectTo;
                        } else {
                            window.location.href = "login.html?message=registration_success";
                        }
                    }, 1500);
                } else {
                    const errorMessage = data.error || "Registration failed. Please try again.";
                    showCustomAlert(errorMessage, 'error');
                    displayError(registerGeneralError, errorMessage);
                }
            } catch (error) {
                console.error('Error during registration API call:', error);
                const errorMsg = "Network error or server unavailable. Please try again later.";
                showCustomAlert(errorMsg, 'error');
                displayError(registerGeneralError, errorMsg);
            } finally {
                toggleSubmitButton(false);
            }
        } else {
            displayError(registerGeneralError, "Please correct the errors above.");
        }
    });

    const animationParams = new URLSearchParams(window.location.search);
    if (animationParams.get("animate") === "right") {
        const authContainer = document.querySelector('.auth-container');
        if (authContainer) {
            authContainer.classList.add("slide-in-right");
        }
    }

    const switchFormLinks = document.querySelectorAll('.switch-form-link');
    switchFormLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const href = link.getAttribute('href');
            
            if (href) {
                const authContainer = document.querySelector('.auth-container');
                if (authContainer) {
                    authContainer.style.transform = 'translateX(-100px)';
                    authContainer.style.opacity = '0';
                    authContainer.style.transition = 'all 0.3s ease-out';
                }
                
                setTimeout(() => {
                    window.location.href = href;
                }, 300);
            }
        });
    });

    // Enhanced back arrow functionality
    const backArrowBtn = document.querySelector('.back-arrow-btn');
    if (backArrowBtn) {
        backArrowBtn.addEventListener('click', (e) => {
            e.preventDefault();
            
            const authContainer = document.querySelector('.auth-container');
            if (authContainer) {
                authContainer.style.transform = 'scale(0.95)';
                authContainer.style.opacity = '0';
                authContainer.style.transition = 'all 0.3s ease-out';
            }
            
            setTimeout(() => {
                window.location.href = backArrowBtn.href;
            }, 300);
        });
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.activeElement?.blur();
            clearMessages();
        }
        
        if (e.key === 'Enter' && e.target.tagName !== 'BUTTON') {
            const submitBtn = document.querySelector('.submit-btn');
            if (submitBtn && !submitBtn.disabled) {
                submitBtn.click();
            }
        }
    });

    setTimeout(() => {
        if (!fullNameInput?.value) {
            fullNameInput?.focus();
        } else if (!usernameInput?.value) {
            usernameInput?.focus();
        } else if (!passwordInput?.value) {
            passwordInput?.focus();
        } else if (!confirmPasswordInput?.value) {
            confirmPasswordInput?.focus();
        } else if (!emailInput?.value) {
            emailInput?.focus();
        }
    }, 100);

    function resetForm() {
        registerForm?.reset();
        clearMessages();
        fullNameInput?.focus(); 
    }

    const resetBtn = document.querySelector('.reset-btn');
    if (resetBtn) {
        resetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            resetForm();
        });
    }

    // Password strength indicator (optional enhancement)
    passwordInput?.addEventListener('input', () => {
        const password = passwordInput.value;
        const strengthIndicator = document.querySelector('.password-strength');
        
        if (strengthIndicator) {
            let strength = 0;
            if (password.length >= 6) strength++;
            if (password.match(/[a-z]/)) strength++;
            if (password.match(/[A-Z]/)) strength++;
            if (password.match(/[0-9]/)) strength++;
            if (password.match(/[^a-zA-Z0-9]/)) strength++;
            
            strengthIndicator.className = `password-strength strength-${strength}`;
            
            const strengthTexts = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'];
            strengthIndicator.textContent = strengthTexts[strength] || '';
        }
    });
});
```

### frontend\public\js\login.js
```js
// frontend/public/js/login.js

import { loginUser, logUsageActivity } from './api.js';
import { showCustomAlert, togglePassword } from './utils.js';

function displayError(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = '#ef4444'; 
        element.style.display = 'block';
    }
}

function clearError(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = '';
        element.style.display = 'none';
    }
}

function displaySuccess(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = '#10b981'; 
        element.style.display = 'block';
    }
}

// Show/Hide loading state on submit button
function toggleSubmitButton(isLoading = false) {
    const submitBtn = document.querySelector('.submit-btn');
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnLoading = submitBtn?.querySelector('.btn-loading');
    
    if (submitBtn && btnText && btnLoading) {
        if (isLoading) {
            btnText.classList.add('hidden');
            btnLoading.classList.remove('hidden');
            submitBtn.disabled = true;
        } else {
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            submitBtn.disabled = false;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const usernameInput = document.getElementById('loginUsername');
    const passwordInput = document.getElementById('loginPassword');
    const loginGeneralError = document.getElementById('loginGeneralError');
    const loginSuccess = document.getElementById('loginSuccess');

    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');

    // Setup password toggle buttons
    document.querySelectorAll('.toggle-password').forEach(btn => {
        btn.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            togglePassword(this.querySelector('i'));
        });
    });

    // Handle URL messages
    if (message === 'registration_success') {
        showCustomAlert("Registration successful! Please log in.", 'success');
        displaySuccess('loginSuccess', 'Registration successful! Please log in.');
        history.replaceState({}, document.title, window.location.pathname);
    } else if (message === 'login_required') {
        showCustomAlert("Please log in to access the grammar checker.", 'info');
        history.replaceState({}, document.title, window.location.pathname);
    } else if (message === 'admin_required') {
        showCustomAlert("Admin access required. Please log in as administrator.", 'warning');
        history.replaceState({}, document.title, window.location.pathname);
    }

    // Handle animation parameter
    const animateParam = urlParams.get('animate');
    if (animateParam === 'left') {
        const authContainer = document.querySelector('.auth-container');
        if (authContainer) {
            authContainer.classList.add('slide-in-left');
        }
        history.replaceState({}, document.title, window.location.pathname);
    }

    // Form validation
    function validateLoginForm() {
        let isValid = true;
        
        clearError('loginGeneralError');
        
        const username = usernameInput?.value.trim();
        const password = passwordInput?.value;
        
        if (!username) {
            displayError('loginGeneralError', 'Username is required.');
            usernameInput?.focus();
            isValid = false;
        } else if (username.length < 3) {
            displayError('loginGeneralError', 'Username must be at least 3 characters.');
            usernameInput?.focus();
            isValid = false;
        }
        
        if (!password) {
            displayError('loginGeneralError', 'Password is required.');
            if (isValid) passwordInput?.focus(); 
            isValid = false;
        } else if (password.length < 6) {
            displayError('loginGeneralError', 'Password must be at least 6 characters.');
            if (isValid) passwordInput?.focus();
            isValid = false;
        }
        
        return isValid;
    }

    // Real-time validation
    usernameInput?.addEventListener('input', () => {
        if (usernameInput.value.trim().length >= 3) {
            clearError('loginGeneralError');
        }
    });

    passwordInput?.addEventListener('input', () => {
        if (passwordInput.value.length >= 6) {
            clearError('loginGeneralError');
        }
    });

    // Check if already logged in (using original AuthManager)
    if (window.AuthManager && AuthManager.isLoggedIn()) {
        const currentUser = AuthManager.getCurrentUser();
        console.log('ğŸ‘¤ Already logged in (Tab ID: ' + currentUser._tabId + '):', currentUser.username);
        
        // Show info and redirect
        showCustomAlert(`Already logged in as ${currentUser.username}. Redirecting...`, 'info');
        
        setTimeout(() => {
            const redirectTo = currentUser.userRole === 'admin' ? '/admin.html' : '/introduction.html';
            window.location.href = redirectTo;
        }, 1500);
        
        return; // Don't setup form if already logged in
    }

    // Handle form submission
    if (loginForm) {
        loginForm.addEventListener('submit', async (event) => {
            event.preventDefault();

            clearError('loginGeneralError');
            clearError('loginSuccess');

            if (!validateLoginForm()) {
                return;
            }

            const username = usernameInput.value.trim();
            const password = passwordInput.value;

            try {
                toggleSubmitButton(true);
                
                const response = await loginUser(username, password);
                console.log("Login API response:", response);

                if (response.success && response.userId) {
                    // Prepare user data for AuthManager
                    const userToStore = {
                        userId: response.userId,
                        username: response.username,
                        email: response.email,
                        phone: response.phone,
                        userRole: response.userRole
                    };

                    // Login through AuthManager (creates session for this tab)
                    AuthManager.login(userToStore);
                    
                    // Get the tab ID that was assigned
                    const tabId = AuthManager.getTabId();
                    console.log('âœ… Login successful on Tab ID:', tabId);
                    
                    // Log usage activity
                    try {
                        await logUsageActivity({
                            action: 'login',
                            language: null,
                            details: { 
                                login_method: 'username_password',
                                user_role: userToStore.userRole,
                                tab_id: tabId
                            }
                        });
                    } catch (activityError) {
                        console.warn('Failed to log activity:', activityError);
                        // Don't block login if activity logging fails
                    }

                    // Show success message
                    showCustomAlert("Login successful! Redirecting...", 'success');
                    displaySuccess('loginSuccess', 'Login successful! Redirecting...');

                    // Determine redirect destination
                    const redirectTo = urlParams.get('redirect') ||
                        (userToStore.userRole === 'admin' ? '/admin.html' : '/introduction.html');

                    // Animate out
                    setTimeout(() => {
                        const authContainer = document.querySelector('.auth-container');
                        if (authContainer) {
                            authContainer.style.transform = 'translateY(-20px)';
                            authContainer.style.opacity = '0';
                            authContainer.style.transition = 'all 0.3s ease-out';
                        }
                    }, 1000);

                    // Redirect
                    setTimeout(() => {
                        window.location.href = redirectTo;
                    }, 1500);

                } else {
                    const errorMessage = response.error || 'Login failed. Invalid credentials or missing user data from server.';
                    displayError('loginGeneralError', errorMessage);
                    showCustomAlert(errorMessage, 'error');
                }

            } catch (error) {
                console.error('Error during login API call:', error);
                const errorMsg = "Network error or server unavailable. Please try again later.";
                showCustomAlert(errorMsg, 'error');
                displayError('loginGeneralError', errorMsg);
            } finally {
                toggleSubmitButton(false);
            }
        });
    }

    // Social login handlers
    document.querySelectorAll('.social-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const provider = btn.classList.contains('social-btn-google') ? 'Google' : 'Facebook';
            showCustomAlert(`${provider} login is not implemented yet.`, 'info');
        });
    });

    // Form switching with animation
    const switchFormLinks = document.querySelectorAll('.switch-form-link');
    switchFormLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const href = link.getAttribute('href');
            
            if (href) {
                const authContainer = document.querySelector('.auth-container');
                if (authContainer) {
                    authContainer.style.transform = 'translateX(100px)';
                    authContainer.style.opacity = '0';
                    authContainer.style.transition = 'all 0.3s ease-out';
                }
                
                setTimeout(() => {
                    window.location.href = href;
                }, 300);
            }
        });
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.activeElement?.blur();
            clearError('loginGeneralError');
        }
        
        if (e.key === 'Enter' && e.target.tagName !== 'BUTTON') {
            const submitBtn = document.querySelector('.submit-btn');
            if (submitBtn && !submitBtn.disabled) {
                submitBtn.click();
            }
        }
    });

    // Auto-focus first empty field
    setTimeout(() => {
        if (!usernameInput?.value) {
            usernameInput?.focus();
        } else if (!passwordInput?.value) {
            passwordInput?.focus();
        }
    }, 100);

    // Listen for auth events from AuthManager (Multi-Session)
    window.addEventListener('auth-login', (event) => {
        const { user, tabId } = event.detail;
        console.log('ğŸ“¢ Auth Event - Login:', user.username, 'Tab:', tabId);
    });

    window.addEventListener('auth-logout', (event) => {
        const { user, tabId } = event.detail;
        console.log('ğŸ“¢ Auth Event - Logout:', user?.username, 'Tab:', tabId);
    });

    window.addEventListener('auth-logout-all', (event) => {
        console.log('ğŸ“¢ Auth Event - Logout All Tabs');
    });

    // Debug: Show session info in console (development only)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('ğŸ” Debug - All Sessions:', AuthManager.getSessionsInfo());
        console.log('ğŸ“Š Debug - Active Tab ID:', AuthManager.getTabId());
        
        // Show active sessions count
        const sessionsInfo = AuthManager.getSessionsInfo();
        if (sessionsInfo.length > 0) {
            console.log(`â„¹ï¸ There are ${sessionsInfo.length} active session(s):`);
            sessionsInfo.forEach((session, index) => {
                console.log(`  ${index + 1}. ${session.username} (${session.userRole}) - ${session.isCurrent ? 'CURRENT TAB' : 'Other Tab'}`);
            });
        }
    }
});
```

### frontend\public\js\notifications.js
```js
// frontend/public/js/notifications.js
class NotificationManager {
    constructor() {
        this.notifications = [];
        this.unreadCount = 0;
        this.userId = null;
        this.userRole = null;
        
        // DOM elements
        this.notificationIcon = document.querySelector('.notification-icon');
        this.notificationDropdown = document.getElementById('notificationDropdown');
        this.notificationList = document.getElementById('notificationList');
        this.seeAllBtn = document.getElementById('seeAllBtn');
        
        // Create badge element
        this.createNotificationBadge();
        
        // Bind events
        this.bindEvents();
        
        console.log('ğŸ“± NotificationManager initialized');
    }

    createNotificationBadge() {
        this.badge = document.createElement('span');
        this.badge.className = 'notification-badge hidden';
        this.badge.id = 'notificationBadge';
        this.notificationIcon.appendChild(this.badge);
        
        const style = document.createElement('style');
        style.textContent = `
            .notification-icon {
                position: relative;
                cursor: pointer;
                padding: 10px;
                border-radius: 50%;
                transition: background-color 0.3s;
            }
            
            .notification-icon:hover {
                background-color: rgba(0, 0, 0, 0.1);
            }
            
            .notification-badge {
                position: absolute;
                top: 5px;
                right: 5px;
                background-color: #ff4444;
                color: white;
                border-radius: 50%;
                width: 18px;
                height: 18px;
                font-size: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                animation: pulse 2s infinite;
            }
            
            .notification-badge.hidden {
                display: none !important;
            }
            
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            
            .notification-dropdown {
                position: absolute;
                top: 100%;
                right: 0;
                width: 350px;
                max-height: 400px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                overflow: hidden;
            }
            
            .notification-dropdown.hidden {
                display: none;
            }
            
            .notification-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                border-bottom: 1px solid #eee;
                background-color: #f8f9fa;
            }
            
            .notification-header h4 {
                margin: 0;
                font-size: 16px;
                color: #333;
            }
            
            .notification-list {
                list-style: none;
                margin: 0;
                padding: 0;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .notification-item {
                padding: 12px 15px;
                border-bottom: 1px solid #eee;
                cursor: pointer;
                transition: background-color 0.2s;
                position: relative;
            }
            
            .notification-item:hover {
                background-color: #f8f9fa;
            }
            
            .notification-item.unread {
                background-color: #e3f2fd;
                border-left: 3px solid #2196f3;
            }
            
            .notification-item.unread::before {
                content: '';
                position: absolute;
                top: 15px;
                right: 15px;
                width: 8px;
                height: 8px;
                background-color: #2196f3;
                border-radius: 50%;
            }
            
            .notification-title {
                font-weight: 600;
                font-size: 14px;
                color: #333;
                margin-bottom: 4px;
            }
            
            .notification-message {
                font-size: 13px;
                color: #666;
                margin-bottom: 6px;
                line-height: 1.4;
            }
            
            .notification-time {
                font-size: 11px;
                color: #999;
            }
            
            .notification-actions {
                padding: 10px 15px;
                border-top: 1px solid #eee;
                background-color: #f8f9fa;
                display: flex;
                gap: 10px;
            }
            
            .btn-link {
                background: none;
                border: none;
                color: #007bff;
                cursor: pointer;
                font-size: 12px;
                text-decoration: underline;
            }
            
            .btn-link:hover {
                color: #0056b3;
            }
            
            .no-notifications {
                padding: 30px;
                text-align: center;
                color: #666;
            }
            
            .no-notifications i {
                font-size: 24px;
                margin-bottom: 10px;
                color: #ccc;
            }
        `;
        document.head.appendChild(style);
    }

    bindEvents() {
        this.notificationIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown();
        });
        
        document.addEventListener('click', (e) => {
            if (!this.notificationIcon.contains(e.target) && 
                !this.notificationDropdown.contains(e.target)) {
                this.closeDropdown();
            }
        });
        
        this.seeAllBtn.addEventListener('click', () => {
              this.markAllAsRead();
        });
    }

    async init(userId, userRole) {
        this.userId = userId;
        this.userRole = userRole;
        
        console.log(`ğŸ“± Initializing notifications for user ${userId}`);
        
        await this.loadNotifications();
        
        this.startPeriodicRefresh();
    }

    async loadNotifications() {
        if (!this.userId) {
            console.warn('âš ï¸ No user ID available for loading notifications');
            return;
        }

        try {
            const response = await fetch(`/api/notifications/user/${this.userId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                this.notifications = data.notifications;
                this.unreadCount = data.meta.unreadCount;
                
                console.log(`ğŸ“± Loaded ${this.notifications.length} notifications, ${this.unreadCount} unread`);
                
                this.updateUI();
            } else {
                console.error('âŒ Failed to load notifications:', data.error);
            }

        } catch (error) {
            console.error('âŒ Error loading notifications:', error);
        }
    }

    updateUI() {
        this.updateBadge();
        this.renderNotifications();
    }

    updateBadge() {
        if (this.unreadCount > 0) {
            this.badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount.toString();
            this.badge.classList.remove('hidden');
        } else {
            this.badge.classList.add('hidden');
        }
    }

    renderNotifications() {
        if (this.notifications.length === 0) {
            this.notificationList.innerHTML = `
                <li class="no-notifications">
                    <i class="fas fa-bell-slash"></i>
                    <p>No notifications yet</p>
                </li>
            `;
            return;
        }

        this.notificationList.innerHTML = this.notifications
            .slice(0, 10) 
            .map(notification => this.createNotificationHTML(notification))
            .join('');

        const existingActions = document.querySelector('.notification-actions');
        if (existingActions) {
        existingActions.remove();
        }

        this.bindNotificationItemEvents();
    }
    createNotificationHTML(notification) {
        const isUnread = !notification.IsRead;
        const timeAgo = this.getTimeAgo(new Date(notification.CreatedAt));
        
        return `
            <li class="notification-item ${isUnread ? 'unread' : ''}" 
                data-notification-id="${notification.NotificationID}">
                <div class="notification-title">${this.escapeHtml(notification.Title)}</div>
                <div class="notification-message">${this.escapeHtml(notification.Message)}</div>
                <div class="notification-time">${timeAgo}</div>
            </li>
        `;
    }

    bindNotificationItemEvents() {
        const items = this.notificationList.querySelectorAll('.notification-item');
        items.forEach(item => {
            item.addEventListener('click', () => {
                const notificationId = item.dataset.notificationId;
                this.markAsRead(notificationId);
            });
        });
    }

    async markAsRead(notificationId) {
        try {
            const response = await fetch(`/api/notifications/${notificationId}/read`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                const notification = this.notifications.find(n => n.NotificationID == notificationId);
                if (notification && !notification.IsRead) {
                    notification.IsRead = true;
                    notification.ReadAt = new Date().toISOString();
                    this.unreadCount = Math.max(0, this.unreadCount - 1);
                    
                    console.log(`âœ… Marked notification ${notificationId} as read`);
                    this.updateUI();
                }
            }

        } catch (error) {
            console.error('âŒ Error marking notification as read:', error);
        }
    }

    async markAllAsRead() {
        if (this.unreadCount === 0) return;

        try {
            const response = await fetch(`/api/notifications/user/${this.userId}/mark-all-read`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': this.userId.toString(),
                    'x-user-role': this.userRole
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success) {
                this.notifications.forEach(notification => {
                    if (!notification.IsRead) {
                        notification.IsRead = true;
                        notification.ReadAt = new Date().toISOString();
                    }
                });
                
                this.unreadCount = 0;
                
                console.log(`âœ… Marked all notifications as read`);
                this.updateUI();
                this.closeDropdown();
                
                this.showToast('All notifications marked as read', 'success');
            }

        } catch (error) {
            console.error('âŒ Error marking all notifications as read:', error);
            this.showToast('Error marking notifications as read', 'error');
        }
    }

    toggleDropdown() {
        const isHidden = this.notificationDropdown.classList.contains('hidden');
        
        if (isHidden) {
            this.openDropdown();
        } else {
            this.closeDropdown();
        }
    }

    openDropdown() {
        this.notificationDropdown.classList.remove('hidden');
        
        this.loadNotifications();
    }

    closeDropdown() {
        this.notificationDropdown.classList.add('hidden');
    }

    startPeriodicRefresh() {
        setInterval(() => {
            if (this.userId) {
                this.loadNotifications();
            }
        }, 300000);
    }

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `notification-toast notification-toast-${type}`;
        toast.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'exclamation' : 'info'}-circle"></i>
            <span>${message}</span>
        `;
        
        const style = document.createElement('style');
        style.textContent = `
            .notification-toast {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 16px;
                border-radius: 6px;
                color: white;
                font-size: 14px;
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 8px;
                animation: slideInRight 0.3s ease-out;
            }
            
            .notification-toast-success { background-color: #28a745; }
            .notification-toast-error { background-color: #dc3545; }
            .notification-toast-info { background-color: #17a2b8; }
            
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        `;
        
        if (!document.querySelector('style[data-toast-styles]')) {
            style.setAttribute('data-toast-styles', 'true');
            document.head.appendChild(style);
        }
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'slideInRight 0.3s ease-out reverse';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 3000);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    getTimeAgo(date) {
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        if (diffInSeconds < 60) return 'Just now';
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
        if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
        
        return date.toLocaleDateString();
    }
}

window.notificationManager = new NotificationManager();
export { NotificationManager };
```

### frontend\public\js\utils.js
```js
// frontend/public/js/utils.js

export function showCustomAlert(message, type = 'info', duration = 3000) {
    const existingAlert = document.getElementById('customAlert');
    if (existingAlert) {
        existingAlert.remove();
    }

    const alertDiv = document.createElement('div');
    alertDiv.id = 'customAlert';
    alertDiv.textContent = message;

    alertDiv.style.position = 'fixed';
    alertDiv.style.top = '20px';
    alertDiv.style.left = '50%';
    alertDiv.style.transform = 'translateX(-50%)';
    alertDiv.style.padding = '15px 30px';
    alertDiv.style.borderRadius = '8px';
    alertDiv.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
    alertDiv.style.zIndex = '9999';
    alertDiv.style.fontSize = '1.1em';
    alertDiv.style.fontWeight = 'bold';
    alertDiv.style.textAlign = 'center';
    alertDiv.style.opacity = '0';
    alertDiv.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';

    // Type-specific styling
    switch (type) {
        case 'success':
            alertDiv.style.backgroundColor = '#d4edda';
            alertDiv.style.color = '#155724';
            alertDiv.style.border = '1px solid #c3e6cb';
            break;
        case 'error':
            alertDiv.style.backgroundColor = '#f8d7da';
            alertDiv.style.color = '#721c24';
            alertDiv.style.border = '1px solid #f5c6cb';
            break;
        case 'info':
        default:
            alertDiv.style.backgroundColor = '#d1ecf1';
            alertDiv.style.color = '#0c5460';
            alertDiv.style.border = '1px solid #bee5eb';
            break;
    }

    document.body.appendChild(alertDiv);

    setTimeout(() => {
        alertDiv.style.opacity = '1';
        alertDiv.style.transform = 'translateX(-50%) translateY(0)';
    }, 10); 

    // Animate out and remove
    setTimeout(() => {
        alertDiv.style.opacity = '0';
        alertDiv.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => {
            alertDiv.remove();
        }, 500); 
    }, duration);
}

export function getUserData() {
    if (typeof AuthManager !== 'undefined' && AuthManager.getCurrentUser) {
        return AuthManager.getCurrentUser();
    }
    return null;
}

/**
 * Toggles visibility of a password input field when eye icon is clicked.
 * @param {HTMLElement} iconElement 
 */
export function togglePassword(iconElement) {
    const wrapper = iconElement.closest('.password-wrapper, .input-group');
    if (!wrapper) return;

    const input = wrapper.querySelector('input[type="password"], input[type="text"]');
    if (!input) return;

    const isPassword = input.getAttribute('type') === 'password';
    input.setAttribute('type', isPassword ? 'text' : 'password');

    iconElement.classList.toggle('fa-eye', !isPassword);
    iconElement.classList.toggle('fa-eye-slash', isPassword);
}

```

### frontend\public\js\admin\admin-api.js
```js
/**
 * admin-api.js
 * API functions for user management
 */

'use strict';

// API management functions
const AdminAPI = {
  async loadUsers() {
    showLoading(true);

    try {
      log('Starting to load users...');
      let response;
      let usersData = [];

      // Try main API endpoint
      try {
        response = await fetch(`${CONFIG.API_BASE_URL}/admin/users`);
        if (response.ok) {
          const data = await response.json();
          usersData = data.users || data.data || data;
        }
      } catch (err) {
        log('Admin endpoint failed, trying fallback', err, 'warn');
      }

      // Try fallback endpoint if main failed
      if (!usersData || usersData.length === 0) {
        try {
          const res = await fetch('/api/admin/users/mock');
          if (res.ok) {
            const mockData = await res.json();
            usersData = mockData.users || mockData.data || mockData;
            log('Loaded data from /api/admin/users/mock', { count: usersData.length });
            updateConnectionStatus('offline');
            showToast('Warning', 'Using mock data from server - database unavailable', 'warning', 4000);
          }
        } catch (err) {
          log('Mock endpoint also failed', err, 'error');
        }
      }

      // Validate data
      if (!usersData || usersData.length === 0) {
        showError('Failed to load users. Please check your database connection.');
        updateConnectionStatus('offline');
        return;
      }

      // Normalize data
      const normalizedUsers = this.normalizeUsersData(usersData);

      // Update state
      AdminState.setUsers(normalizedUsers);
      updateStatistics();
      renderUserTable();
      updateConnectionStatus('online');
      
      showToast('Success', `Loaded ${normalizedUsers.length} users`, 'success', 2000);
      log('Users loaded successfully', { count: normalizedUsers.length });
      
    } catch (err) {
      log('Error loading users', err, 'error');
      showError('Failed to load users. Please check your database connection.');
      updateConnectionStatus('offline');
    } finally {
      showLoading(false);
    }
  },

  // Normalize user data from different API formats
  normalizeUsersData(usersData) {
    
    return usersData.map((user, idx) => ({
        id: Number(user.UserID ?? user.id ?? (idx + 1)),
        username: user.Username || user.username || `user${idx + 1}`,
        fullName: user.FullName || user.fullName || user.name || 'Unknown User',
        email: user.Email || user.email || `user${idx + 1}@example.com`,
        phone: user.Phone || user.phone || '',
        role: (user.UserRole || user.role || 'user').toLowerCase(),
        accountType: user.AccountType || user.accountType || (user.isPremium ? 'plus' : 'free'),
        status: user.UserStatus || user.status || (user.isActive ? 'active' : 'inactive'),
        createdAt: user.CreatedAt || user.createdAt || new Date().toISOString(),
        updatedAt: user.UpdatedAt || user.updatedAt || null,
        
        _debugUpdatedAt: user.UpdatedAt,
        _debugupdatedAt: user.updatedAt
    }));
},

  // Create new user
  async createUser(userData) {
    try {
      log('Creating new user', userData);
      
      let response;
      try {
        response = await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/register`, {
          method: 'POST',
          body: JSON.stringify(userData)
        });
      } catch (error) {
        log('Authenticated create failed, trying alternative', error, 'warn');
        response = await makeAPICall('/users', 'POST', userData);
      }
      
      // Format the new user data
      const newUser = response.user || response.data || response;
      const formattedUser = {
        id: newUser.UserID || newUser.id || Date.now(),
        username: newUser.Username || newUser.username || userData.username,
        fullName: newUser.FullName || newUser.fullName || userData.fullName,
        email: newUser.Email || newUser.email || userData.email,
        phone: newUser.Phone || newUser.phone || userData.phone || '',
        role: newUser.UserRole || newUser.role || userData.role || 'user',
        accountType: newUser.AccountType || newUser.accountType || userData.accountType || 'free',
        status: newUser.UserStatus || newUser.status || userData.status || 'active',
        createdAt: newUser.CreatedAt || newUser.createdAt || new Date().toISOString()
      };
      
      // Add to state
      AdminState.addUser(formattedUser);
      updateStatistics();
      renderUserTable();
      
      showToast('Success', `User "${userData.username}" created successfully`, 'success');
      log('User created successfully', formattedUser);
      
      return formattedUser;
    } catch (error) {
      log('Error creating user', error, 'error');
      throw new Error('Failed to create user: ' + error.message);
    }
  },

  // Update existing user
async updateUser(userId, userData) {
  try {
    log('Starting user update', { userId, userData });
    
    const currentAdmin = AuthManager.getCurrentUser();
    if (!currentAdmin || currentAdmin.userRole !== 'admin') {
      throw new Error('Admin access required');
    }
    
    const currentUserData = AdminState.getUserById(userId);
    if (!currentUserData) {
      throw new Error('User not found in local data');
    }
    
    // Create detailed update payload
    const updatePayload = {
      username: userData.username || currentUserData.username,
      email: userData.email || currentUserData.email,
      phone: userData.phone !== undefined ? userData.phone : (currentUserData.phone || ''),
      fullName: userData.fullName || currentUserData.fullName
    };
    
    if (userData.hasOwnProperty('status')) {
      updatePayload.status = userData.status;
    } else {
      updatePayload.status = currentUserData.status;
    }
    
    if (userData.hasOwnProperty('accountType')) {
      updatePayload.accountType = userData.accountType;
    } else {
      updatePayload.accountType = currentUserData.accountType;
    }
    
    if (userData.hasOwnProperty('role')) {
      updatePayload.role = userData.role;
    } else {
      updatePayload.role = currentUserData.role;
    }
    
    // Add password only if provided
    if (userData.password && userData.password.trim()) {
      updatePayload.password = userData.password.trim();
    }
    
    log('Final update payload', updatePayload);
    
    let response;
    try {
      response = await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/admin/update/${userId}`, {
        method: 'PUT',
        body: JSON.stringify(updatePayload)
      });
    } catch (error) {
      log('Authenticated update failed, trying alternative', error, 'warn');
      response = await makeAPICall(`/users/${userId}`, 'PUT', updatePayload);
    }

    // Log response Ä‘á»ƒ debug
    log('API response received', response);
    
    if (response && response.user) {
      const apiUser = response.user;
      log('API returned user data', apiUser);
      
      const updatedUser = {
        id: Number(userId),
        username: apiUser.Username || apiUser.username,
        fullName: apiUser.FullName || apiUser.fullName,
        email: apiUser.Email || apiUser.email,
        phone: apiUser.Phone || apiUser.phone || '',
        role: (apiUser.UserRole || apiUser.role || 'user').toLowerCase(),
        accountType: apiUser.AccountType || apiUser.accountType || 'free',
        status: apiUser.UserStatus || apiUser.status || 'active',
        createdAt: apiUser.CreatedAt || apiUser.createdAt,
        updatedAt: apiUser.UpdatedAt || apiUser.updatedAt // Get from database
      };
      
      log('Using UpdatedAt from API response', updatedUser.updatedAt);
      
      // Update state and UI immediately
      AdminState.updateUser(userId, updatedUser);
      updateStatistics();
      renderUserTable();
      
      const changes = [];
      if (currentUserData.status !== updatedUser.status) {
        changes.push(`Status: ${currentUserData.status} â†’ ${updatedUser.status}`);
      }
      if (currentUserData.accountType !== updatedUser.accountType) {
        changes.push(`Account Type: ${currentUserData.accountType} â†’ ${updatedUser.accountType}`);
      }
      if (currentUserData.role !== updatedUser.role) {
        changes.push(`Role: ${currentUserData.role} â†’ ${updatedUser.role}`);
      }
      
      let message = `User "${updatedUser.username}" updated successfully`;
      if (changes.length > 0) {
        message += `\nChanges: ${changes.join(', ')}`;
      }
      
      showToast('Success', message, 'success', 4000);
      log('User update completed successfully', { updatedUser, changes });
      
      return updatedUser;
      
    } else {
      const updatedUser = {
        id: Number(userId),
        username: updatePayload.username,
        fullName: updatePayload.fullName,
        email: updatePayload.email,
        phone: updatePayload.phone,
        role: updatePayload.role,
        accountType: updatePayload.accountType,
        status: updatePayload.status,
        createdAt: currentUserData.createdAt,
        updatedAt: new Date().toISOString() 
      };
      
      // Update state and UI immediately
      AdminState.updateUser(userId, updatedUser);
      updateStatistics();
      renderUserTable();
      
      const changes = [];
      if (currentUserData.status !== updatedUser.status) {
        changes.push(`Status: ${currentUserData.status} â†’ ${updatedUser.status}`);
      }
      if (currentUserData.accountType !== updatedUser.accountType) {
        changes.push(`Account Type: ${currentUserData.accountType} â†’ ${updatedUser.accountType}`);
      }
      if (currentUserData.role !== updatedUser.role) {
        changes.push(`Role: ${currentUserData.role} â†’ ${updatedUser.role}`);
      }
      
      let message = `User "${updatedUser.username}" updated successfully`;
      if (changes.length > 0) {
        message += `\nChanges: ${changes.join(', ')}`;
      }
      
      showToast('Success', message, 'success', 4000);
      log('User update completed successfully (fallback mode)', { updatedUser, changes });
      
      return updatedUser;
    }
    
  } catch (error) {
    log('Error updating user', error, 'error');
    throw new Error('Failed to update user: ' + error.message);
  }
},

  // Delete user
  async deleteUser(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    if (!confirm(`Are you sure you want to delete user "${user.username}"?\n\nThis action cannot be undone.`)) {
      return;
    }
    
    showLoading(true);
    
    try {
      log('Deleting user', { userId, user });
      
      try {
        await makeAuthenticatedRequest(`${CONFIG.API_BASE_URL}/users/admin/delete/${userId}`, {
          method: 'DELETE'
        });
      } catch (error) {
        log('Authenticated delete failed, trying alternative', error, 'warn');
        await makeAPICall(`/users/${userId}`, 'DELETE');
      }
      
      // Remove user from state and update UI
      AdminState.removeUser(userId);
      updateStatistics();
      renderUserTable();
      
      showToast('Success', `User "${user.username}" deleted successfully`, 'success');
      log('User deleted successfully', { userId, username: user.username });
      
    } catch (error) {
      log('Delete error', error, 'error');
      showToast('Error', 'Failed to delete user: ' + error.message, 'error');
    } finally {
      showLoading(false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
async function loadUsers() {
  return AdminAPI.loadUsers();
}

async function createUser(userData) {
  return AdminAPI.createUser(userData);
}

async function updateUser(userId, userData) {
  return AdminAPI.updateUser(userId, userData);
}

async function deleteUser(userId) {
  return AdminAPI.deleteUser(userId);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminAPI = AdminAPI;
  window.loadUsers = loadUsers;
  window.createUser = createUser;
  window.updateUser = updateUser;
  window.deleteUser = deleteUser;
}
```

### frontend\public\js\admin\admin-auth.js
```js
'use strict';

// Authentication management
const AdminAuth = {
  validateAuthentication() {
    if (!AuthManager.canAccessAdminPanel()) {
      log('Admin access required', null, 'warn');
      showToast('Access Denied', 'Admin privileges required for this panel', 'error', 3000);
      setTimeout(() => {
        window.location.href = 'login.html';
      }, 3000);
      return false;
    }
    
    const userData = AuthManager.getCurrentUser();
    log('Admin authentication validated successfully', { 
      userRole: userData.userRole, 
      username: userData.username,
      isAdminPanel: isAdminPanel()
    });
    return true;
  },

  // Make authenticated API request
  async makeAuthenticatedRequest(url, options = {}) {
    const userData = AuthManager.getCurrentUser();
    
    if (!userData) {
      log('No user data available for authentication', null, 'error');
      throw new Error('Authentication required. Please login again.');
    }
    
    if (isAdminPanel() && userData.userRole !== 'admin') {
      log('Non-admin user trying to access admin functionality', userData, 'error');
      throw new Error('Admin privileges required for this operation.');
    }
    
    const defaultHeaders = {
      'Content-Type': 'application/json',
      'x-user-role': userData.userRole,
      'x-user-id': userData.userId || userData.id,
      'x-username': userData.username
    };
    
    // Add admin token if available
    const adminToken = localStorage.getItem('admin_token');
    if (adminToken) {
      defaultHeaders['Authorization'] = `Bearer ${adminToken}`;
    }
    
    const requestOptions = {
      ...options,
      headers: {
        ...defaultHeaders,
        ...options.headers
      }
    };
    
    log(`Making authenticated API request to: ${url}`, { 
      method: options.method || 'GET', 
      userRole: userData.userRole
    });
    
    try {
      const response = await fetch(url, requestOptions);
      const data = await response.json();
      
      log(`API response received`, { status: response.status, ok: response.ok });
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error(data.error || 'Access denied. Insufficient privileges.');
        }
        if (response.status === 401) {
          AuthManager.logout();
          localStorage.removeItem('admin_token');
          throw new Error('Authentication expired. Please login again.');
        }
        throw new Error(data.error || `API request failed with status ${response.status}`);
      }
      
      return data;
    } catch (networkError) {
      log('Network error in authenticated request', networkError, 'error');
      throw new Error(`Network error: ${networkError.message}`);
    }
  },

  loginUser(loginResponse) {
    try {
      const userData = {
        userId: loginResponse.userId || loginResponse.user?.id || loginResponse.id,
        username: loginResponse.username || loginResponse.user?.username,
        userRole: loginResponse.userRole || loginResponse.user?.role || loginResponse.role,
        email: loginResponse.email || loginResponse.user?.email,
        phone: loginResponse.phone || loginResponse.user?.phone || '',
        fullName: loginResponse.fullName || loginResponse.user?.fullName || loginResponse.name
      };
      
      if (!userData.userId || !userData.username || !userData.userRole) {
        throw new Error('Incomplete login data received');
      }
      
      const storedData = AuthManager.login(userData);
      
      log(`User logged in with role: ${userData.userRole}`, storedData);
      
      if (userData.userRole === 'admin') {
        window.location.href = 'admin.html';
      } else {
        window.location.href = 'dashboard.html';
      }
      
      return storedData;
    } catch (error) {
      log('Login failed', error, 'error');
      throw error;
    }
  },

  // Logout with proper cleanup
  logout() {
    const userData = AuthManager.getCurrentUser();
    
    if (!userData) {
      console.warn('No user to logout');
      window.location.href = 'login.html';
      return;
    }
    
    const userRole = userData.userRole || 'unknown';
    
    if (confirm(`Are you sure you want to logout?`)) {
      log(`${userRole} user logging out`);
      
      AuthManager.logout();
      localStorage.removeItem('admin_token');
      
      if (AppState?.autoRefreshTimer) {
        clearInterval(AppState.autoRefreshTimer);
      }
      
      showToast('Logging out', `${userRole} session ended. Goodbye!`, 'info', 1000);
      
      setTimeout(() => {
        window.location.href = 'login.html';
      }, 1000);
    }
  }
};

// Legacy API call function for backward compatibility
async function makeAPICall(endpoint, method = 'GET', data = null) {
  const config = {
    method,
    headers: {
      'Content-Type': 'application/json',
    }
  };
  
  const userData = AuthManager.getCurrentUser();
  if (userData) {
    config.headers['x-user-role'] = userData.userRole;
  }
  
  const token = localStorage.getItem('admin_token');
  if (token) {
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  
  if (data) {
    config.body = JSON.stringify(data);
  }
  
  try {
    log(`Making API call to: ${CONFIG.API_BASE_URL}${endpoint}`, { method, data });
    const response = await fetch(`${CONFIG.API_BASE_URL}${endpoint}`, config);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const responseData = await response.json();
    log(`API call successful`, responseData);
    return responseData;
  } catch (error) {
    log('API call failed', error, 'error');
    throw error;
  }
}

// Legacy wrapper functions for backward compatibility
function validateAuthentication() {
  return AdminAuth.validateAuthentication();
}

async function makeAuthenticatedRequest(url, options = {}) {
  return AdminAuth.makeAuthenticatedRequest(url, options);
}

function handleLogout() {
  AdminAuth.logout();
}

if (typeof window !== 'undefined') {
  window.AdminAuth = AdminAuth;
  window.validateAuthentication = validateAuthentication;
  window.makeAuthenticatedRequest = makeAuthenticatedRequest;
  window.makeAPICall = makeAPICall;
  window.handleLogout = handleLogout;
  window.loginUser = AdminAuth.loginUser;
  
  // Chá»‰ gá»i náº¿u function tá»“n táº¡i
  if (typeof AuthManager.setupLogoutSync === 'function') {
    AuthManager.setupLogoutSync();
  }
}
```

### frontend\public\js\admin\admin-config.js
```js
/**
 * admin-config.js
 * Configuration and constants for admin panel
 */

'use strict';

const CONFIG = {
  API_BASE_URL: window.location.origin + '/api',
  ADMIN_STORAGE_KEY: 'loggedInAs_admin',
  USER_STORAGE_KEY: 'loggedInAs_user', 
  DEBUG_MODE: true,
  AUTO_REFRESH_INTERVAL: 3000000, 
  NOTIFICATION_DURATION: 5000,
  SEARCH_DEBOUNCE_DELAY: 300
};

// Export for global access
if (typeof window !== 'undefined') {
  window.AdminConfig = CONFIG;
}
```

### frontend\public\js\admin\admin-dashboard.js
```js
// frontend/public/js/admin/dashboard.js
class DashboardManager {
    constructor() {
        this.charts = {};
        this.data = {};
        this.isLoading = false;
        this.currentUser = null;

        this.init();
    }

    async init() {
        console.log('Initializing admin dashboard...');

        this.updateConnectionStatus('connecting', 'Connecting to database...');

        // âœ… Kiá»ƒm tra quyá»n admin báº±ng AuthManager
        if (!this.checkAdminAuth()) {
            this.updateConnectionStatus('error', 'Authentication failed');
            window.location.href = '/login.html';
            return;
        }

        this.setupEventListeners();
        await this.loadDashboardData();
    }

    updateConnectionStatus(status, text) {
        const statusIndicator = document.getElementById('connectionStatus');
        const connectionText = document.getElementById('connectionText');

        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            switch (status) {
                case 'connecting':
                    statusIndicator.classList.add('status-loading'); break;
                case 'connected':
                    statusIndicator.classList.add('status-success'); break;
                case 'error':
                    statusIndicator.classList.add('status-error'); break;
            }
        }
        if (connectionText) connectionText.textContent = text;
    }

    /**
     * âœ… Kiá»ƒm tra quyá»n admin qua AuthManager
     */
    checkAdminAuth() {
        if (typeof AuthManager === 'undefined' || typeof AuthManager.getCurrentUser !== 'function') {
            console.error('AuthManager not found or invalid');
            return false;
        }

        const user = AuthManager.getCurrentUser();
        if (!user || user.userRole !== 'admin') {
            console.error('Access denied. Admin privileges required.');
            return false;
        }

        this.currentUser = user;
        console.log('âœ… Admin authenticated:', user);

        const nameEl = document.getElementById('adminUsername');
        if (nameEl) nameEl.textContent = user.username || 'Admin';

        return true;
    }

    setupEventListeners() {
        document.getElementById('backToAdminBtn')?.addEventListener('click', (e) => {
            e.preventDefault();
            window.location.href = '/admin.html';
        });

        document.getElementById('refreshDashboardBtn')?.addEventListener('click', (e) => {
            e.preventDefault();
            this.loadDashboardData();
        });

        document.getElementById('exportStatsBtn')?.addEventListener('click', (e) => {
            e.preventDefault();
            this.exportStatistics();
        });

        document.getElementById('timeframeSelect')?.addEventListener('change', (e) => {
            this.updateTimelineChart(e.target.value);
        });
    }

    async loadDashboardData() {
        if (this.isLoading) return;

        this.isLoading = true;
        this.showLoading(true);
        this.updateConnectionStatus('connecting', 'Loading data...');

        try {
            const [overview, accountTypes, languages, timeframe] = await Promise.all([
                this.fetchOverviewStats(),
                this.fetchAccountTypesStats(),
                this.fetchLanguageStats(),
                this.fetchTimeframeStats('day')
            ]);

            this.data = { overview, accountTypes, languages, timeframe };

            this.updateOverviewCards();
            this.updateCharts();
            this.updateConnectionStatus('connected', 'Connected to Database');

        } catch (err) {
            console.error('âŒ Error loading dashboard data:', err);
            this.updateConnectionStatus('error', 'Connection failed');
            this.showError(true);
            this.showToast('Error', 'Failed to load dashboard data: ' + err.message, 'error');
        } finally {
            this.isLoading = false;
            this.showLoading(false);
        }
    }

    /**
     * âœ… Fetch cÃ³ xÃ¡c thá»±c (dá»±a trÃªn AuthManager)
     */
    async fetchWithAuth(url, options = {}) {
        if (!this.currentUser) {
            throw new Error('Unauthorized: missing admin session');
        }

        const headers = {
            'Content-Type': 'application/json',
            'x-user-id': this.currentUser.userId?.toString() || '',
            'x-user-role': this.currentUser.userRole || 'admin',
            ...options.headers
        };

        const response = await fetch(url, { ...options, headers });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

        const json = await response.json();
        if (!json.success) throw new Error(json.error || 'API request failed');
        return json.data;
    }

    // === API LAYER ===
    async fetchOverviewStats() { return await this.fetchWithAuth('/api/stats/overview'); }
    async fetchAccountTypesStats() { return await this.fetchWithAuth('/api/stats/account-types'); }
    async fetchLanguageStats(days = 30) { return await this.fetchWithAuth(`/api/stats/languages?days=${days}`); }
    async fetchTimeframeStats(range = 'day') { return await this.fetchWithAuth(`/api/stats/timeframe?range=${range}&action=grammar_check`); }

    // === UI UPDATE ===
    updateOverviewCards() {
        const o = this.data.overview || {};
        document.getElementById('totalUsersCount').textContent = o.total_users || 0;
        document.getElementById('activeUsersCount').textContent = o.active_users || 0;

        const total = o.total_users || 0;
        const grammarChecks = Math.floor(total * 25);
        const todayChecks = Math.floor(grammarChecks * 0.1);

        document.getElementById('grammarChecksCount').textContent = grammarChecks;
        document.getElementById('todayChecksCount').textContent = todayChecks;
        document.getElementById('languagesCount').textContent = this.data.languages?.languages?.length || 0;
        document.getElementById('mostUsedLanguage').textContent = this.data.languages?.most_used?.language_name || 'N/A';
        document.getElementById('totalNotificationsCount').textContent = o.total_notifications || 0;
        document.getElementById('unreadNotificationsCount').textContent = o.unread_notifications || 0;
    }

    updateCharts() {
        this.updateAccountTypesChart();
        this.updateLanguagesChart();
        this.updateTimelineChart();
    }

    updateAccountTypesChart() {
        const canvas = document.getElementById('accountTypesChart');
        const data = this.data.accountTypes?.breakdown;
        if (!canvas || !data) return;

        if (this.charts.accountTypes) this.charts.accountTypes.destroy();

        const ctx = canvas.getContext('2d');
        this.charts.accountTypes = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: data.map(d => d.type),
                datasets: [{
                    data: data.map(d => d.count),
                    backgroundColor: ['#28a745', '#ffc107', '#17a2b8', '#dc3545'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: { responsive: true, plugins: { legend: { position: 'bottom' } } }
        });
    }

    updateLanguagesChart() {
        const canvas = document.getElementById('languagesChart');
        const langs = this.data.languages?.languages;
        if (!canvas || !langs) return;

        if (this.charts.languages) this.charts.languages.destroy();

        const ctx = canvas.getContext('2d');
        const topLangs = langs.slice(0, 6);

        this.charts.languages = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: topLangs.map(l => l.language_name),
                datasets: [{
                    label: 'Usage Count',
                    data: topLangs.map(l => l.usage_count),
                    backgroundColor: ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6f42c1']
                }]
            },
            options: { responsive: true, plugins: { legend: { display: false } } }
        });
    }

    updateTimelineChart(range = null) {
        const canvas = document.getElementById('timelineChart');
        if (!canvas) return;

        const timeframe = this.data.timeframe;
        if (range && range !== timeframe?.range) {
            this.fetchTimeframeStats(range).then(data => {
                this.data.timeframe = data;
                this.updateTimelineChart();
            });
            return;
        }

        if (!timeframe?.data) return;
        if (this.charts.timeline) this.charts.timeline.destroy();

        const ctx = canvas.getContext('2d');
        this.charts.timeline = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeframe.data.map(t => t.period),
                datasets: [{
                    label: 'Activities',
                    data: timeframe.data.map(t => t.count),
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: { responsive: true, plugins: { legend: { position: 'top' } } }
        });
    }

    async exportStatistics() {
        try {
            this.showExportLoading(true);
            const data = await this.fetchWithAuth('/api/stats/export');
            this.downloadAsExcel(data);
            this.showToast('Success', 'Statistics exported successfully', 'success');
        } catch (err) {
            this.showToast('Error', 'Error exporting statistics: ' + err.message, 'error');
        } finally {
            this.showExportLoading(false);
        }
    }

    downloadAsExcel(data) {
        let csv = "data:text/csv;charset=utf-8,";
        csv += "User ID,Username,Email,Role,Account Type,Status,Created At,Total Notifications,Unread Notifications\n";
        data.data.forEach(u => {
            csv += [
                u.user_id, u.username, u.email, u.role,
                u.account_type, u.status, u.created_at,
                u.notification_count, u.unread_notifications
            ].map(v => `"${v}"`).join(',') + '\n';
        });
        const uri = encodeURI(csv);
        const a = document.createElement('a');
        a.href = uri;
        a.download = `grammar_checker_stats_${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    showLoading(show) {
        document.getElementById('dashboardLoading')?.classList.toggle('hidden', !show);
        document.getElementById('dashboardError')?.classList.add('hidden');
    }

    showError(show) {
        document.getElementById('dashboardLoading')?.classList.add('hidden');
        document.getElementById('dashboardError')?.classList.toggle('hidden', !show);
    }

    showExportLoading(show) {
        const btn = document.getElementById('exportStatsBtn');
        if (!btn) return;
        btn.disabled = show;
        btn.innerHTML = show
            ? '<i class="fas fa-spinner fa-spin"></i> Exporting...'
            : '<i class="fas fa-download"></i> Export Excel';
    }

    showToast(title, msg, type = 'info', duration = 4000) {
        const container = document.getElementById('toastContainer');
        if (!container) return console.log(`${title}: ${msg}`);
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `<div class="toast-content"><strong>${title}</strong><p>${msg}</p></div>`;
        container.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
    }
}

// Initialize Dashboard
document.addEventListener('DOMContentLoaded', () => {
    if (!window.__dashboardInitialized) {
        window.__dashboardInitialized = true;
        new DashboardManager();
    }
});

```

### frontend\public\js\admin\admin-debug.js
```js
/**
 * admin-debug.js
 * Debug helpers and development tools
 */

'use strict';

// Debug management functions
const AdminDebug = {
  debugAuth() {
    console.log('=== Authentication Debug ===');
    console.log('Admin Storage Key:', CONFIG.ADMIN_STORAGE_KEY);
    console.log('User Storage Key:', CONFIG.USER_STORAGE_KEY);
    console.log('Raw Admin Storage:', localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY));
    console.log('Raw User Storage:', localStorage.getItem(CONFIG.USER_STORAGE_KEY));
    console.log('Admin Token:', localStorage.getItem('admin_token'));
    console.log('Parsed User Data:', getUserData());
    console.log('Is Admin Panel:', isAdminPanel());
    console.log('==============================');
  },

  // Debug storage state
  debugStorage() {
    console.log('=== Storage Debug ===');
    console.log('Is Admin Panel:', isAdminPanel());
    console.log('Admin Storage:', localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY));
    console.log('User Storage:', localStorage.getItem(CONFIG.USER_STORAGE_KEY));
    console.log('Current User:', getUserData());
    console.log('Storage Key Function Test:', getStorageKey('admin'), getStorageKey('user'));
    console.log('====================');
  },

  // Debug form state
  debugForm() {
    console.log('=== Form Debug ===');
    console.log('Edit Mode:', AppState.isEditMode);
    console.log('Editing User ID:', AppState.currentEditingUserId);
    
    if (AppState.currentEditingUserId) {
      const user = AdminState.getUserById(AppState.currentEditingUserId);
      console.log('User Being Edited:', user);
    }
    
    console.log('Form Elements:', {
      username: elements.username?.value,
      email: elements.email?.value,
      fullName: elements.fullName?.value,
      isActive: elements.isActive?.checked,
      isPlusAccount: elements.isPlusAccount?.checked,
      isAdmin: elements.isAdmin?.checked
    });
    
    try {
      console.log('Form Data:', getFormData());
    } catch (error) {
      console.log('Form Data Error:', error);
    }
    
    console.log('==================');
  },

  // Debug app state
  debugAppState() {
    console.log('=== App State Debug ===');
    console.log('All Users Count:', AppState.allUsers.length);
    console.log('Filtered Users Count:', AppState.filteredUsers.length);
    console.log('Edit Mode:', AppState.isEditMode);
    console.log('Current Editing User ID:', AppState.currentEditingUserId);
    console.log('Loading State:', AppState.isLoading);
    console.log('Debug Mode:', AppState.isDebugMode);
    console.log('Search Term:', elements.searchInput?.value);
    
    if (AppState.allUsers.length > 0) {
      console.log('First User Sample:', AppState.allUsers[0]);
      
      const stats = {
        total: AppState.allUsers.length,
        active: AppState.allUsers.filter(u => u.status === 'active').length,
        inactive: AppState.allUsers.filter(u => u.status === 'inactive').length,
        plus: AppState.allUsers.filter(u => u.accountType === 'plus').length,
        free: AppState.allUsers.filter(u => u.accountType === 'free').length,
        admin: AppState.allUsers.filter(u => u.role === 'admin').length
      };
      console.log('User Statistics:', stats);
    }
    
    console.log('========================');
  },

  // Clear all sessions
  clearAllSessions() {
    localStorage.removeItem(CONFIG.ADMIN_STORAGE_KEY);
    localStorage.removeItem(CONFIG.USER_STORAGE_KEY);
    localStorage.removeItem('admin_token');
    console.log('All sessions cleared');
    showToast('Debug', 'All sessions cleared', 'info', 2000);
  },

  // Test API endpoints
  async testAPIEndpoints() {
    console.log('=== API Endpoints Test ===');
    
    const endpoints = [
      { url: `${CONFIG.API_BASE_URL}/admin/users`, method: 'GET', description: 'Load Users' },
      { url: `${CONFIG.API_BASE_URL}/users/register`, method: 'POST', description: 'Create User' },
      { url: `${CONFIG.API_BASE_URL}/users/admin/update/1`, method: 'PUT', description: 'Update User' },
      { url: `${CONFIG.API_BASE_URL}/users/admin/delete/1`, method: 'DELETE', description: 'Delete User' }
    ];
    
    for (const endpoint of endpoints) {
      try {
        console.log(`Testing ${endpoint.description}...`);
        const response = await fetch(endpoint.url, {
          method: endpoint.method,
          headers: { 'Content-Type': 'application/json' }
        });
        console.log(`${endpoint.description}:`, response.status, response.statusText);
      } catch (error) {
        console.log(`${endpoint.description} Error:`, error.message);
      }
    }
    
    console.log('=============================');
  },

  // Performance monitoring
  startPerformanceMonitoring() {
    const originalFetch = window.fetch;
    let requestCount = 0;
    let totalTime = 0;
    
    window.fetch = function(...args) {
      const startTime = performance.now();
      requestCount++;
      
      console.log(`[API Request #${requestCount}]`, args[0]);
      
      return originalFetch.apply(this, args)
        .then(response => {
          const endTime = performance.now();
          const duration = endTime - startTime;
          totalTime += duration;
          
          console.log(`[API Response #${requestCount}]`, {
            status: response.status,
            duration: `${duration.toFixed(2)}ms`,
            avgDuration: `${(totalTime / requestCount).toFixed(2)}ms`
          });
          
          return response;
        })
        .catch(error => {
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          console.log(`[API Error #${requestCount}]`, {
            error: error.message,
            duration: `${duration.toFixed(2)}ms`
          });
          
          throw error;
        });
    };
    
    console.log('Performance monitoring started');
    showToast('Debug', 'Performance monitoring started', 'info', 2000);
  },

  // Export debug data
  exportDebugData() {
    const debugData = {
      timestamp: new Date().toISOString(),
      appState: {
        allUsers: AppState.allUsers.length,
        filteredUsers: AppState.filteredUsers.length,
        isEditMode: AppState.isEditMode,
        currentEditingUserId: AppState.currentEditingUserId,
        isLoading: AppState.isLoading,
        isDebugMode: AppState.isDebugMode
      },
      storage: {
        adminStorage: localStorage.getItem(CONFIG.ADMIN_STORAGE_KEY),
        userStorage: localStorage.getItem(CONFIG.USER_STORAGE_KEY),
        adminToken: localStorage.getItem('admin_token')
      },
      config: CONFIG,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    const dataStr = JSON.stringify(debugData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `admin-debug-${new Date().toISOString().slice(0, 19)}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('Debug data exported');
    showToast('Debug', 'Debug data exported to file', 'success', 2000);
  }
};

// Global debug functions for easy access in console
function debugAuth() {
  AdminDebug.debugAuth();
}

function debugStorage() {
  AdminDebug.debugStorage();
}

function debugForm() {
  AdminDebug.debugForm();
}

function debugAppState() {
  AdminDebug.debugAppState();
}

function clearAllSessions() {
  AdminDebug.clearAllSessions();
}

function setTempAdminData() {
  return AdminDebug.setTempAdminData();
}

// Global exports and console helpers
if (typeof window !== 'undefined') {
  window.AdminDebug = AdminDebug;
  window.debugAuth = debugAuth;
  window.debugStorage = debugStorage;
  window.debugForm = debugForm;
  window.debugAppState = debugAppState;
  window.clearAllSessions = clearAllSessions;
  window.setTempAdminData = setTempAdminData;
  
  // Quick debug shortcuts
  window.d = {
    auth: debugAuth,
    storage: debugStorage,
    form: debugForm,
    state: debugAppState,
    clear: clearAllSessions,
    temp: setTempAdminData,
    export: () => AdminDebug.exportDebugData(),
    api: () => AdminDebug.testAPIEndpoints(),
    perf: () => AdminDebug.startPerformanceMonitoring()
  };
  
  console.log('Debug helpers loaded. Use window.d for shortcuts:', window.d);
}
```

### frontend\public\js\admin\admin-events.js
```js
/**
 * admin-events.js
 * Event handlers and listeners
 */

'use strict';

// Event management functions
const AdminEvents = {
  initializeEventListeners() {
    if (elements.logoutBtn) {
      elements.logoutBtn.addEventListener('click', handleLogout);
    }
    
    if (elements.searchInput) {
      elements.searchInput.addEventListener('input', this.handleSearch);
    }
    if (elements.refreshBtn) {
      elements.refreshBtn.addEventListener('click', refreshUsers);
    }
    if (elements.debugBtn) {
      elements.debugBtn.addEventListener('click', toggleDebug);
    }
    
    if (elements.addUserBtn) {
      elements.addUserBtn.addEventListener('click', showAddUserModal);
    }
    if (elements.cancelBtn) {
      elements.cancelBtn.addEventListener('click', hideUserModal);
    }
    if (elements.userForm) {
      elements.userForm.addEventListener('submit', handleFormSubmit);
    }
    
    if (elements.quickToggleCancelBtn) {
      elements.quickToggleCancelBtn.addEventListener('click', hideQuickToggleModal);
    }
    if (elements.quickToggleConfirmBtn) {
      elements.quickToggleConfirmBtn.addEventListener('click', handleQuickToggleConfirm);
    }
    
    this.setupModalCloseEvents();
    this.setupToastEvents();
    this.setupFormValidationEvents();
    this.setupCheckboxEvents();
    this.setupKeyboardShortcuts();
    monitorStorageChanges();
    
    log('Event listeners initialized successfully');
  },

  // Setup table event listeners
  setupTableEventListeners() {
    if (!elements.userTableBody) return;
    
    elements.userTableBody.removeEventListener('click', this.handleTableClick);
    elements.userTableBody.addEventListener('click', this.handleTableClick);
  },

  handleTableClick(e) {
    const btn = e.target.closest('button');
    if (!btn) return;

    const userId = Number(btn.dataset?.userId || btn.closest('tr')?.dataset?.userId);
    if (!userId || Number.isNaN(userId)) return;

    e.preventDefault();
    e.stopPropagation();

    if (btn.classList.contains('action-edit')) {
      showEditUserModal(userId);
    } else if (btn.classList.contains('action-delete')) {
      deleteUser(userId);
    }
  },

  // Handle search input
  handleSearch() {
    if (!elements.searchInput) return;
    
    if (AppState.searchTimeout) {
      clearTimeout(AppState.searchTimeout);
    }
    
    // Debounce search
    AppState.searchTimeout = setTimeout(() => {
      const searchTerm = elements.searchInput.value.toLowerCase().trim();
      
      AdminState.filterUsers(searchTerm);
      renderUserTable();
      
      if (searchTerm && AppState.filteredUsers.length !== AppState.allUsers.length) {
        showToast('Search Results', `Found ${AppState.filteredUsers.length} of ${AppState.allUsers.length} users`, 'info', 2000);
      }
      
      log(`Search performed: "${searchTerm}", showing ${AppState.filteredUsers.length}/${AppState.allUsers.length} users`);
    }, CONFIG.SEARCH_DEBOUNCE_DELAY);
  },

  // Setup modal close events
  setupModalCloseEvents() {
    if (elements.userModal) {
      elements.userModal.addEventListener('click', function(e) {
        if (e.target === elements.userModal) {
          hideUserModal();
        }
      });
    }
    
    if (elements.quickToggleModal) {
      elements.quickToggleModal.addEventListener('click', function(e) {
        if (e.target === elements.quickToggleModal) {
          hideQuickToggleModal();
        }
      });
    }
  },

  // Setup toast events
  setupToastEvents() {
    if (elements.toastContainer) {
      elements.toastContainer.addEventListener('click', function(e) {
        if (e.target.classList.contains('toast-close')) {
          const toastId = e.target.closest('.toast').id;
          removeToast(toastId);
        }
      });
    }
  },

  // Setup form validation events
  setupFormValidationEvents() {
    if (elements.username) {
      elements.username.addEventListener('blur', validateUsername);
    }
    if (elements.email) {
      elements.email.addEventListener('blur', validateEmail);
    }
    if (elements.fullName) {
      elements.fullName.addEventListener('blur', validateFullName);
    }
    if (elements.password) {
      elements.password.addEventListener('input', validatePassword);
    }
  },

  // Setup checkbox events
  setupCheckboxEvents() {
    if (elements.isActive) {
      elements.isActive.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
      });
    }
    
    if (elements.isPlusAccount) {
      elements.isPlusAccount.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
        
        if (elements.isPlusAccount.checked) {
          showToast('Plus Account', 'User will get premium features access', 'warning', 3000);
        }
      });
    }
    
    if (elements.isAdmin) {
      elements.isAdmin.addEventListener('change', function() {
        this.parentElement.style.transform = 'scale(1.02)';
        setTimeout(() => {
          if (this.parentElement) {
            this.parentElement.style.transform = '';
          }
        }, 200);
        
        if (elements.isAdmin.checked) {
          showToast('Admin Role', 'User will get full admin panel access', 'warning', 3000);
        }
      });
    }
  },

  // Setup keyboard shortcuts
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
      // Ctrl/Cmd + K: Focus search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        if (elements.searchInput) {
          elements.searchInput.focus();
          elements.searchInput.select();
        }
      }
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        showAddUserModal();
      }
      
      if (e.key === 'Escape') {
        if (elements.userModal?.classList.contains('show')) {
          hideUserModal();
        }
        if (elements.quickToggleModal?.classList.contains('show')) {
          hideQuickToggleModal();
        }
      }
      
      // Ctrl/Cmd + R: Refresh users
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        refreshUsers();
      }
    });
    
    log('Keyboard shortcuts setup completed');
  }
};

document.addEventListener('DOMContentLoaded', function() {
    
    const dashboardBtn = document.getElementById('dashboardBtn');
    if (dashboardBtn) {
        dashboardBtn.addEventListener('click', function(e) {
            console.log('Dashboard button clicked - redirecting...');
            e.preventDefault();
            e.stopPropagation();
            window.location.href = 'admin-dashboard.html';
        });
    } else {
        console.error('Dashboard button not found in DOM');
    }
});

setTimeout(function() {
    const dashboardBtn = document.getElementById('dashboardBtn');
    if (dashboardBtn && !dashboardBtn.hasAttribute('data-listener-added')) {
        dashboardBtn.setAttribute('data-listener-added', 'true');
        dashboardBtn.addEventListener('click', function(e) {
            console.log('Backup dashboard listener triggered');
            e.preventDefault();
            window.location.href = 'admin-dashboard.html';
        });
    }
}, 300000);

// Legacy wrapper functions for backward compatibility
function initializeEventListeners() {
  AdminEvents.initializeEventListeners();
}

function setupTableEventListeners() {
  AdminEvents.setupTableEventListeners();
}

function handleTableClick(e) {
  AdminEvents.handleTableClick(e);
}

function handleSearch() {
  AdminEvents.handleSearch();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminEvents = AdminEvents;
  window.initializeEventListeners = initializeEventListeners;
  window.setupTableEventListeners = setupTableEventListeners;
  window.handleTableClick = handleTableClick;
  window.handleSearch = handleSearch;
}
```

### frontend\public\js\admin\admin-forms.js
```js
/**
 * admin-forms.js
 * Form handling and validation functions
 */

'use strict';

// Form management functions
const AdminForms = {
  getFormData() {
    const data = {
      username: elements.username?.value?.trim() || '',
      email: elements.email?.value?.trim() || '',
      phone: elements.phone?.value?.trim() || '',
      fullName: elements.fullName?.value?.trim() || ''
    };

    if (elements.password?.value && elements.password.value.trim()) {
      data.password = elements.password.value.trim();
    }

    if (AppState.isEditMode && AppState.currentEditingUserId) {
      const isActiveEl = document.getElementById('isActive');
      const isPlusEl = document.getElementById('isPlusAccount'); 
      const isAdminEl = document.getElementById('isAdmin');
      
      data.status = isActiveEl && isActiveEl.checked ? 'active' : 'inactive';
      data.accountType = isPlusEl && isPlusEl.checked ? 'plus' : 'free';
      data.role = isAdminEl && isAdminEl.checked ? 'admin' : 'user';
      
      log('Edit mode form data extracted', {
        formData: data,
        checkboxElements: {
          isActive: isActiveEl?.checked,
          isPlusAccount: isPlusEl?.checked,
          isAdmin: isAdminEl?.checked
        },
        editingUserId: AppState.currentEditingUserId
      });
    } else {
      data.status = 'active';
      data.accountType = 'free';
      data.role = 'user';
      
      log('Add mode form data extracted', data);
    }

    return data;
  },

  // Populate form fields with user data
  populateFormFields(user) {
    if (elements.editUserId) elements.editUserId.value = user.id;
    if (elements.username) elements.username.value = user.username || '';
    if (elements.email) elements.email.value = user.email || '';
    if (elements.phone) elements.phone.value = user.phone || '';
    if (elements.fullName) elements.fullName.value = user.fullName || '';
    if (elements.password) elements.password.value = '';
    if (elements.isActive) {
      elements.isActive.checked = (user.status === 'active');
      log('Set isActive checkbox', { userStatus: user.status, checked: elements.isActive.checked });
    }
    
    if (elements.isPlusAccount) {
      elements.isPlusAccount.checked = (user.accountType === 'plus');
      log('Set isPlusAccount checkbox', { userAccountType: user.accountType, checked: elements.isPlusAccount.checked });
    }
    
    if (elements.isAdmin) {
      elements.isAdmin.checked = (user.role === 'admin');
      log('Set isAdmin checkbox', { userRole: user.role, checked: elements.isAdmin.checked });
    }
    
    log('Form fields populated', {
      user: user,
      checkboxStates: {
        isActive: elements.isActive?.checked,
        isPlusAccount: elements.isPlusAccount?.checked,
        isAdmin: elements.isAdmin?.checked
      }
    });
  },

  // Validate entire form
  validateForm() {
    let isValid = true;
    
    isValid = this.validateUsername() && isValid;
    isValid = this.validateEmail() && isValid;
    isValid = this.validateFullName() && isValid;
    
    if (!AppState.isEditMode) {
      isValid = this.validatePassword() && isValid;
    }
    
    return isValid;
  },

  // Validate username field
  validateUsername() {
    if (!elements.username) return true;
    
    const username = elements.username.value.trim();
    
    if (!username) {
      this.showFieldError('username', 'Username is required');
      return false;
    }
    
    if (username.length < 3) {
      this.showFieldError('username', 'Username must be at least 3 characters');
      return false;
    }
    
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      this.showFieldError('username', 'Username can only contain letters, numbers, and underscores');
      return false;
    }
    
    const existingUser = AppState.allUsers.find(u => 
      u.username.toLowerCase() === username.toLowerCase() && 
      (!AppState.isEditMode || Number(u.id) !== Number(AppState.currentEditingUserId))
    );
    
    if (existingUser) {
      this.showFieldError('username', 'Username already exists');
      return false;
    }
    
    this.clearFieldError('username');
    return true;
  },

  // Validate email field
  validateEmail() {
    if (!elements.email) return true;
    
    const email = elements.email.value.trim();
    
    if (!email) {
      this.showFieldError('email', 'Email is required');
      return false;
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      this.showFieldError('email', 'Please enter a valid email address');
      return false;
    }
    
    const existingUser = AppState.allUsers.find(u => 
      u.email.toLowerCase() === email.toLowerCase() && 
      (!AppState.isEditMode || Number(u.id) !== Number(AppState.currentEditingUserId))
    );
    
    if (existingUser) {
      this.showFieldError('email', 'Email already exists');
      return false;
    }
    
    this.clearFieldError('email');
    return true;
  },

  // Validate full name field
  validateFullName() {
    if (!elements.fullName) return true;
    
    const fullName = elements.fullName.value.trim();
    
    if (!fullName) {
      this.showFieldError('fullName', 'Full name is required');
      return false;
    }
    
    if (fullName.length < 2) {
      this.showFieldError('fullName', 'Full name must be at least 2 characters');
      return false;
    }
    
    this.clearFieldError('fullName');
    return true;
  },

  // Validate password field
  validatePassword() {
    if (!elements.password) return true;
    
    const password = elements.password.value;
    
    if (!AppState.isEditMode && !password) {
      this.showFieldError('password', 'Password is required');
      return false;
    }
    
    if (password && password.length < 6) {
      this.showFieldError('password', 'Password must be at least 6 characters');
      return false;
    }
    
    this.clearFieldError('password');
    return true;
  },

  // Show field validation error
  showFieldError(fieldName, message) {
    const errorElement = document.getElementById(fieldName + 'Error');
    const inputElement = elements[fieldName];
    
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.color = '#dc3545';
      errorElement.style.fontSize = '12px';
      errorElement.style.fontWeight = '500';
    }
    
    if (inputElement) {
      inputElement.classList.add('has-error');
      inputElement.style.borderColor = '#667eea';
      inputElement.style.boxShadow = 'none';
      inputElement.style.transform = 'none';
      
      // Add shake animation
      inputElement.style.animation = 'shake 0.3s ease-in-out';
      setTimeout(() => {
        if (inputElement) inputElement.style.animation = '';
      }, 300);
    }
  },

  // Clear field validation error
  clearFieldError(fieldName) {
    const errorElement = document.getElementById(fieldName + 'Error');
    const inputElement = elements[fieldName];
    
    if (errorElement) errorElement.textContent = '';
    
    if (inputElement) {
      inputElement.classList.remove('has-error');
      inputElement.style.borderColor = '#667eea';
      inputElement.style.boxShadow = 'none';
      inputElement.style.transform = 'none';
    }
  },

  // Clear all validation errors
  clearValidationErrors() {
    const errorFields = ['username', 'email', 'fullName', 'password'];
    errorFields.forEach(field => this.clearFieldError(field));
    
    const formError = document.getElementById('formError');
    if (formError) formError.textContent = '';
  },

  // Handle form submission
  async handleFormSubmit(e) {
    e.preventDefault();
    
    if (!this.validateForm()) {
      showToast('Validation Error', 'Please fix the errors below', 'error');
      return;
    }
    
    showButtonLoading(elements.saveBtn, elements.saveBtnText, elements.saveBtnLoader, true);
    
    try {
      const formData = this.getFormData();
      
      if (AppState.isEditMode && AppState.currentEditingUserId) {
        // Update existing user - DO NOT reload after update
        await updateUser(AppState.currentEditingUserId, formData);
      } else {
        // Create new user - reload to get fresh data from server
        await createUser(formData);
        await loadUsers();
      }
      
      hideUserModal();
      
    } catch (error) {
      log('Form submission error', error, 'error');
      showToast('Error', error.message || 'Operation failed', 'error');
    } finally {
      showButtonLoading(elements.saveBtn, elements.saveBtnText, elements.saveBtnLoader, false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
function getFormData() {
  return AdminForms.getFormData();
}

function populateFormFields(user) {
  return AdminForms.populateFormFields(user);
}

function validateForm() {
  return AdminForms.validateForm();
}

function validateUsername() {
  return AdminForms.validateUsername();
}

function validateEmail() {
  return AdminForms.validateEmail();
}

function validateFullName() {
  return AdminForms.validateFullName();
}

function validatePassword() {
  return AdminForms.validatePassword();
}

function showFieldError(fieldName, message) {
  return AdminForms.showFieldError(fieldName, message);
}

function clearFieldError(fieldName) {
  return AdminForms.clearFieldError(fieldName);
}

function clearValidationErrors() {
  return AdminForms.clearValidationErrors();
}

async function handleFormSubmit(e) {
  return AdminForms.handleFormSubmit(e);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminForms = AdminForms;
  window.getFormData = getFormData;
  window.populateFormFields = populateFormFields;
  window.validateForm = validateForm;
  window.validateUsername = validateUsername;
  window.validateEmail = validateEmail;
  window.validateFullName = validateFullName;
  window.validatePassword = validatePassword;
  window.showFieldError = showFieldError;
  window.clearFieldError = clearFieldError;
  window.clearValidationErrors = clearValidationErrors;
  window.handleFormSubmit = handleFormSubmit;
}
```

### frontend\public\js\admin\admin-main.js
```js
'use strict';

// Main admin panel initialization
const AdminMain = {
  async init() {
    try {
      log('Initializing Enhanced Admin Panel v8.0.0 (Complete Modular System)...');
      
      if (!validateAuthentication()) {
        return;
      }
      
      initializeElements();
      initializeEventListeners();
      setupInputFixes();
      setupPasswordToggle();
      
      const userData = AuthManager.getCurrentUser();
      if (userData && elements.adminUsername) {
        elements.adminUsername.textContent = userData.username || 'admin';
      }
      
      await loadUsers();
      if (userData) {
        showToast('Admin Panel Ready', `Welcome ${userData.username}! Complete modular system loaded.`, 'success', 3000);
      }
      
      this.setupAutoRefresh();
      
      log('Enhanced admin panel initialization complete');
      
    } catch (error) {
      log('Initialization failed', error, 'error');
      showError('Initialization failed: ' + error.message);
    }
  },

  setupDevelopmentMode() {
    if (CONFIG.DEBUG_MODE) {
      console.log('ğŸ› ï¸ Development Mode Enabled');
      console.log('Debug commands:', {
        'd.auth()': 'Debug authentication',
        'd.storage()': 'Debug localStorage',
        'd.form()': 'Debug form state',
        'd.state()': 'Debug app state',
        'd.clear()': 'Clear all sessions',
        'd.temp()': 'Set temp admin data',
        'd.export()': 'Export debug data',
        'd.api()': 'Test API endpoints',
        'd.perf()': 'Monitor performance'
      });
    }
  },
  
  // Setup auto-refresh functionality
  setupAutoRefresh() {
    if (CONFIG.AUTO_REFRESH_INTERVAL > 0) {
      AppState.autoRefreshTimer = setInterval(() => {
        if (!AppState.isEditMode && !AppState.isLoading) {
          log('Auto-refresh triggered');
          loadUsers();
        }
      }, CONFIG.AUTO_REFRESH_INTERVAL);
      
      log(`Auto-refresh setup: every ${CONFIG.AUTO_REFRESH_INTERVAL / 1000} seconds`);
    }
  },

  // Add CSS animations
  addCSSAnimations() {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-10px); }
      }
      
      @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .modal.show {
        animation: fadeIn 0.3s ease-out;
      }
      
      .toast {
        animation: fadeIn 0.3s ease-out;
      }
      
      .loading-spinner .spinner {
        animation: spin 1s linear infinite;
      }
      
      .btn:hover {
        transform: translateY(-1px);
        transition: transform 0.2s ease;
      }
      
      .btn:active {
        transform: translateY(0);
      }
    `;
    document.head.appendChild(style);
    log('CSS animations added');
  },

  setupLegacyGlobals() {
    window.AdminPanel = {
      init: this.init.bind(this),
      loadUsers,
      showAddUserModal,
      showEditUserModal,
      deleteUser,
      toggleDebug,
      handleLogout,
      exportUsers,
      log,
      AppState,
      CONFIG,
      AdminAPI,
      AdminAuth,
      AdminUI,
      AdminForms,
      AdminModals,
      AdminEvents,
      AdminDebug,
      AdminStorage
    };
    
    log('Legacy globals setup for backward compatibility');
  },

  cleanup() {
    if (AppState.autoRefreshTimer) {
      clearInterval(AppState.autoRefreshTimer);
      AppState.autoRefreshTimer = null;
    }
    
    if (AppState.searchTimeout) {
      clearTimeout(AppState.searchTimeout);
      AppState.searchTimeout = null;
    }
    
    log('Admin panel cleanup completed');
  },
};

function initializeAdminPanel() {
  if (typeof AuthManager === 'undefined') {
    console.error('âŒ CRITICAL: AuthManager not loaded! Cannot initialize admin panel.');
    alert('Authentication system failed to load. Please refresh the page.');
    return;
  }
  
  AdminMain.addCSSAnimations();
  AdminMain.setupLegacyGlobals();
  AdminMain.setupDevelopmentMode();
  AdminMain.init();
  window.addEventListener('beforeunload', AdminMain.cleanup);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAdminPanel);
} else {
  initializeAdminPanel();
}

if (typeof window !== 'undefined') {
  window.AdminMain = AdminMain;
}

log('Admin panel main script loaded successfully', { 
  version: '8.0.0', 
  features: [
    'Complete Modular Architecture',
    'Separate Storage Keys', 
    'Immediate UI Updates',
    'No Function Conflicts',
    'Enhanced Error Handling',
    'Debug Tools',
    'Development Helpers'
  ],
  timestamp: new Date().toISOString() 
});
```

### frontend\public\js\admin\admin-modals.js
```js
/**
 * admin-modals.js
 * Modal management functions
 */

'use strict';

// Modal management functions
const AdminModals = {
  showAddUserModal() {
    this.resetModalState();
    
    if (elements.modalTitle) elements.modalTitle.textContent = 'Add New User';
    if (elements.saveBtnText) elements.saveBtnText.textContent = 'Create User';
    if (elements.passwordRequired) elements.passwordRequired.style.display = 'inline';
    if (elements.passwordHint) elements.passwordHint.style.display = 'none';
    if (elements.accountSettings) elements.accountSettings.style.display = 'none';
    
    this.showModal();
    log('Add user modal opened');
  },

  // Show edit user modal
  showEditUserModal(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    this.resetModalState();
    AdminState.setEditMode(userId);
    
    // Update modal UI
    if (elements.modalTitle) elements.modalTitle.textContent = 'Edit User';
    if (elements.saveBtnText) elements.saveBtnText.textContent = 'Update User';
    if (elements.passwordRequired) elements.passwordRequired.style.display = 'none';
    if (elements.passwordHint) elements.passwordHint.style.display = 'block';
    if (elements.accountSettings) elements.accountSettings.style.display = 'block';
    if (elements.roleSelection) elements.roleSelection.style.display = 'block';
    
    // Populate form fields
    populateFormFields(user);
    
    this.showModal();
    log('Edit user modal opened', { userId, user });
  },

  // Show modal
  showModal() {
    if (elements.userForm) elements.userForm.reset();
    
    // Populate form if in edit mode
    if (AppState.isEditMode && AppState.currentEditingUserId) {
      const user = AdminState.getUserById(AppState.currentEditingUserId);
      if (user) populateFormFields(user);
    }
    
    clearValidationErrors();
    
    if (elements.userModal) elements.userModal.classList.add('show');
    
    // Apply styling fixes
    setTimeout(() => {
      fixInputStyling();
      if (elements.username) elements.username.focus();
    }, 100);
  },

  // Hide user modal
  hideUserModal() {
    if (elements.userModal) elements.userModal.classList.remove('show');
    this.resetModalState();
    setTimeout(fixInputStyling, 100);
  },

  resetModalState() {
    AdminState.clearEditMode();
    
    if (elements.userForm) {
      elements.userForm.reset();
      const inputs = elements.userForm.querySelectorAll('input, select');
      inputs.forEach(input => {
        input.style.borderColor = '#e9ecef';
        input.style.boxShadow = 'none';
        input.classList.remove('error', 'success');
      });
    }
    clearValidationErrors();
  },

  // Show quick toggle modal
  showQuickToggle(userId) {
    const user = AdminState.getUserById(userId);
    if (!user) {
      showToast('Error', 'User not found', 'error');
      return;
    }
    
    if (!elements.quickToggleModal) {
      console.error('Quick toggle modal not found');
      return;
    }
    
    AdminState.setEditMode(userId);
    if (elements.quickToggleUsername) {
      elements.quickToggleUsername.textContent = user.username;
    }
    
    const options = [
      {
        id: 'status',
        label: 'Account Status',
        current: user.status,
        new: user.status === 'active' ? 'inactive' : 'active'
      },
      {
        id: 'accountType',
        label: 'Account Type',
        current: user.accountType,
        new: user.accountType === 'free' ? 'plus' : 'free'
      }
    ];
    
    if (user.role !== 'admin') {
      options.push({
        id: 'role',
        label: 'User Role',
        current: user.role,
        new: user.role === 'user' ? 'admin' : 'user'
      });
    }
    
    if (elements.quickToggleOptions) {
      elements.quickToggleOptions.innerHTML = options.map(option => `
        <div class="quick-toggle-option" data-field="${option.id}">
          <div class="quick-toggle-label">${option.label}</div>
          <div class="quick-toggle-badges">
            <span class="quick-toggle-badge current">${option.current}</span>
            <span style="margin: 0 0.5rem;">â†’</span>
            <span class="quick-toggle-badge new">${option.new}</span>
          </div>
        </div>
      `).join('');
      
      elements.quickToggleOptions.querySelectorAll('.quick-toggle-option').forEach(option => {
        option.addEventListener('click', function() {
          this.classList.toggle('active');
        });
      });
    }
    
    elements.quickToggleModal.classList.add('show');
    log('Quick toggle modal opened', { userId, user });
  },

  // Hide quick toggle modal
  hideQuickToggleModal() {
    if (elements.quickToggleModal) {
      elements.quickToggleModal.classList.remove('show');
    }
    AdminState.clearEditMode();
  },

  // Handle quick toggle confirmation
  async handleQuickToggleConfirm() {
    if (!elements.quickToggleOptions) return;
    
    const selectedOptions = elements.quickToggleOptions.querySelectorAll('.quick-toggle-option.active');
    
    if (selectedOptions.length === 0) {
      showToast('No Changes', 'Please select at least one option to change', 'warning');
      return;
    }
    
    showButtonLoading(elements.quickToggleConfirmBtn, elements.quickToggleBtnText, elements.quickToggleBtnLoader, true);
    
    try {
      const currentUser = AdminState.getUserById(AppState.currentEditingUserId);
      const changes = {};
      
      selectedOptions.forEach(option => {
        const field = option.dataset.field;
        const newBadge = option.querySelector('.quick-toggle-badge.new');
        const newValue = newBadge.textContent;
        changes[field] = newValue;
      });
      
      await updateUser(AppState.currentEditingUserId, {
        ...currentUser,
        ...changes
      });
      
      this.hideQuickToggleModal();
      
    } catch (error) {
      log('Quick toggle error', error, 'error');
      showToast('Error', error.message || 'Update failed', 'error');
    } finally {
      showButtonLoading(elements.quickToggleConfirmBtn, elements.quickToggleBtnText, elements.quickToggleBtnLoader, false);
    }
  }
};

// Legacy wrapper functions for backward compatibility
function showAddUserModal() {
  AdminModals.showAddUserModal();
}

function showEditUserModal(userId) {
  AdminModals.showEditUserModal(userId);
}

function showModal() {
  AdminModals.showModal();
}

function hideUserModal() {
  AdminModals.hideUserModal();
}

function resetModalState() {
  AdminModals.resetModalState();
}

function showQuickToggle(userId) {
  AdminModals.showQuickToggle(userId);
}

function hideQuickToggleModal() {
  AdminModals.hideQuickToggleModal();
}

async function handleQuickToggleConfirm() {
  return AdminModals.handleQuickToggleConfirm();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminModals = AdminModals;
  window.showAddUserModal = showAddUserModal;
  window.showEditUserModal = showEditUserModal;
  window.showModal = showModal;
  window.hideUserModal = hideUserModal;
  window.resetModalState = resetModalState;
  window.showQuickToggle = showQuickToggle;
  window.hideQuickToggleModal = hideQuickToggleModal;
  window.handleQuickToggleConfirm = handleQuickToggleConfirm;
}
```

### frontend\public\js\admin\admin-state.js
```js
/**
 * admin-state.js
 * Application state management
 */

'use strict';

// Global application state
const AppState = {
  allUsers: [],
  filteredUsers: [],
  currentEditingUserId: null,
  isEditMode: false,
  isDebugMode: false,
  isLoading: false,
  autoRefreshTimer: null,
  searchTimeout: null,
  currentUser: null
};

// DOM elements cache
let elements = {};

const AdminState = {
  setUsers(users) {
    AppState.allUsers = users;
    AppState.filteredUsers = [...users];
  },

  addUser(user) {
    AppState.allUsers.push(user);
    AppState.filteredUsers = [...AppState.allUsers];
  },

  updateUser(userId, updatedUser) {
    const index = AppState.allUsers.findIndex(u => Number(u.id) === Number(userId));
    if (index >= 0) {
      AppState.allUsers[index] = updatedUser;
      AppState.filteredUsers = [...AppState.allUsers];
    }
  },

  removeUser(userId) {
    AppState.allUsers = AppState.allUsers.filter(u => Number(u.id) !== Number(userId));
    AppState.filteredUsers = [...AppState.allUsers];
  },

  filterUsers(searchTerm) {
    if (!searchTerm) {
      AppState.filteredUsers = [...AppState.allUsers];
    } else {
      AppState.filteredUsers = AppState.allUsers.filter(user =>
        user.username.toLowerCase().includes(searchTerm) ||
        user.fullName.toLowerCase().includes(searchTerm) ||
        user.email.toLowerCase().includes(searchTerm) ||
        (user.phone && user.phone.toLowerCase().includes(searchTerm))
      );
    }
  },

  getUserById(userId) {
    return AppState.allUsers.find(u => Number(u.id) === Number(userId));
  },

  // Edit mode management
  setEditMode(userId) {
    AppState.isEditMode = true;
    AppState.currentEditingUserId = userId;
  },

  clearEditMode() {
    AppState.isEditMode = false;
    AppState.currentEditingUserId = null;
  },

  // Loading state
  setLoading(isLoading) {
    AppState.isLoading = isLoading;
  },

  // Debug mode
  toggleDebug() {
    AppState.isDebugMode = !AppState.isDebugMode;
  }
};

// Export to global scope
if (typeof window !== 'undefined') {
  window.AppState = AppState;
  window.AdminState = AdminState;
  window.elements = elements;
}
```

### frontend\public\js\admin\admin-storage.js
```js
/**
 * admin-storage.js
 * Storage management with separate keys for admin and user
 */

'use strict';

// Storage management functions
const AdminStorage = {
  getStorageKey(userRole) {
    return userRole === 'admin' ? CONFIG.ADMIN_STORAGE_KEY : CONFIG.USER_STORAGE_KEY;
  },

  setUserData(userData) {
    try {
      const storageKey = this.getStorageKey(userData.userRole);
      const dataToStore = {
        userId: userData.userId || userData.user?.id || userData.id,
        username: userData.username || userData.user?.username,
        userRole: userData.userRole || userData.user?.role || userData.role,
        email: userData.email || userData.user?.email,
        phone: userData.phone || userData.user?.phone || '',
        fullName: userData.fullName || userData.user?.fullName || userData.name,
        loginTime: new Date().toISOString()
      };
      
      if (!dataToStore.userId || !dataToStore.username || !dataToStore.userRole) {
        throw new Error('Incomplete user data');
      }
      
      localStorage.setItem(storageKey, JSON.stringify(dataToStore));
      
      // Cleanup: remove legacy storage and other role's data
      localStorage.removeItem(CONFIG.LEGACY_STORAGE_KEY);
      if (userData.userRole === 'admin') {
        localStorage.removeItem(CONFIG.USER_STORAGE_KEY);
      } else {
        localStorage.removeItem(CONFIG.ADMIN_STORAGE_KEY);
      }
      
      log(`User data stored with key: ${storageKey}`, dataToStore);
      return dataToStore;
    } catch (error) {
      log('Error storing user data', error, 'error');
      throw error;
    }
  },

  // Get user data for current context
  getUserData() {
    try {
      let userData = null;
      let storageKey = null;
      
      if (isAdminPanel()) {
        storageKey = CONFIG.ADMIN_STORAGE_KEY;
        const adminData = localStorage.getItem(storageKey);
        if (adminData) {
          userData = JSON.parse(adminData);
          log('Retrieved admin data from admin storage', userData);
        }
      } else {
        storageKey = CONFIG.USER_STORAGE_KEY;
        const regularUserData = localStorage.getItem(storageKey);
        if (regularUserData) {
          userData = JSON.parse(regularUserData);
          log('Retrieved user data from user storage', userData);
        }
      }
      
      if (!userData) {
        userData = this.migrateLegacyData();
      }
      
      if (userData) {
        if (!userData.username || !userData.userRole) {
          log('Invalid user data structure', userData, 'warn');
          return null;
        }
        
        if (isAdminPanel() && userData.userRole !== 'admin') {
          log('Non-admin user trying to access admin panel', userData, 'warn');
          return null;
        }
      }
      
      return userData;
    } catch (error) {
      log('Error parsing user data from localStorage', error, 'error');
      return null;
    }
  },

  // Migrate from legacy storage format
  migrateLegacyData() {
    try {
      const legacyData = localStorage.getItem(CONFIG.LEGACY_STORAGE_KEY);
      if (!legacyData) return null;
      
      const userData = JSON.parse(legacyData);
      if (!userData.userRole) return null;
      
      log('Migrating legacy data', userData);
      
      const newStorageKey = this.getStorageKey(userData.userRole);
      localStorage.setItem(newStorageKey, legacyData);
      
      localStorage.removeItem(CONFIG.LEGACY_STORAGE_KEY);
      
      log(`Legacy data migrated to: ${newStorageKey}`);
      return userData;
    } catch (error) {
      log('Error migrating legacy data', error, 'error');
      return null;
    }
  },

  // Clear user data
  clearUserData(userRole) {
    const storageKey = this.getStorageKey(userRole);
    localStorage.removeItem(storageKey);
    localStorage.removeItem('admin_token');
    log(`Cleared data for role: ${userRole}`);
  },

  // Check if current user is admin
  isCurrentUserAdmin() {
    const userData = this.getUserData();
    return userData && userData.userRole === 'admin';
  }
};

// Storage change monitoring
function monitorStorageChanges() {
  window.addEventListener('storage', function(e) {
    if (e.key === CONFIG.ADMIN_STORAGE_KEY || e.key === CONFIG.USER_STORAGE_KEY || e.key === CONFIG.LEGACY_STORAGE_KEY) {
      log('Storage change detected', { key: e.key, newValue: e.newValue ? 'Data present' : 'Data removed' });
      
      const currentUser = AdminStorage.getUserData();
      if (!currentUser && isAdminPanel()) {
        showToast('Session Changed', 'Admin session was modified in another tab', 'warning', 3000);
      }
    }
  });
  
  log('Storage monitoring initialized');
}

// Legacy wrapper functions for backward compatibility
function getUserData() {
  return AdminStorage.getUserData();
}

function setUserData(userData) {
  return AdminStorage.setUserData(userData);
}

function getStorageKey(userRole) {
  return AdminStorage.getStorageKey(userRole);
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminStorage = AdminStorage;
  window.getUserData = getUserData;
  window.setUserData = setUserData;
  window.getStorageKey = getStorageKey;
  window.monitorStorageChanges = monitorStorageChanges;
}
```

### frontend\public\js\admin\admin-ui.js
```js
/**
 * admin-ui.js
 * UI update and management functions
 */

'use strict';

// UI management functions
const AdminUI = {
  updateStatistics() {
    const stats = {
      total: AppState.allUsers.length,
      active: AppState.allUsers.filter(u => u.status === 'active').length,
      inactive: AppState.allUsers.filter(u => u.status === 'inactive').length,
      plus: AppState.allUsers.filter(u => u.accountType === 'plus').length,
      free: AppState.allUsers.filter(u => u.accountType === 'free').length,
      admin: AppState.allUsers.filter(u => u.role === 'admin').length
    };
    
    if (elements.totalUsers) elements.totalUsers.textContent = stats.total;
    if (elements.activeUsers) elements.activeUsers.textContent = stats.active;
    if (elements.plusUsers) elements.plusUsers.textContent = stats.plus;
    
    log('Statistics updated', stats);
  },

  // Render user table
  renderUserTable() {
    if (!elements.userTableBody) {
      console.error('User table body element not found');
      return;
    }
    
    if (AppState.filteredUsers.length === 0) {
      elements.userTableBody.innerHTML = `
        <tr>
          <td colspan="11" class="empty">
            ${AppState.allUsers.length === 0 ? 'No users found in database.' : 'No users match your search criteria.'}
          </td>
        </tr>
      `;
      return;
    }
    
    elements.userTableBody.innerHTML = AppState.filteredUsers.map(user => `
      <tr data-user-id="${user.id}">
        <td>${user.id}</td>
        <td><strong>${user.username}</strong></td>
        <td>${user.fullName}</td>
        <td>${user.email}</td>
        <td>${user.phone || '-'}</td>
        <td>
          <span class="role-badge role-${user.role}">${user.role}</span>
        </td>
        <td>
          <span class="account-type-badge ${user.accountType}">${user.accountType}</span>
        </td>
        <td>
          <span class="status-badge status-${user.status}">${user.status}</span>
        </td>
        <td>${formatDate(user.createdAt)}</td>
        <td>${user.updatedAt ? formatDate(user.updatedAt) : '-'}</td>  
        <td>
          <div class="actions">
            <button class="btn btn-small btn-primary action-edit" data-user-id="${user.id}" title="Edit User">
              âœï¸ Edit
            </button>
            <button class="btn btn-small btn-danger action-delete" data-user-id="${user.id}" title="Delete User">
              ğŸ—‘ï¸ Delete
            </button>
          </div>
        </td>
      </tr>
    `).join('');
    
    setupTableEventListeners();
    log('User table rendered', { displayedCount: AppState.filteredUsers.length });
  },

  // Update connection status indicator
  updateConnectionStatus(status = 'loading') {
    const statusMap = {
      online: { class: 'status-online', text: 'Connected to Database' },
      offline: { class: 'status-offline', text: 'Database Offline' },
      loading: { class: 'status-loading', text: 'Connecting...' }
    };
    
    const config = statusMap[status] || statusMap.loading;
    
    if (elements.connectionStatus) {
      elements.connectionStatus.className = `status-indicator ${config.class}`;
    }
    if (elements.connectionText) {
      elements.connectionText.textContent = config.text;
    }
    
    log(`Connection status updated: ${status} - ${config.text}`);
  },

  // Show/hide loading overlay
  showLoading(show) {
    if (elements.loadingOverlay) {
      elements.loadingOverlay.style.display = show ? 'flex' : 'none';
    }
    AppState.isLoading = show;
  },

  // Show/hide button loading state
  showButtonLoading(button, textElement, loaderElement, show) {
    if (!button) return;
    
    if (show) {
      button.disabled = true;
      if (textElement) textElement.style.display = 'none';
      if (loaderElement) loaderElement.style.display = 'inline-block';
    } else {
      button.disabled = false;
      if (textElement) textElement.style.display = 'inline';
      if (loaderElement) loaderElement.style.display = 'none';
    }
  },

  // Show toast notification
  showToast(title, message, type = 'info', duration = 3000) {
    if (!elements.toastContainer) {
      log('Toast container not found', null, 'warn');
      return;
    }
    
    const toastId = 'toast-' + Date.now();
    
    const icons = {
      success: 'âœ…',
      error: 'âŒ',
      warning: 'âš ï¸',
      info: 'â„¹ï¸'
    };
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.id = toastId;
    toast.innerHTML = `
      <div class="toast-content">
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-message">
          <div class="toast-title">${title}</div>
          <div class="toast-text">${message}</div>
        </div>
        <button class="toast-close" data-toast-id="${toastId}">Ã—</button>
      </div>
      <div class="toast-progress"></div>
    `;
    
    elements.toastContainer.appendChild(toast);
    
    setTimeout(() => this.removeToast(toastId), duration);
    log(`Toast shown: ${type} - ${title}: ${message}`);
  },

  // Remove toast notification
  removeToast(toastId) {
    const toast = document.getElementById(toastId);
    if (toast) {
      toast.style.animation = 'slideOutRight 0.3s ease-out forwards';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }
  },

  // Show error in table
  showError(message) {
    if (elements.userTableBody) {
      elements.userTableBody.innerHTML = `
        <tr>
          <td colspan="11" class="error">
            <span class="status-indicator status-offline"></span>
            <strong>Error:</strong> ${message}
            <br><button class="btn btn-small retry-btn" style="margin-top: 1rem;">ğŸ”„ Retry</button>
          </td>
        </tr>
      `;
      
      const retryBtn = elements.userTableBody.querySelector('.retry-btn');
      if (retryBtn) {
        retryBtn.addEventListener('click', loadUsers);
      }
    }
    
    this.updateConnectionStatus('offline');
  },

  // Refresh users
  refreshUsers() {
    this.showToast('Refreshing', 'Loading latest user data from database...', 'info', 1000);
    loadUsers();
  },

  // Toggle debug panel
  toggleDebug() {
    AppState.isDebugMode = !AppState.isDebugMode;
    
    if (!elements.debugInfo || !elements.debugBtn) return;
    
    const isVisible = elements.debugInfo.style.display !== 'none';
    
    if (isVisible) {
      elements.debugInfo.style.display = 'none';
      elements.debugBtn.textContent = 'ğŸ” Debug';
    } else {
      elements.debugInfo.style.display = 'block';
      elements.debugBtn.textContent = 'ğŸ” Hide Debug';
      this.updateDebugInfo();
    }
    
    log(`Debug mode ${AppState.isDebugMode ? 'enabled' : 'disabled'}`);
  },

  // Update debug information
  updateDebugInfo() {
    if (!elements.debugContent) return;
    
    const debugData = {
      'Total Users': AppState.allUsers.length,
      'Filtered Users': AppState.filteredUsers.length,
      'Edit Mode': AppState.isEditMode,
      'Current User': AppState.currentEditingUserId ? 
        AdminState.getUserById(AppState.currentEditingUserId)?.username || 'Unknown' : 'None',
      'Search Term': elements.searchInput?.value || 'Empty',
      'API Base URL': CONFIG.API_BASE_URL,
      'Storage Key': CONFIG.ADMIN_STORAGE_KEY,
      'Last Updated': new Date().toLocaleString(),
      'Sample User Data': AppState.allUsers.length > 0 ? JSON.stringify(AppState.allUsers[0], null, 2) : 'No users loaded'
    };
    
    elements.debugContent.innerHTML = Object.entries(debugData)
      .map(([key, value]) => `<div><strong>${key}:</strong> ${value}</div>`)
      .join('');
  }
};

// Legacy wrapper functions for backward compatibility
function updateStatistics() {
  AdminUI.updateStatistics();
}

function renderUserTable() {
  AdminUI.renderUserTable();
}

function updateConnectionStatus(status) {
  AdminUI.updateConnectionStatus(status);
}

function showLoading(show) {
  AdminUI.showLoading(show);
}

function showButtonLoading(button, textElement, loaderElement, show) {
  AdminUI.showButtonLoading(button, textElement, loaderElement, show);
}

function showToast(title, message, type, duration) {
  AdminUI.showToast(title, message, type, duration);
}

function removeToast(toastId) {
  AdminUI.removeToast(toastId);
}

function showError(message) {
  AdminUI.showError(message);
}

function refreshUsers() {
  AdminUI.refreshUsers();
}

function toggleDebug() {
  AdminUI.toggleDebug();
}

function updateDebugInfo() {
  AdminUI.updateDebugInfo();
}

// Global exports
if (typeof window !== 'undefined') {
  window.AdminUI = AdminUI;
  window.updateStatistics = updateStatistics;
  window.renderUserTable = renderUserTable;
  window.updateConnectionStatus = updateConnectionStatus;
  window.showLoading = showLoading;
  window.showButtonLoading = showButtonLoading;
  window.showToast = showToast;
  window.removeToast = removeToast;
  window.showError = showError;
  window.refreshUsers = refreshUsers;
  window.toggleDebug = toggleDebug;
  window.updateDebugInfo = updateDebugInfo;
}
```

### frontend\public\js\admin\admin-utils.js
```js
/**
 * admin-utils.js
 * Utility functions for admin panel
 */

'use strict';

// Logging function
function log(message, data = null, level = 'info') {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ğŸ” Admin Panel: ${message}`;
  
  switch (level) {
    case 'error':
      console.error(logMessage, data || '');
      break;
    case 'warn':
      console.warn(logMessage, data || '');
      break;
    default:
  }
  
  // Add to debug panel if enabled
  if (AppState.isDebugMode) {
    const debugContent = document.getElementById('debugContent');
    if (debugContent) {
      const debugEntry = document.createElement('div');
      debugEntry.innerHTML = `
        <div style="margin-bottom: 0.5rem; padding: 0.5rem; border-left: 3px solid ${level === 'error' ? '#dc3545' : level === 'warn' ? '#ffc107' : '#28a745'};">
          <strong>[${new Date().toLocaleTimeString()}]</strong> ${message}
          ${data ? `<pre style="margin-top: 0.25rem; font-size: 0.75rem;">${JSON.stringify(data, null, 2)}</pre>` : ''}
        </div>
      `;
      debugContent.appendChild(debugEntry);
      debugContent.scrollTop = debugContent.scrollHeight;
    }
  }
}

// Format date helper
function formatDate(dateString) {
  if (!dateString) return 'N/A';
  try {
    const parts = dateString.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})/);
    if (parts) {
      const [, year, month, day, hour, minute] = parts;
      return `${new Date(year, month-1, day).toLocaleDateString('en-US', {month: 'short'})} ${day}, ${year}, ${hour.padStart(2,'0')}:${minute}`;
    }
    return dateString; 
  } catch (e) {
    return 'Invalid Date';
  }
}

// Delay helper
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function isAdminPanel() {
  return window.location.pathname.includes('admin') || 
         window.location.href.includes('admin') ||
         document.title.toLowerCase().includes('admin') ||
         document.getElementById('adminUsername') !== null;
}

// Initialize DOM elements
function initializeElements() {
  elements = {
    adminUsername: document.getElementById('adminUsername'),
    connectionStatus: document.getElementById('connectionStatus'),
    connectionText: document.getElementById('connectionText'),
    logoutBtn: document.getElementById('logoutBtn'),
    
    totalUsers: document.getElementById('totalUsers'),
    activeUsers: document.getElementById('activeUsers'),
    plusUsers: document.getElementById('plusUsers'),
    
    searchInput: document.getElementById('searchInput'),
    userTableBody: document.getElementById('userTableBody'),
    refreshBtn: document.getElementById('refreshBtn'),
    debugBtn: document.getElementById('debugBtn'),
    debugInfo: document.getElementById('debugInfo'),
    debugContent: document.getElementById('debugContent'),
    
    userModal: document.getElementById('userModal'),
    modalTitle: document.getElementById('modalTitle'),
    userForm: document.getElementById('userForm'),
    addUserBtn: document.getElementById('addUserBtn'),
    cancelBtn: document.getElementById('cancelBtn'),
    saveBtn: document.getElementById('saveBtn'),
    saveBtnText: document.getElementById('saveBtnText'),
    saveBtnLoader: document.getElementById('saveBtnLoader'),
    
    editUserId: document.getElementById('editUserId'),
    username: document.getElementById('username'),
    email: document.getElementById('email'),
    phone: document.getElementById('phone'),
    fullName: document.getElementById('fullName'),
    password: document.getElementById('password'),
    passwordRequired: document.getElementById('passwordRequired'),
    passwordHint: document.getElementById('passwordHint'),
    
    accountSettings: document.getElementById('accountSettings'),
    isActive: document.getElementById('isActive'),
    isPlusAccount: document.getElementById('isPlusAccount'),
    isAdmin: document.getElementById('isAdmin'),
    roleSelection: document.getElementById('roleSelection'),
    
    quickToggleModal: document.getElementById('quickToggleModal'),
    quickToggleUsername: document.getElementById('quickToggleUsername'),
    quickToggleOptions: document.getElementById('quickToggleOptions'),
    quickToggleCancelBtn: document.getElementById('quickToggleCancelBtn'),
    quickToggleConfirmBtn: document.getElementById('quickToggleConfirmBtn'),
    quickToggleBtnText: document.getElementById('quickToggleBtnText'),
    quickToggleBtnLoader: document.getElementById('quickToggleBtnLoader'),
    
    loadingOverlay: document.getElementById('loadingOverlay'),
    toastContainer: document.getElementById('toastContainer')
  };
  
  log('DOM elements initialized');
}

function fixInputStyling() {
  const inputs = document.querySelectorAll('input, select');
  
  inputs.forEach(input => {
    input.removeAttribute('aria-invalid');
    input.removeAttribute('aria-describedby');
    input.classList.remove('invalid', 'valid', 'error');
    input.style.borderColor = '#667eea';
    input.style.boxShadow = 'none';
    input.style.outline = 'none';
    input.style.transform = 'none';
    input.style.backfaceVisibility = 'hidden';
    
    const events = ['focus', 'blur', 'invalid', 'input'];
    events.forEach(eventType => {
      input.addEventListener(eventType, function(e) {
        if (eventType === 'invalid') {
          e.preventDefault();
          e.stopPropagation();
        }
        
        this.style.borderColor = eventType === 'focus' ? '#4f46e5' : '#667eea';
        this.style.boxShadow = eventType === 'focus' ? '0 0 0 3px rgba(102, 126, 234, 0.15)' : 'none';
        this.style.outline = 'none';
        this.style.transform = 'none';
      });
    });
  });
}

// Setup input fixes
function setupInputFixes() {
  const userModal = document.getElementById('userModal');
  if (userModal) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          if (userModal.classList.contains('show')) {
            setTimeout(fixInputStyling, 50);
            setTimeout(fixInputStyling, 200);
            setTimeout(fixInputStyling, 500);
          }
        }
      });
    });
    
    observer.observe(userModal, {
      attributes: true,
      attributeFilter: ['class']
    });
  }
}

// Setup password toggle
function setupPasswordToggle() {
  document.addEventListener('click', (e) => {
    if (e.target.closest('#togglePassword') || e.target.closest('.toggle-password')) {
      const toggleBtn = e.target.closest('#togglePassword') || e.target.closest('.toggle-password');
      const passwordInput = document.getElementById('password');
      
      if (passwordInput) {
        const isHidden = passwordInput.getAttribute('type') === 'password';
        passwordInput.setAttribute('type', isHidden ? 'text' : 'password');
        
        const icon = toggleBtn.querySelector('i');
        if (icon) {
          icon.classList.toggle('fa-eye', !isHidden);
          icon.classList.toggle('fa-eye-slash', isHidden);
        }
      }
    }
  }
);
}

// Export functions
function exportUsers(format = 'csv') {
  const exportData = AppState.filteredUsers.map(user => ({
    ID: user.id,
    Username: user.username,
    'Full Name': user.fullName,
    Email: user.email,
    Phone: user.phone || '',
    Role: user.role,
    'Account Type': user.accountType,
    Status: user.status,
    'Created At': formatDate(user.createdAt)
  }));
  
  if (format === 'csv') {
    exportToCSV(exportData, 'users.csv');
  } else if (format === 'json') {
    exportToJSON(exportData, 'users.json');
  }
  
  showToast('Export', `Exported ${exportData.length} users as ${format.toUpperCase()}`, 'success');
}

function exportToCSV(data, filename) {
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => 
        JSON.stringify(row[header] || '')
      ).join(',')
    )
  ].join('\n');
  
  downloadFile(csvContent, filename, 'text/csv');
}

function exportToJSON(data, filename) {
  const jsonContent = JSON.stringify(data, null, 2);
  downloadFile(jsonContent, filename, 'application/json');
}

function downloadFile(content, filename, contentType) {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

if (typeof window !== 'undefined') {
  window.log = log;
  window.formatDate = formatDate;
  window.delay = delay;
  window.isAdminPanel = isAdminPanel;
  window.initializeElements = initializeElements;
  window.fixInputStyling = fixInputStyling;
  window.setupInputFixes = setupInputFixes;
  window.setupPasswordToggle = setupPasswordToggle;
  window.exportUsers = exportUsers;
}
```

### frontend\public\js\introduction\demoHandler.js
```js
// demoHandler.js 

import { showToast } from './utils.js';
import { 
    getRemainingUsage, 
    hasRemainingUsage, 
    incrementUsage,
    getMaxFreeUsage 
} from './usageManager.js';
import { updateTextStats, displayResults } from './grammarChecker.js';
import { showUsageLimitModal } from './uiComponents.js';
import { checkGrammar, detectLanguage } from '/js/api.js';

// Language name mapping
const LANGUAGE_NAMES = {
  'en-US': 'English (US)', 'en': 'English', 'fr': 'French', 'de': 'German', 
  'ru': 'Russian', 'ru-RU': 'Russian', 'uk': 'Ukrainian', 'uk-UA': 'Ukrainian',
  'ja': 'Japanese', 'ja-JP': 'Japanese', 
  'es': 'Spanish', 'pt': 'Portuguese', 'it': 'Italian', 'nl': 'Dutch', 
  'pl-PL': 'Polish', 'pl': 'Polish', 'sv': 'Swedish',
  'da-DK': 'Danish', 'da': 'Danish', 'ar': 'Arabic', 'zh-CN': 'Chinese', 
  'zh': 'Chinese', 'ko': 'Korean',
  'vi': 'Vietnamese', 'th': 'Thai', 'be': 'Belarusian', 'bg': 'Bulgarian', 'sr': 'Serbian'
};

const LANGUAGE_CODE_MAP = {
  'en-US': 'en', 'en': 'en', 'ja-JP': 'ja', 'ja': 'ja', 'zh-CN': 'zh', 'zh': 'zh',
  'ru-RU': 'ru', 'ru': 'ru', 'uk-UA': 'uk', 'uk': 'uk', 'de-DE': 'de', 'de': 'de',
  'fr': 'fr', 'es': 'es', 'it': 'it', 'pt': 'pt', 'vi': 'vi', 'ko': 'ko',
  'ar': 'ar', 'nl': 'nl', 'pl-PL': 'pl', 'pl': 'pl', 'sv': 'sv',
  'da-DK': 'da', 'da': 'da', 'th': 'th', 'be': 'be', 'bg': 'bg', 'sr': 'sr'
};

function getLanguageName(code) {
  return LANGUAGE_NAMES[code] || code;
}

function normalizeLanguageCode(code) {
  return LANGUAGE_CODE_MAP[code] || code;
}

export function populateDemoLanguages() {
    const demoLanguage = document.getElementById('demoLanguage');
    
    if (!demoLanguage) {
        console.warn('demoLanguage select not found');
        return;
    }
    
    demoLanguage.innerHTML = '';
    
    const languages = [
        { code: 'en-US', name: 'English (US)' },
        { code: 'fr', name: 'French' },
        { code: 'de', name: 'German' },
        { code: 'es', name: 'Spanish' },
        { code: 'it', name: 'Italian' },
        { code: 'pt', name: 'Portuguese' },
        { code: 'ru', name: 'Russian' },
        { code: 'ja-JP', name: 'Japanese' },
        { code: 'zh-CN', name: 'Chinese' }
    ];
    
    languages.forEach(({ code, name }) => {
        const option = document.createElement('option');
        option.value = code;
        option.textContent = name;
        demoLanguage.appendChild(option);
    });
    
    demoLanguage.value = 'en-US';
    console.log('Demo languages populated');
}

// Main demo grammar check function
export async function checkDemoGrammar() {
    const demoText = document.getElementById('demoText');
    const demoLanguage = document.getElementById('demoLanguage');
    const demoResults = document.getElementById('demoResults');
    const demoErrorsList = document.getElementById('demoErrorsList');
    const demoIssueCount = document.getElementById('demoIssueCount');
    const remainingUsesEl = document.getElementById('remainingUses');
    const demoCheckBtn = document.getElementById('demoCheckBtn');
    
    if (!demoText || !demoText.value.trim()) {
        showToast('Please enter some text to check.', 'error');
        return;
    }
    
    const text = demoText.value.trim();
    const selectedLang = demoLanguage ? demoLanguage.value : 'en-US';
    
    if (!hasRemainingUsage()) {
        const maxUsage = getMaxFreeUsage();
        showToast(`Free usage limit reached (${maxUsage}/${maxUsage}). Please register or login to continue.`, 'error');
        showUsageLimitModal();
        return;
    }
    
    try {
        if (demoCheckBtn) {
            demoCheckBtn.disabled = true;
            demoCheckBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
        }        
        const hiraganaPattern = /[\u3040-\u309F]/;
        const katakanaPattern = /[\u30A0-\u30FF]/;
        const koreanPattern = /[\uAC00-\uD7AF\u1100-\u11FF]/;
        const arabicPattern = /[\u0600-\u06FF\u0750-\u077F]/;
        const cyrillicPattern = /[\u0400-\u04FF]/;
        const thaiPattern = /[\u0E00-\u0E7F]/;
        
        let preDetectedLang = null;
        if (koreanPattern.test(text)) {
            preDetectedLang = 'ko';
        } else if (thaiPattern.test(text)) {
            preDetectedLang = 'th';
        } else if (arabicPattern.test(text)) {
            preDetectedLang = 'ar';
        } else if (cyrillicPattern.test(text)) {
            preDetectedLang = 'ru-RU';
        }else if (hiraganaPattern.test(text) || katakanaPattern.test(text)) {
            preDetectedLang = 'ja-JP';
        }
        
        let detectionInfo;
        if (preDetectedLang) {
            detectionInfo = {
                language: preDetectedLang,
                confidence: 0.95,
                reliable: true,
                source: 'unicode-pattern'
            };
        } else {
            console.log('ğŸ” Using CLD3 detection...');
            detectionInfo = await detectLanguage(text);
        }
        
        const detectedLang = normalizeLanguageCode(detectionInfo.language);
        const selectedLangNormalized = normalizeLanguageCode(selectedLang);
        
        console.log(`Selected: ${selectedLang} (${selectedLangNormalized})`);
        console.log(`Detected: ${detectionInfo.language} (${detectedLang})`);
        console.log(`Confidence: ${(detectionInfo.confidence * 100).toFixed(1)}%`);
        
        const shouldValidate = detectionInfo.confidence > 0.3;
        const cyrillicLanguages = ['ru', 'uk', 'be', 'bg', 'sr'];
        const isCyrillicDetected = cyrillicLanguages.includes(detectedLang);
        const isCyrillicSelected = cyrillicLanguages.includes(selectedLangNormalized);
        const areBothCyrillic = isCyrillicDetected && isCyrillicSelected;
        const shouldShowWarning = shouldValidate && detectedLang !== selectedLangNormalized && !areBothCyrillic;
        
        if (shouldShowWarning) {
            if (demoCheckBtn) {
                demoCheckBtn.disabled = false;
                demoCheckBtn.innerHTML = '<i class="fas fa-check-circle"></i> Check Grammar';
            }
            
            const detectedLangName = getLanguageName(detectionInfo.language);
            const selectedLangName = getLanguageName(selectedLang);
            
            showToast(
                `âŒ Language mismatch!\n\nDetected: ${detectedLangName}\nYou selected: ${selectedLangName}\n\nPlease select the correct language.`,
                'error',
                5000
            );
            
            if (demoLanguage) {
                demoLanguage.style.border = '2px solid #dc3545';
                setTimeout(() => {
                    demoLanguage.style.border = '';
                }, 3000);
            }
            
            return;
        }
        
        console.log('âœ… Language validation passed. Checking grammar...');
        
        const result = await checkGrammar(text, selectedLang);
        console.log('API result:', result);
        
        const matches = result.matches || result.data?.matches || [];
        
        if (matches || result.success !== false) {
            incrementUsage();
            const remaining = getRemainingUsage();
            
            if (remainingUsesEl) {
                remainingUsesEl.textContent = remaining;
            }
            
            if (remaining > 0) {
                showToast(`Grammar check completed! ${remaining} free checks remaining.`, 'success');
            } else {
                showToast('Grammar check completed! This was your last free check.', 'info');
            }
            
            updateTextStats(text);
            
            if (demoIssueCount) demoIssueCount.textContent = matches.length;
            
            if (demoResults) demoResults.style.display = 'block';
            if (demoErrorsList) {
                displayResults(matches, demoErrorsList);
                setupAcceptAllButton(matches);
            }
            
        } else {
            showToast('Grammar check failed. Please try again.', 'error');
        }
        
    } catch (error) {
        console.error('Demo grammar check failed:', error);
        showToast('Error: ' + error.message, 'error');
    } finally {
        if (demoCheckBtn) {
            demoCheckBtn.disabled = false;
            demoCheckBtn.innerHTML = '<i class="fas fa-check-circle"></i> Check Grammar';
        }
    }
}

function setupAcceptAllButton(matches) {
    const acceptAllBtn = document.getElementById('demoAcceptAllBtn');
    if (!acceptAllBtn) return;
    
    const newBtn = acceptAllBtn.cloneNode(true);
    acceptAllBtn.parentNode.replaceChild(newBtn, acceptAllBtn);
    
    newBtn.addEventListener('click', () => {
        applyAllDemoSuggestions(matches);
    });
}

function applyAllDemoSuggestions(matches) {
    const demoText = document.getElementById('demoText');
    if (!demoText || !matches || matches.length === 0) return;
    
    let text = demoText.value;
    let offsetShift = 0;
    
    const sortedMatches = [...matches].sort((a, b) => a.offset - b.offset);
    
    sortedMatches.forEach(match => {
        const suggestion = match.replacements?.[0]?.value;
        if (suggestion) {
            const start = match.offset + offsetShift;
            const end = start + match.length;
            text = text.substring(0, start) + suggestion + text.substring(end);
            offsetShift += suggestion.length - match.length;
        }
    });
    
    demoText.value = text;
    
    const demoErrorsList = document.getElementById('demoErrorsList');
    if (demoErrorsList) {
        demoErrorsList.innerHTML = `
            <div class="demo-no-errors">
                <i class="fas fa-check-circle"></i>
                <p>All suggestions applied successfully!</p>
            </div>
        `;
    }
    
    const acceptAllBtn = document.getElementById('demoAcceptAllBtn');
    if (acceptAllBtn) acceptAllBtn.style.display = 'none';
    
    const issueCount = document.getElementById('demoIssueCount');
    if (issueCount) issueCount.textContent = '0';
    
    updateTextStats(text);
    showToast('All suggestions applied successfully!', 'success');
}

export function setupDemoTextListener() {
    const demoText = document.getElementById('demoText');
    if (demoText) {
        demoText.addEventListener('input', () => {
            updateTextStats(demoText.value);
        });
    }
}
```

### frontend\public\js\introduction\grammarChecker.js
```js
// grammarChecker.js - Xá»­ lÃ½ hiá»ƒn thá»‹ káº¿t quáº£ grammar check

export function displayResults(matches, container) {
    if (!container) return;
    
    if (matches.length === 0) {
        container.innerHTML = `
            <div class="demo-no-errors">
                <i class="fas fa-check-circle"></i>
                <p>Great! No grammar issues found in your text.</p>
            </div>
        `;
        
        const acceptAllBtn = document.getElementById('demoAcceptAllBtn');
        if (acceptAllBtn) acceptAllBtn.style.display = 'none';
        
        return;
    }
    
    window.currentDemoMatches = matches;
    
    container.innerHTML = matches.map((match, index) => {
        const errorText = match.context 
            ? match.context.text.substring(
                match.context.offset,
                match.context.offset + match.context.length
              )
            : 'Unknown';
        
        const suggestion = match.replacements?.[0]?.value || '';
        const errorType = match.rule?.category?.name || 'Grammar';
        
        return `
            <div class="demo-error-item" data-error-index="${index}">
                <div class="demo-error-type">${errorType}</div>
                <div class="demo-error-message"><strong>Issue:</strong> ${match.message}</div>
                <div class="demo-suggestion">
                    <strong>Original:</strong> 
                    <span style="background: #ffebee; padding: 2px 6px; border-radius: 3px; color: #c62828;">"${escapeHtml(errorText)}"</span> 
                    â†’ 
                    <strong>Suggestion:</strong> 
                    <span style="background: #e8f5e8; padding: 2px 6px; border-radius: 3px; color: #2e7d32;">"${suggestion || 'No suggestion'}"</span>
                </div>
                ${suggestion ? `
                    <button class="demo-apply-btn" 
                            data-index="${index}" 
                            data-offset="${match.offset}" 
                            data-length="${match.length}" 
                            data-suggestion="${escapeHtml(suggestion)}">
                        <i class="fas fa-check"></i> Apply
                    </button>
                ` : ''}
            </div>
        `;
    }).join('');
    
    const acceptAllBtn = document.getElementById('demoAcceptAllBtn');
    if (acceptAllBtn) acceptAllBtn.style.display = 'block';
    
    setupApplyButtons();
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function setupApplyButtons() {
    document.querySelectorAll('.demo-apply-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            const offset = parseInt(this.dataset.offset);
            const length = parseInt(this.dataset.length);
            const suggestion = this.dataset.suggestion;
            
            applyDemoSuggestion(index, offset, length, suggestion);
        });
    });
}

function applyDemoSuggestion(index, offset, length, suggestion) {
    const demoText = document.getElementById('demoText');
    if (!demoText) return;
    
    const text = demoText.value;
    const newText = text.substring(0, offset) + suggestion + text.substring(offset + length);
    demoText.value = newText;
    
    const errorItem = document.querySelector(`[data-error-index="${index}"]`);
    if (errorItem) {
        errorItem.classList.add('removing');
        setTimeout(() => {
            errorItem.remove();
            
            const remainingErrors = document.querySelectorAll('.demo-error-item');
            if (remainingErrors.length === 0) {
                const demoErrorsList = document.getElementById('demoErrorsList');
                if (demoErrorsList) {
                    demoErrorsList.innerHTML = `
                        <div class="demo-no-errors">
                            <i class="fas fa-check-circle"></i>
                            <p>All suggestions applied! Your text looks great.</p>
                        </div>
                    `;
                }
                
                const acceptAllBtn = document.getElementById('demoAcceptAllBtn');
                if (acceptAllBtn) acceptAllBtn.style.display = 'none';
            }
            
            const issueCount = document.getElementById('demoIssueCount');
            if (issueCount) {
                issueCount.textContent = remainingErrors.length;
            }
        }, 300);
    }
    
    updateTextStats(newText);
    
    if (window.currentDemoMatches) {
        window.currentDemoMatches = window.currentDemoMatches.filter((_, i) => i !== index);
    }
}

export function updateTextStats(text) {
    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const chars = text.length;
    
    const wordCountEl = document.getElementById('demoWordCount');
    const charCountEl = document.getElementById('demoCharCount');
    
    if (wordCountEl) wordCountEl.textContent = words;
    if (charCountEl) charCountEl.textContent = chars;
    
    return { words, chars };
}
```

### frontend\public\js\introduction\intro-main.js
```js
// intro-main.js - Updated Version with AuthManager

import { showToast, showCustomAlert } from './utils.js';
import { getRemainingUsage, getMaxFreeUsage } from './usageManager.js';
import { 
    initSmoothScrolling, 
    initAccordion, 
    updateButtonVisibility,
    initPageTransitions,
    showUsageLimitModal,
    closeUsageLimitModal 
} from './uiComponents.js';
import { checkDemoGrammar, populateDemoLanguages } from './demoHandler.js';
import { 
    setupSidebar, 
    updateSidebarVisibility, 
    initSidebarScrollSpy 
} from './sidebar.js';

function getAuthManager() {
    if (typeof AuthManager !== 'undefined' && AuthManager) {
        return AuthManager;
    } else if (window.AuthManager) {
        return window.AuthManager;
    } else {
        console.warn('AuthManager not available yet, using fallback');
        return {
            isLoggedIn: () => false,
            getCurrentUser: () => null,
            logout: () => false,
            getTabId: () => 'fallback-tab'
        };
    }
}

// ==================== USER AUTHENTICATION & UI ====================

function updateUIForAuth() {
    const authManager = getAuthManager();
    const authButtons = document.getElementById('authButtons');
    const userDropdownContainer = document.getElementById('userDropdownContainer');
    const desktopNav = document.getElementById('desktopNav');
    const tryItFreeBtn = document.getElementById('tryItFreeBtn');

    const loggedIn = authManager.isLoggedIn();
    updateSidebarVisibility(loggedIn);
    updateButtonVisibility(); 

    if (loggedIn) {
        const userData = authManager.getCurrentUser();
        
        if (userData) {
            if (authButtons) {
                authButtons.classList.add('hidden');
            }
            if (userDropdownContainer) {
                userDropdownContainer.classList.remove('hidden');
            }
            if (desktopNav) {
                desktopNav.classList.remove('hidden');
            }
            if (tryItFreeBtn) {
                tryItFreeBtn.style.display = 'none'; 
            }

            populateUserInfo(userData);
        }
    } else {
        if (authButtons) {
            authButtons.classList.remove('hidden');
        }
        if (desktopNav) desktopNav.classList.remove('hidden');
        if (userDropdownContainer) {
            userDropdownContainer.classList.add('hidden');
        }if (tryItFreeBtn) {
            tryItFreeBtn.style.display = 'inline-flex'; 
        }
    }
}

/**
 * Populate user information in dropdown
 */
function populateUserInfo(userData) {
    const headerUsername = document.getElementById('headerUsername');
    const dropdownUsername = document.getElementById('dropdownUsername');
    const dropdownEmail = document.getElementById('dropdownEmail');
    
    const username = userData.username || userData.name || 'User';
    const email = userData.email || 'user@example.com';
    
    if (headerUsername) headerUsername.textContent = username;
    if (dropdownUsername) dropdownUsername.textContent = username;
    if (dropdownEmail) dropdownEmail.textContent = email;
}

/**
 * Setup user dropdown functionality
 */
function setupUserDropdown() {
    const userAvatarToggle = document.getElementById('userAvatarToggle');
    const userDropdown = document.getElementById('userDropdown');
    
    if (!userAvatarToggle || !userDropdown) return;
    
    userAvatarToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        userDropdown.classList.toggle('hidden');
        userAvatarToggle.classList.toggle('active');
    });
    
    document.addEventListener('click', (e) => {
        if (!userAvatarToggle.contains(e.target) && !userDropdown.contains(e.target)) {
            userDropdown.classList.add('hidden');
            userAvatarToggle.classList.remove('active');
        }
    });
}

/**
 * Setup logout functionality
 */
function setupLogout() {
    const logoutBtn = document.getElementById('logoutBtn');
    const authManager = getAuthManager();

    if (!logoutBtn) return;
    
    logoutBtn.addEventListener('click', (e) => {
        e.preventDefault();
        
        if (authManager.logout()) {
            showToast('Logged out successfully', 'success', 2000);
            
            setTimeout(() => {
                window.location.href = '/introduction.html';
            }, 1000);
        }
    });
}

// ==================== BUTTON HANDLERS ====================

function setupButtonHandlers() {
    const authManager = getAuthManager();
    const tryItFreeBtn = document.getElementById('tryItFreeBtn');
    const learnMoreBtn = document.getElementById('learnMoreBtn');
    const upgradeAccountBtn = document.getElementById('upgradeAccountBtn');
    const goToRegisterBtn = document.getElementById('goToRegisterBtn');
    const goToLoginBtn = document.getElementById('goToLoginBtn');

    if (tryItFreeBtn) {
        tryItFreeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            
            if (authManager.isLoggedIn()) {
                showToast('Redirecting to full grammar checker...', 'success', 1500);
                setTimeout(() => {
                    window.location.href = '/GrammarChecker1.html';
                }, 1500);
                return;
            }
            
            const remaining = getRemainingUsage();
            const maxUsage = getMaxFreeUsage();
            
            if (remaining > 0) {
                const demoSection = document.getElementById('demo');
                if (demoSection) {
                    demoSection.style.display = 'block';
                    
                    const headerHeight = document.querySelector('header')?.offsetHeight || 0;
                    const targetPosition = demoSection.offsetTop - headerHeight - 20;
                    
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                    
                    showToast(`You have ${remaining} free checks remaining. Try it now!`, 'info', 3000);
                }
            } else {
                showToast(`You have used all free checks (${maxUsage}/${maxUsage}). Please register to continue.`, 'error', 4000);
                showUsageLimitModal();
            }
        });
    }

    if (learnMoreBtn) {
        learnMoreBtn.addEventListener('click', (e) => {
            e.preventDefault();
            const aboutSection = document.getElementById('about');
            if (aboutSection) {
                const headerHeight = document.querySelector('header')?.offsetHeight || 0;
                const targetPosition = aboutSection.offsetTop - headerHeight - 20;
                
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    }

    if (upgradeAccountBtn) {
        upgradeAccountBtn.addEventListener('click', (e) => {
            e.preventDefault();
            showCustomAlert("This feature is coming soon! Stay tuned for premium plans.", 'info');
        });
    }

    if (goToRegisterBtn) {
        goToRegisterBtn.addEventListener('click', () => {
            closeUsageLimitModal();
            window.location.href = '/index.html';
        });
    }

    if (goToLoginBtn) {
        goToLoginBtn.addEventListener('click', () => {
            closeUsageLimitModal();
            window.location.href = '/login.html';
        });
    }
}

// ==================== SIDEBAR NAVIGATION HANDLER ====================

function setupSidebarNavigation() {
    setTimeout(() => {
        const sidebar = document.getElementById('sidebar');
        if (!sidebar) return;
        
        const grammarCheckLink = sidebar.querySelector('a[href="GrammarChecker1.html"]');
        const authManager = getAuthManager();
        
        if (grammarCheckLink) {
            const newLink = grammarCheckLink.cloneNode(true);
            grammarCheckLink.parentNode.replaceChild(newLink, grammarCheckLink);
            
            newLink.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (authManager.isLoggedIn()) {
                    window.location.href = '/GrammarChecker1.html';
                } else {
                    showToast('Please log in to access the full grammar checker.', 'info', 4000);
                    
                    if (window.innerWidth < 1024) {
                        sidebar.classList.add('hidden');
                        const pageContentWrapper = document.getElementById('pageContentWrapper');
                        if (pageContentWrapper) {
                            pageContentWrapper.classList.remove('sidebar-open');
                        }
                    }
                }
            });
        }
    }, 100);
}

// ==================== MODAL HANDLERS ====================

function setupModalHandlers() {
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('close') && e.target.dataset.modal === 'usageLimitModal') {
            closeUsageLimitModal();
        }
    });

    window.addEventListener('click', (event) => {
        const modal = document.getElementById('usageLimitModal');
        if (event.target === modal) {
            closeUsageLimitModal();
        }
    });
}

// ==================== INITIALIZATION ====================

function initializeApp() {
    setupSidebar();
    setupUserDropdown();
    setupLogout();

    initSmoothScrolling();
    initAccordion();
    initPageTransitions();
    initSidebarScrollSpy();
    updateUIForAuth();
    setupButtonHandlers();
    setupSidebarNavigation();
    setupModalHandlers();
    populateDemoLanguages();

    const demoCheckBtn = document.getElementById('demoCheckBtn');
    if (demoCheckBtn) {
        demoCheckBtn.addEventListener('click', checkDemoGrammar);
    }
    setTimeout(() => {
        updateUIForAuth();
    }, 300);
}

// ==================== MAIN ====================

document.addEventListener('DOMContentLoaded', initializeApp);

window.showToast = showToast;
window.showCustomAlert = showCustomAlert;
window.closeUsageLimitModal = closeUsageLimitModal;
window.updateUIForAuth = updateUIForAuth;

window.addEventListener('load', () => {
    updateUIForAuth();
});
```

### frontend\public\js\introduction\sidebar.js
```js
// sidebar.js - Sidebar functionality module

/**
 * Setup sidebar functionality - DATA ATTRIBUTES VERSION
 */
export function setupSidebar() {
    const sidebarToggle = document.getElementById('sidebarToggle');
    const sidebar = document.getElementById('sidebar');
    const pageContentWrapper = document.getElementById('pageContentWrapper');
    
    if (!sidebarToggle || !sidebar) return;
    
    sidebarToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        sidebar.classList.toggle('hidden');
        pageContentWrapper?.classList.toggle('sidebar-open');
    });
    
    setupSidebarNavigation(sidebar, pageContentWrapper);
    
    setupClickOutsideToClose(sidebar, sidebarToggle, pageContentWrapper);
    
    setupResponsiveBehavior(sidebar, pageContentWrapper);
}

/**
 * Setup sidebar navigation items
 */
function setupSidebarNavigation(sidebar, pageContentWrapper) {
    const sidebarItems = sidebar.querySelectorAll('.sidebar-item');
    
    sidebarItems.forEach(item => {
        item.addEventListener('click', (e) => {
            const href = item.getAttribute('href');
            
            if (href && href.startsWith('#')) {
                e.preventDefault();
                
                const targetSection = document.querySelector(href);
                if (targetSection) {
                    scrollToSection(targetSection);
                    
                    sidebarItems.forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    
                    if (window.innerWidth < 1024) {
                        sidebar.classList.add('hidden');
                        pageContentWrapper?.classList.remove('sidebar-open');
                    }
                }
            }
        });
    });
}

/**
 * Scroll to a specific section with offset
 */
function scrollToSection(targetSection) {
    const headerHeight = document.querySelector('header')?.offsetHeight || 0;
    const targetPosition = targetSection.offsetTop - headerHeight - 20;
    
    window.scrollTo({
        top: targetPosition,
        behavior: 'smooth'
    });
}

/**
 * Setup click outside to close sidebar
 */
function setupClickOutsideToClose(sidebar, sidebarToggle, pageContentWrapper) {
    document.addEventListener('click', (e) => {
        if (!sidebar.contains(e.target) && !sidebarToggle.contains(e.target)) {
            if (!sidebar.classList.contains('hidden')) {
                sidebar.classList.add('hidden');
                pageContentWrapper?.classList.remove('sidebar-open');
            }
        }
    });
}

/**
 * Setup responsive behavior for sidebar
 */
function setupResponsiveBehavior(sidebar, pageContentWrapper) {
    window.addEventListener('resize', () => {
        if (window.innerWidth < 768) {
            sidebar.classList.add('hidden');
            pageContentWrapper?.classList.remove('sidebar-open');
        }
    });
}

/**
 * Update sidebar visibility based on screen size and auth status
 */
export function updateSidebarVisibility(isLoggedIn) {
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebarToggle');
    
    if (sidebarToggle) {
        if (window.innerWidth < 1024) {
            sidebarToggle.classList.remove('hidden');
        } else {
            sidebarToggle.classList.add('hidden');
        }
    }
    
    if (sidebar) {
        if (window.innerWidth < 1024) {
            sidebar.classList.add('hidden');
        } else {
            sidebar.classList.remove('hidden');
        }
    }
}

/**
 * Set active sidebar item based on current section
 */
export function setActiveSidebarItem(sectionId) {
    const sidebar = document.getElementById('sidebar');
    if (!sidebar) return;
    
    const sidebarItems = sidebar.querySelectorAll('.sidebar-item');
    sidebarItems.forEach(item => {
        const href = item.getAttribute('href');
        if (href === `#${sectionId}`) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

/**
 * Highlight sidebar item on scroll
 */
export function initSidebarScrollSpy() {
    const sections = document.querySelectorAll('section[id]');
    const sidebarItems = document.querySelectorAll('.sidebar-item');
    
    if (sections.length === 0 || sidebarItems.length === 0) return;
    
    const observerOptions = {
        root: null,
        rootMargin: '-20% 0px -70% 0px',
        threshold: 0
    };
    
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const id = entry.target.getAttribute('id');
                setActiveSidebarItem(id);
            }
        });
    }, observerOptions);
    
    sections.forEach(section => {
        observer.observe(section);
    });
}

/**
 * Toggle sidebar programmatically
 */
export function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const pageContentWrapper = document.getElementById('pageContentWrapper');
    
    if (sidebar) {
        sidebar.classList.toggle('hidden');
        pageContentWrapper?.classList.toggle('sidebar-open');
    }
}

/**
 * Close sidebar programmatically
 */
export function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const pageContentWrapper = document.getElementById('pageContentWrapper');
    
    if (sidebar && !sidebar.classList.contains('hidden')) {
        sidebar.classList.add('hidden');
        pageContentWrapper?.classList.remove('sidebar-open');
    }
}

/**
 * Open sidebar programmatically
 */
export function openSidebar() {
    const sidebar = document.getElementById('sidebar');
    const pageContentWrapper = document.getElementById('pageContentWrapper');
    
    if (sidebar && sidebar.classList.contains('hidden')) {
        sidebar.classList.remove('hidden');
        pageContentWrapper?.classList.add('sidebar-open');
    }
}
```

### frontend\public\js\introduction\uiComponents.js
```js
// uiComponents.js 

import { isLoggedIn } from './utils.js';

// Modal Functions
export function showUsageLimitModal() {
    const modal = document.getElementById('usageLimitModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

export function closeUsageLimitModal() {
    const modal = document.getElementById('usageLimitModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Smooth scrolling for navigation links
export function initSmoothScrolling() {
    const navLinks = document.querySelectorAll('nav a[href^="#"]');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
                const headerHeight = document.querySelector('header').offsetHeight;
                const targetPosition = targetElement.offsetTop - headerHeight - 20;
                
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    });
}

// Initialize accordion functionality
export function initAccordion() {
    const accordionHeaders = document.querySelectorAll('.accordion-header');
    accordionHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const content = header.nextElementSibling;
            const isActive = header.classList.contains('active');
            accordionHeaders.forEach(h => {
                h.classList.remove('active');
                const c = h.nextElementSibling;
                if (c) c.style.maxHeight = null;
            });
            if (!isActive) {
                header.classList.add('active');
                if (content) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            }
        });
    });
}

// Update button visibility based on login status
export function updateButtonVisibility() {
    const tryItFreeBtn = document.getElementById('tryItFreeBtn');
    const upgradeAccountBtn = document.getElementById('upgradeAccountBtn');
    const authButtons = document.querySelector('.auth-buttons');
    
    const loggedIn = isLoggedIn();
    
    if (tryItFreeBtn) tryItFreeBtn.style.display = loggedIn ? 'none' : 'inline-block';
    if (upgradeAccountBtn) upgradeAccountBtn.style.display = loggedIn ? 'inline-block' : 'none';
    if (authButtons) {
    if (loggedIn) {
        authButtons.classList.add('hidden');
        authButtons.style.display = 'none';
    } else {
        authButtons.classList.remove('hidden');
        authButtons.style.display = 'flex';
    }
}
}

// Add page transition effects
export function initPageTransitions() {
    const links = document.querySelectorAll('a[href]:not([href^="#"]):not([target="_blank"])');
    links.forEach(link => {
        link.addEventListener('click', (e) => {
            if (link.onclick) return;
            
            e.preventDefault();
            const href = link.getAttribute('href');
            document.body.style.opacity = '0.7';
            document.body.style.transition = 'opacity 0.3s ease';
            
            setTimeout(() => {
                window.location.href = href;
            }, 300);
        });
    });
}
```

### frontend\public\js\introduction\usageManager.js
```js
// usageManager.js 

const USAGE_KEY = 'freeUsageCount';
const MAX_FREE_USAGE = 3;

// Get current usage count
export function getCurrentUsage() {
    return parseInt(localStorage.getItem(USAGE_KEY) || '0');
}

export function getRemainingUsage() {
    return Math.max(0, MAX_FREE_USAGE - getCurrentUsage());
}

export function hasRemainingUsage() {
    return getCurrentUsage() < MAX_FREE_USAGE;
}

export function incrementUsage() {
    const currentUsage = getCurrentUsage();
    const newUsage = currentUsage + 1;
    localStorage.setItem(USAGE_KEY, newUsage.toString());
    return newUsage;
}

export function resetUsage() {
    localStorage.removeItem(USAGE_KEY);
    return 0;
}

export function getMaxFreeUsage() {
    return MAX_FREE_USAGE;
}

export function updateRemainingUsesDisplay() {
    const remainingUsesEl = document.getElementById('remainingUses');
    if (remainingUsesEl) {
        remainingUsesEl.textContent = getRemainingUsage();
    }
}
```

### frontend\public\js\introduction\utils.js
```js
// utils.js 

// Toast notification system
export function showToast(message, type = 'success', duration = 5000) {
    const existingToasts = document.querySelectorAll('.toast');
    existingToasts.forEach(toast => toast.remove());
    
    const toast = document.createElement('div');
    toast.className = `toast show ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    const hideTimeout = setTimeout(() => {
        if (toast.parentNode) {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }
    }, duration);
    
    toast.addEventListener('click', () => {
        clearTimeout(hideTimeout);
        toast.classList.remove('show');
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 300);
    });
}

export function showLoading(show = true) {
    let overlay = document.getElementById('loadingOverlay');
    
    if (overlay) {
        overlay.style.display = show ? 'flex' : 'none';
    }
}

export function showCustomAlert(message, type = 'info', duration = 3000) {
    showToast(message, type, duration);
}

export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Check if user is logged in
export function isLoggedIn() {
    return !!(
        localStorage.getItem('loggedInAs_user') ||
        localStorage.getItem('loggedInAs_admin') 
    );
}
```
